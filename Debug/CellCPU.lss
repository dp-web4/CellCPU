
CellCPU.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000074  00000000  00000000  000000f4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00000074  000005d6  2**0
                  ALLOC
  2 .fuse         00000003  00820000  00820000  00000b56  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  3 .comment      0000002f  00000000  00000000  00000b59  2**0
                  CONTENTS, READONLY
  4 .stack.descriptors.hdr 0000000e  00000000  00000000  00000b88  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 000000b8  00000000  00000000  00000b96  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000201b  00000000  00000000  00000c4e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000945  00000000  00000000  00002c69  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000daa  00000000  00000000  000035ae  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000048c  00000000  00000000  00004358  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000280  00000000  00000000  000047e4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000a96  00000000  00000000  00004a64  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .text         00000002  00000a58  00000a58  00000b4c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 13 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000054fc  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .text         00000024  00000a26  00000a26  00000b1a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 15 .text         00000178  000007f6  000007f6  000008ea  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 16 .text         00000314  000004e2  000004e2  000005d6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 17 .bss          0000000e  0080006f  0080006f  00000b56  2**0
                  ALLOC
 18 .text         000000b8  0000096e  0000096e  00000a62  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 19 .text         0000046e  00000074  00000074  00000168  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 20 .bss          0000000f  00800060  00800060  00000b56  2**0
                  ALLOC
 21 .text.__dummy_fini 00000002  00000a5a  00000a5a  00000b4e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 22 .text.__dummy_funcs_on_exit 00000002  00000a5c  00000a5c  00000b50  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 23 .text.__dummy_simulator_exit 00000002  00000a5e  00000a5e  00000b52  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 24 .text.exit    0000000e  00000a4a  00000a4a  00000b3e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 25 .text._Exit   00000002  00000a60  00000a60  00000b54  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE

Disassembly of section .text:

00000000 <__vectors>:
   0:	11 c0       	rjmp	.+34     	; 0x24 <__ctors_end>
   2:	b7 c3       	rjmp	.+1902   	; 0x772 <__vector_1>
   4:	37 c0       	rjmp	.+110    	; 0x74 <_etext>
   6:	28 c5       	rjmp	.+2640   	; 0xa58 <__bad_interrupt>
   8:	ba c3       	rjmp	.+1908   	; 0x77e <__vector_4>
   a:	bf c3       	rjmp	.+1918   	; 0x78a <__vector_5>
   c:	d0 c3       	rjmp	.+1952   	; 0x7ae <__vector_6>
   e:	d5 c3       	rjmp	.+1962   	; 0x7ba <__vector_7>
  10:	23 c5       	rjmp	.+2630   	; 0xa58 <__bad_interrupt>
  12:	22 c5       	rjmp	.+2628   	; 0xa58 <__bad_interrupt>
  14:	60 c1       	rjmp	.+704    	; 0x2d6 <__vector_10>
  16:	cb c0       	rjmp	.+406    	; 0x1ae <__vector_11>
  18:	1f c5       	rjmp	.+2622   	; 0xa58 <__bad_interrupt>
  1a:	bd c3       	rjmp	.+1914   	; 0x796 <__vector_13>
  1c:	c2 c3       	rjmp	.+1924   	; 0x7a2 <__vector_14>

0000001e <.dinit>:
  1e:	00 60       	ori	r16, 0x00	; 0
  20:	00 7d       	andi	r16, 0xD0	; 208
  22:	80 00       	.word	0x0080	; ????

00000024 <__ctors_end>:
  24:	11 24       	eor	r1, r1
  26:	1f be       	out	0x3f, r1	; 63
  28:	cf e5       	ldi	r28, 0x5F	; 95
  2a:	d1 e0       	ldi	r29, 0x01	; 1
  2c:	de bf       	out	0x3e, r29	; 62
  2e:	cd bf       	out	0x3d, r28	; 61

00000030 <__do_copy_data>:
  30:	ee e1       	ldi	r30, 0x1E	; 30
  32:	f0 e0       	ldi	r31, 0x00	; 0
  34:	40 e0       	ldi	r20, 0x00	; 0
  36:	17 c0       	rjmp	.+46     	; 0x66 <__do_clear_bss+0x8>
  38:	b5 91       	lpm	r27, Z+
  3a:	a5 91       	lpm	r26, Z+
  3c:	35 91       	lpm	r19, Z+
  3e:	25 91       	lpm	r18, Z+
  40:	05 91       	lpm	r16, Z+
  42:	07 fd       	sbrc	r16, 7
  44:	0c c0       	rjmp	.+24     	; 0x5e <__do_clear_bss>
  46:	95 91       	lpm	r25, Z+
  48:	85 91       	lpm	r24, Z+
  4a:	ef 01       	movw	r28, r30
  4c:	f9 2f       	mov	r31, r25
  4e:	e8 2f       	mov	r30, r24
  50:	05 90       	lpm	r0, Z+
  52:	0d 92       	st	X+, r0
  54:	a2 17       	cp	r26, r18
  56:	b3 07       	cpc	r27, r19
  58:	d9 f7       	brne	.-10     	; 0x50 <__SREG__+0x11>
  5a:	fe 01       	movw	r30, r28
  5c:	04 c0       	rjmp	.+8      	; 0x66 <__do_clear_bss+0x8>

0000005e <__do_clear_bss>:
  5e:	1d 92       	st	X+, r1
  60:	a2 17       	cp	r26, r18
  62:	b3 07       	cpc	r27, r19
  64:	e1 f7       	brne	.-8      	; 0x5e <__do_clear_bss>
  66:	e3 32       	cpi	r30, 0x23	; 35
  68:	f4 07       	cpc	r31, r20
  6a:	31 f7       	brne	.-52     	; 0x38 <__do_copy_data+0x8>
  6c:	b2 d2       	rcall	.+1380   	; 0x5d2 <main>
  6e:	ed c4       	rjmp	.+2522   	; 0xa4a <exit>

00000070 <_exit>:
  70:	f8 94       	cli

00000072 <__stop_program>:
  72:	ff cf       	rjmp	.-2      	; 0x72 <__stop_program>

Disassembly of section .text:

00000a58 <__bad_interrupt>:
 a58:	d3 ca       	rjmp	.-2650   	; 0x0 <__TEXT_REGION_ORIGIN__>

Disassembly of section .text:

00000a26 <ADCRead>:
uint16_t ADCRead(void)
{
	uint16_t u16Reading;
	
    // Set the prescaler to clock/2 & enable ADC
    ADCSRA |= (1 << ADPS0) | (1 << ADEN);
 a26:	86 b1       	in	r24, 0x06	; 6
 a28:	81 68       	ori	r24, 0x81	; 129
 a2a:	86 b9       	out	0x06, r24	; 6

	// Minor delay so we get a reasonable value
	Delay(20);
 a2c:	84 e1       	ldi	r24, 0x14	; 20
 a2e:	90 e0       	ldi	r25, 0x00	; 0
 a30:	58 dd       	rcall	.-1360   	; 0x4e2 <Delay>
    
    // Read the ADC in order to get a 10 bit reading of where it is.
    // Start the conversion
    ADCSRA |= (1 << ADSC);
 a32:	86 b1       	in	r24, 0x06	; 6
 a34:	80 64       	ori	r24, 0x40	; 64
 a36:	86 b9       	out	0x06, r24	; 6

    // Wait for it to finish - blocking
    while (ADCSRA & (1 << ADSC));
 a38:	36 99       	sbic	0x06, 6	; 6
 a3a:	fe cf       	rjmp	.-4      	; 0xa38 <ADCRead+0x12>
	
	// Get the actual reading
	u16Reading = ADC;
 a3c:	24 b1       	in	r18, 0x04	; 4
 a3e:	35 b1       	in	r19, 0x05	; 5
	
	// Power down the ADC
	ADCSRA &= ~(1 << ADEN);
 a40:	96 b1       	in	r25, 0x06	; 6
 a42:	9f 77       	andi	r25, 0x7F	; 127
 a44:	96 b9       	out	0x06, r25	; 6
    
    return(u16Reading);
}
 a46:	c9 01       	movw	r24, r18
 a48:	08 95       	ret

Disassembly of section .text:

000007f6 <I2CQuantizeTiming>:
}

// Causes the code to become synchronized with 
static void I2CQuantizeTiming(void)
{
	Delay(1);
 7f6:	81 e0       	ldi	r24, 0x01	; 1
 7f8:	90 e0       	ldi	r25, 0x00	; 0
 7fa:	73 de       	rcall	.-794    	; 0x4e2 <Delay>
 7fc:	08 95       	ret

000007fe <I2CBitDelay>:
#include "Platform.h"

// Delays for one I2C bit's worth of time
static void I2CBitDelay(void)
{
	Delay(5);
 7fe:	85 e0       	ldi	r24, 0x05	; 5
 800:	90 e0       	ldi	r25, 0x00	; 0
 802:	6f de       	rcall	.-802    	; 0x4e2 <Delay>
 804:	08 95       	ret

00000806 <I2CStart>:

// Send an I2C start sequence and quantize foreground code to the overflow
// timer
void I2CStart(void)
{
	I2CQuantizeTiming();
 806:	f7 df       	rcall	.-18     	; 0x7f6 <I2CQuantizeTiming>

	SDA_SET_OUTPUT();
 808:	87 b3       	in	r24, 0x17	; 23
 80a:	84 60       	ori	r24, 0x04	; 4
 80c:	87 bb       	out	0x17, r24	; 23
	SDA_HIGH();
 80e:	88 b3       	in	r24, 0x18	; 24
 810:	84 60       	ori	r24, 0x04	; 4
 812:	88 bb       	out	0x18, r24	; 24
	SCL_HIGH();
 814:	88 b3       	in	r24, 0x18	; 24
 816:	88 60       	ori	r24, 0x08	; 8
 818:	88 bb       	out	0x18, r24	; 24
	I2CBitDelay();
 81a:	f1 df       	rcall	.-30     	; 0x7fe <I2CBitDelay>
	SDA_LOW();
 81c:	88 b3       	in	r24, 0x18	; 24
 81e:	8b 7f       	andi	r24, 0xFB	; 251
 820:	88 bb       	out	0x18, r24	; 24
	I2CBitDelay();
 822:	ed df       	rcall	.-38     	; 0x7fe <I2CBitDelay>
	SCL_LOW();
 824:	88 b3       	in	r24, 0x18	; 24
 826:	87 7f       	andi	r24, 0xF7	; 247
 828:	88 bb       	out	0x18, r24	; 24
	I2CBitDelay();
 82a:	e9 df       	rcall	.-46     	; 0x7fe <I2CBitDelay>
 82c:	08 95       	ret

0000082e <I2CStop>:
}

// Send an I2C stop sequence
void I2CStop(void)
{
	I2CQuantizeTiming();
 82e:	e3 df       	rcall	.-58     	; 0x7f6 <I2CQuantizeTiming>

	SDA_LOW();
 830:	88 b3       	in	r24, 0x18	; 24
 832:	8b 7f       	andi	r24, 0xFB	; 251
 834:	88 bb       	out	0x18, r24	; 24
	I2CBitDelay();
 836:	e3 df       	rcall	.-58     	; 0x7fe <I2CBitDelay>
	SCL_HIGH();
 838:	88 b3       	in	r24, 0x18	; 24
 83a:	88 60       	ori	r24, 0x08	; 8
 83c:	88 bb       	out	0x18, r24	; 24
	I2CBitDelay();
 83e:	df df       	rcall	.-66     	; 0x7fe <I2CBitDelay>
	SDA_SET_INPUT();
 840:	87 b3       	in	r24, 0x17	; 23
 842:	8b 7f       	andi	r24, 0xFB	; 251
 844:	87 bb       	out	0x17, r24	; 23
 846:	88 b3       	in	r24, 0x18	; 24
 848:	84 60       	ori	r24, 0x04	; 4
 84a:	88 bb       	out	0x18, r24	; 24
	I2CBitDelay();
 84c:	d8 df       	rcall	.-80     	; 0x7fe <I2CBitDelay>
 84e:	08 95       	ret

00000850 <I2CTxByte>:
}

// Sends a single I2C byte. Returns false if the byte is not acked, or true if it is.
bool I2CTxByte(uint8_t u8Byte)
{
 850:	cf 93       	push	r28
 852:	df 93       	push	r29
 854:	d8 2f       	mov	r29, r24
	uint8_t u8Length = 8;			// 8 Bits to send
	bool bAck = false;

	I2CQuantizeTiming();
 856:	cf df       	rcall	.-98     	; 0x7f6 <I2CQuantizeTiming>
	SDA_SET_OUTPUT();
 858:	87 b3       	in	r24, 0x17	; 23
 85a:	84 60       	ori	r24, 0x04	; 4
 85c:	87 bb       	out	0x17, r24	; 23
}

// Sends a single I2C byte. Returns false if the byte is not acked, or true if it is.
bool I2CTxByte(uint8_t u8Byte)
{
	uint8_t u8Length = 8;			// 8 Bits to send
 85e:	c8 e0       	ldi	r28, 0x08	; 8
	bool bAck = false;

	I2CQuantizeTiming();
	SDA_SET_OUTPUT();

	while (u8Length)
 860:	13 c0       	rjmp	.+38     	; 0x888 <I2CTxByte+0x38>
	{
		if (u8Byte & 0x80)
 862:	dd 23       	and	r29, r29
 864:	24 f4       	brge	.+8      	; 0x86e <I2CTxByte+0x1e>
		{
			SDA_HIGH();
 866:	88 b3       	in	r24, 0x18	; 24
 868:	84 60       	ori	r24, 0x04	; 4
 86a:	88 bb       	out	0x18, r24	; 24
 86c:	03 c0       	rjmp	.+6      	; 0x874 <I2CTxByte+0x24>
		}
		else
		{
			SDA_LOW();
 86e:	88 b3       	in	r24, 0x18	; 24
 870:	8b 7f       	andi	r24, 0xFB	; 251
 872:	88 bb       	out	0x18, r24	; 24
		}
		
		// Drive SCL high
		SCL_HIGH();
 874:	88 b3       	in	r24, 0x18	; 24
 876:	88 60       	ori	r24, 0x08	; 8
 878:	88 bb       	out	0x18, r24	; 24
		
		I2CBitDelay();
 87a:	c1 df       	rcall	.-126    	; 0x7fe <I2CBitDelay>
		
		// Ensure SCL is low
		SCL_LOW();
 87c:	88 b3       	in	r24, 0x18	; 24
 87e:	87 7f       	andi	r24, 0xF7	; 247
 880:	88 bb       	out	0x18, r24	; 24
	
		// SDA Is now set. Delay.
		I2CBitDelay();
 882:	bd df       	rcall	.-134    	; 0x7fe <I2CBitDelay>
		
		// Next bit
		u8Byte <<= 1;	
 884:	dd 0f       	add	r29, r29
		u8Length--;
 886:	c1 50       	subi	r28, 0x01	; 1
	bool bAck = false;

	I2CQuantizeTiming();
	SDA_SET_OUTPUT();

	while (u8Length)
 888:	c1 11       	cpse	r28, r1
 88a:	eb cf       	rjmp	.-42     	; 0x862 <I2CTxByte+0x12>
		// Next bit
		u8Byte <<= 1;	
		u8Length--;
	}
	
	SDA_SET_INPUT();
 88c:	87 b3       	in	r24, 0x17	; 23
 88e:	8b 7f       	andi	r24, 0xFB	; 251
 890:	87 bb       	out	0x17, r24	; 23
 892:	88 b3       	in	r24, 0x18	; 24
 894:	84 60       	ori	r24, 0x04	; 4
 896:	88 bb       	out	0x18, r24	; 24
	SCL_HIGH();
 898:	88 b3       	in	r24, 0x18	; 24
 89a:	88 60       	ori	r24, 0x08	; 8
 89c:	88 bb       	out	0x18, r24	; 24
	I2CBitDelay();
 89e:	af df       	rcall	.-162    	; 0x7fe <I2CBitDelay>
	
	// See if the byte was acknowledged
	if (SDA_READ())
 8a0:	b2 9b       	sbis	0x16, 2	; 22
	{
		bAck = false;
	}
	else
	{
		bAck = true;
 8a2:	c1 e0       	ldi	r28, 0x01	; 1
	}
	
	SCL_LOW();
 8a4:	88 b3       	in	r24, 0x18	; 24
 8a6:	87 7f       	andi	r24, 0xF7	; 247
 8a8:	88 bb       	out	0x18, r24	; 24
	I2CBitDelay();
 8aa:	a9 df       	rcall	.-174    	; 0x7fe <I2CBitDelay>
	return(bAck);
}
 8ac:	8c 2f       	mov	r24, r28
 8ae:	df 91       	pop	r29
 8b0:	cf 91       	pop	r28
 8b2:	08 95       	ret

000008b4 <I2CRxByte>:

// Receives a single I2C byte and will optionally generate an ack at the end
uint8_t I2CRxByte(bool bAck)
{
 8b4:	1f 93       	push	r17
 8b6:	cf 93       	push	r28
 8b8:	df 93       	push	r29
 8ba:	18 2f       	mov	r17, r24
	uint8_t u8Data = 0;
	uint8_t u8Count = 8;
	
	I2CQuantizeTiming();
 8bc:	9c df       	rcall	.-200    	; 0x7f6 <I2CQuantizeTiming>

	SDA_SET_INPUT();
 8be:	87 b3       	in	r24, 0x17	; 23
 8c0:	8b 7f       	andi	r24, 0xFB	; 251
 8c2:	87 bb       	out	0x17, r24	; 23
 8c4:	88 b3       	in	r24, 0x18	; 24
 8c6:	84 60       	ori	r24, 0x04	; 4
 8c8:	88 bb       	out	0x18, r24	; 24

// Receives a single I2C byte and will optionally generate an ack at the end
uint8_t I2CRxByte(bool bAck)
{
	uint8_t u8Data = 0;
	uint8_t u8Count = 8;
 8ca:	c8 e0       	ldi	r28, 0x08	; 8
}

// Receives a single I2C byte and will optionally generate an ack at the end
uint8_t I2CRxByte(bool bAck)
{
	uint8_t u8Data = 0;
 8cc:	d0 e0       	ldi	r29, 0x00	; 0
	I2CQuantizeTiming();

	SDA_SET_INPUT();
	
	// Consume all 8 data bits
	while (u8Count)
 8ce:	0c c0       	rjmp	.+24     	; 0x8e8 <I2CRxByte+0x34>
	{
		u8Data <<= 1;
 8d0:	dd 0f       	add	r29, r29

		SCL_HIGH();
 8d2:	88 b3       	in	r24, 0x18	; 24
 8d4:	88 60       	ori	r24, 0x08	; 8
 8d6:	88 bb       	out	0x18, r24	; 24
		I2CBitDelay();
 8d8:	92 df       	rcall	.-220    	; 0x7fe <I2CBitDelay>
			
		if (SDA_READ())
 8da:	b2 99       	sbic	0x16, 2	; 22
		{
			u8Data |= 1;
 8dc:	d1 60       	ori	r29, 0x01	; 1
		}
		
		SCL_LOW();
 8de:	88 b3       	in	r24, 0x18	; 24
 8e0:	87 7f       	andi	r24, 0xF7	; 247
 8e2:	88 bb       	out	0x18, r24	; 24
		I2CBitDelay();
 8e4:	8c df       	rcall	.-232    	; 0x7fe <I2CBitDelay>
		u8Count--;
 8e6:	c1 50       	subi	r28, 0x01	; 1
	I2CQuantizeTiming();

	SDA_SET_INPUT();
	
	// Consume all 8 data bits
	while (u8Count)
 8e8:	c1 11       	cpse	r28, r1
 8ea:	f2 cf       	rjmp	.-28     	; 0x8d0 <I2CRxByte+0x1c>
		I2CBitDelay();
		u8Count--;
	}

	// See if we acknowledge this
	SDA_SET_OUTPUT();
 8ec:	87 b3       	in	r24, 0x17	; 23
 8ee:	84 60       	ori	r24, 0x04	; 4
 8f0:	87 bb       	out	0x17, r24	; 23
	if (bAck)
 8f2:	11 23       	and	r17, r17
 8f4:	21 f0       	breq	.+8      	; 0x8fe <I2CRxByte+0x4a>
	{
		SDA_LOW();
 8f6:	88 b3       	in	r24, 0x18	; 24
 8f8:	8b 7f       	andi	r24, 0xFB	; 251
 8fa:	88 bb       	out	0x18, r24	; 24
 8fc:	03 c0       	rjmp	.+6      	; 0x904 <I2CRxByte+0x50>
	}
	else
	{
		SDA_HIGH();
 8fe:	88 b3       	in	r24, 0x18	; 24
 900:	84 60       	ori	r24, 0x04	; 4
 902:	88 bb       	out	0x18, r24	; 24
	}
	
	I2CBitDelay();
 904:	7c df       	rcall	.-264    	; 0x7fe <I2CBitDelay>
	SCL_HIGH();
 906:	88 b3       	in	r24, 0x18	; 24
 908:	88 60       	ori	r24, 0x08	; 8
 90a:	88 bb       	out	0x18, r24	; 24
	I2CBitDelay();
 90c:	78 df       	rcall	.-272    	; 0x7fe <I2CBitDelay>
	SCL_LOW();
 90e:	88 b3       	in	r24, 0x18	; 24
 910:	87 7f       	andi	r24, 0xF7	; 247
 912:	88 bb       	out	0x18, r24	; 24
	I2CBitDelay();
 914:	74 df       	rcall	.-280    	; 0x7fe <I2CBitDelay>
	SDA_LOW();
 916:	88 b3       	in	r24, 0x18	; 24
 918:	8b 7f       	andi	r24, 0xFB	; 251
 91a:	88 bb       	out	0x18, r24	; 24

	return(u8Data);	
}
 91c:	8d 2f       	mov	r24, r29
 91e:	df 91       	pop	r29
 920:	cf 91       	pop	r28
 922:	1f 91       	pop	r17
 924:	08 95       	ret

00000926 <I2CSetup>:
// Prepares the SCL/SDA pins for I2C operation and returns when the CPU is
// quantized to the timer (for consistent bit alignment)
void I2CSetup(void)
{
	// Deassert SCL and SDA
	SCL_HIGH();
 926:	88 b3       	in	r24, 0x18	; 24
 928:	88 60       	ori	r24, 0x08	; 8
 92a:	88 bb       	out	0x18, r24	; 24
	SDA_HIGH();
 92c:	88 b3       	in	r24, 0x18	; 24
 92e:	84 60       	ori	r24, 0x04	; 4
 930:	88 bb       	out	0x18, r24	; 24

	// Set SCL and SDA lines as push/pull output drives
	SCL_SET_OUTPUT();
 932:	87 b3       	in	r24, 0x17	; 23
 934:	88 60       	ori	r24, 0x08	; 8
 936:	87 bb       	out	0x17, r24	; 23
	
	// Turn on SDA, set as an input
	SDA_SET_INPUT();
 938:	87 b3       	in	r24, 0x17	; 23
 93a:	8b 7f       	andi	r24, 0xFB	; 251
 93c:	87 bb       	out	0x17, r24	; 23
 93e:	88 b3       	in	r24, 0x18	; 24
 940:	84 60       	ori	r24, 0x04	; 4
 942:	88 bb       	out	0x18, r24	; 24
	
	Delay(20);
 944:	84 e1       	ldi	r24, 0x14	; 20
 946:	90 e0       	ldi	r25, 0x00	; 0
 948:	cc dd       	rcall	.-1128   	; 0x4e2 <Delay>
 94a:	08 95       	ret

0000094c <I2CStartTransaction>:

// Sets up the I2C pins, sends slave address/read/write byte, and waits for acknowledgment.
// Returns false if no device is responding.
bool I2CStartTransaction(uint8_t u8SlaveAddress,
						 bool bRead)
{
 94c:	cf 93       	push	r28
 94e:	df 93       	push	r29
 950:	c8 2f       	mov	r28, r24
 952:	d6 2f       	mov	r29, r22
	// Set up the pins for I2C operation
	I2CSetup();
 954:	e8 df       	rcall	.-48     	; 0x926 <I2CSetup>
	
	// I2C Start condition
	I2CStart();
 956:	57 df       	rcall	.-338    	; 0x806 <I2CStart>

	// If it's a read operation, clear the lower bit
	if (bRead)
 958:	dd 23       	and	r29, r29
 95a:	19 f0       	breq	.+6      	; 0x962 <I2CStartTransaction+0x16>
	{
		u8SlaveAddress |= 1;
 95c:	8c 2f       	mov	r24, r28
 95e:	81 60       	ori	r24, 0x01	; 1
 960:	02 c0       	rjmp	.+4      	; 0x966 <I2CStartTransaction+0x1a>
	}
	else
	{
		// Otherwise set it
		u8SlaveAddress &= (uint8_t) (~1);
 962:	8c 2f       	mov	r24, r28
 964:	8e 7f       	andi	r24, 0xFE	; 254
	}
	
	// Now send out the slave address + the read/write bit
	return(I2CTxByte(u8SlaveAddress));
 966:	74 df       	rcall	.-280    	; 0x850 <I2CTxByte>
}
 968:	df 91       	pop	r29
 96a:	cf 91       	pop	r28
 96c:	08 95       	ret

Disassembly of section .text:

000004e2 <Delay>:
// next timer tick change.
void Delay(uint16_t u16Ticks)
{
	uint8_t u8Sample;
	
	u16Ticks++;
 4e2:	ac 01       	movw	r20, r24
 4e4:	4f 5f       	subi	r20, 0xFF	; 255
 4e6:	5f 4f       	sbci	r21, 0xFF	; 255
	
	u8Sample = TIMER_COUNTER();
 4e8:	22 b7       	in	r18, 0x32	; 50
	while (u16Ticks)
 4ea:	06 c0       	rjmp	.+12     	; 0x4f8 <Delay+0x16>
	{
		// Wait until we quantize
		while (u8Sample == TIMER_COUNTER());
 4ec:	92 b7       	in	r25, 0x32	; 50
 4ee:	29 17       	cp	r18, r25
 4f0:	e9 f3       	breq	.-6      	; 0x4ec <Delay+0xa>
		
		u8Sample = TIMER_COUNTER();
 4f2:	22 b7       	in	r18, 0x32	; 50
		--u16Ticks;
 4f4:	41 50       	subi	r20, 0x01	; 1
 4f6:	51 09       	sbc	r21, r1
	uint8_t u8Sample;
	
	u16Ticks++;
	
	u8Sample = TIMER_COUNTER();
	while (u16Ticks)
 4f8:	41 15       	cp	r20, r1
 4fa:	51 05       	cpc	r21, r1
 4fc:	b9 f7       	brne	.-18     	; 0x4ec <Delay+0xa>
		while (u8Sample == TIMER_COUNTER());
		
		u8Sample = TIMER_COUNTER();
		--u16Ticks;
	}
}
 4fe:	08 95       	ret

00000500 <Celldn_txDataAvailable>:
// Returns true if cell data is available. See message above for the meaning of >=4
bool Celldn_txDataAvailable(void)
{
	// We signal no more data available at the 4th byte (offset 3)
	// but still need to transmit the final byte.
	if (sg_u8TransmitOffset >= 4)
 500:	80 91 70 00 	lds	r24, 0x0070	; 0x800070 <sg_u8TransmitOffset>
 504:	84 30       	cpi	r24, 0x04	; 4
 506:	10 f0       	brcs	.+4      	; 0x50c <Celldn_txDataAvailable+0xc>
	{
		return(false);
 508:	80 e0       	ldi	r24, 0x00	; 0
 50a:	08 95       	ret
	}
	
	return(true);
 50c:	81 e0       	ldi	r24, 0x01	; 1
}
 50e:	08 95       	ret

00000510 <Celldn_txDataGet>:
// Returns the next byte of cell data we want to transmit to the next cell, etc... module controller
uint8_t Celldn_txDataGet(void)
{
	uint8_t u8Data = 0xff;
	
	if (0 == sg_u8TransmitOffset)
 510:	90 91 70 00 	lds	r25, 0x0070	; 0x800070 <sg_u8TransmitOffset>
 514:	91 11       	cpse	r25, r1
 516:	03 c0       	rjmp	.+6      	; 0x51e <Celldn_txDataGet+0xe>
	{
		// 0 - LSB Voltage
		u8Data = (uint8_t) sg_u16BatteryVoltage;
 518:	80 91 7b 00 	lds	r24, 0x007B	; 0x80007b <sg_u16BatteryVoltage>
 51c:	16 c0       	rjmp	.+44     	; 0x54a <Celldn_txDataGet+0x3a>
	}
	else
	if (1 == sg_u8TransmitOffset)
 51e:	91 30       	cpi	r25, 0x01	; 1
 520:	19 f4       	brne	.+6      	; 0x528 <Celldn_txDataGet+0x18>
	{
		// 1 - MSB Voltage
		u8Data = (uint8_t) (sg_u16BatteryVoltage >> 8);
 522:	80 91 7c 00 	lds	r24, 0x007C	; 0x80007c <sg_u16BatteryVoltage+0x1>
 526:	11 c0       	rjmp	.+34     	; 0x54a <Celldn_txDataGet+0x3a>
	}
	else
	if (2 == sg_u8TransmitOffset)
 528:	92 30       	cpi	r25, 0x02	; 2
 52a:	31 f4       	brne	.+12     	; 0x538 <Celldn_txDataGet+0x28>
	{
		// 2 - LSB Temperature
		u8Data = (uint8_t) sg_u16BatteryTemperature;
 52c:	20 91 79 00 	lds	r18, 0x0079	; 0x800079 <sg_u16BatteryTemperature>
 530:	30 91 7a 00 	lds	r19, 0x007A	; 0x80007a <sg_u16BatteryTemperature+0x1>
 534:	82 2f       	mov	r24, r18
 536:	09 c0       	rjmp	.+18     	; 0x54a <Celldn_txDataGet+0x3a>
	}
	else
	if (3 == sg_u8TransmitOffset)
 538:	93 30       	cpi	r25, 0x03	; 3
 53a:	31 f4       	brne	.+12     	; 0x548 <Celldn_txDataGet+0x38>
	{
		// 3 - MSB Temperature
		u8Data = (uint8_t) (sg_u16BatteryTemperature >> 8);
 53c:	20 91 79 00 	lds	r18, 0x0079	; 0x800079 <sg_u16BatteryTemperature>
 540:	30 91 7a 00 	lds	r19, 0x007A	; 0x80007a <sg_u16BatteryTemperature+0x1>
 544:	83 2f       	mov	r24, r19
 546:	01 c0       	rjmp	.+2      	; 0x54a <Celldn_txDataGet+0x3a>
}

// Returns the next byte of cell data we want to transmit to the next cell, etc... module controller
uint8_t Celldn_txDataGet(void)
{
	uint8_t u8Data = 0xff;
 548:	8f ef       	ldi	r24, 0xFF	; 255
	{
		// 3 - MSB Temperature
		u8Data = (uint8_t) (sg_u16BatteryTemperature >> 8);
	}
	
	sg_u8TransmitOffset++;
 54a:	9f 5f       	subi	r25, 0xFF	; 255
 54c:	90 93 70 00 	sts	0x0070, r25	; 0x800070 <sg_u8TransmitOffset>
	return(u8Data);
}
 550:	08 95       	ret

00000552 <Celldn_txDataReset>:
// Resets the cell data state machine if necessary. This is called upon the falling
// edge of the start of a receive stream.
void Celldn_txDataReset(void)
{
	// Offset back to 0
	sg_u8TransmitOffset = 0;
 552:	10 92 70 00 	sts	0x0070, r1	; 0x800070 <sg_u8TransmitOffset>
 556:	08 95       	ret

00000558 <Celldn_txTransmitStart>:

// Called right before data is transmitted/appended
void Celldn_txTransmitStart(void)
{
	// Sending the 0th byte
	sg_u8TransmitOffset = 0;
 558:	10 92 70 00 	sts	0x0070, r1	; 0x800070 <sg_u8TransmitOffset>
 55c:	08 95       	ret

0000055e <Celldn_rxDataStart>:
// type.

// Called when start of message from module controller or upstream is started
void Celldn_rxDataStart(void)
{
	sg_u8dn_rxBitCount = 0;
 55e:	10 92 6f 00 	sts	0x006F, r1	; 0x80006f <sg_u8dn_rxBitCount>
	sg_u16BatteryVoltageMsg = 0;
 562:	10 92 74 00 	sts	0x0074, r1	; 0x800074 <sg_u16BatteryVoltageMsg+0x1>
 566:	10 92 73 00 	sts	0x0073, r1	; 0x800073 <sg_u16BatteryVoltageMsg>
 56a:	08 95       	ret

0000056c <Celldn_rxDataBit>:
// for further specific illustration.

// Called for each received bit from the dn_rx direction (from the module controller)
void Celldn_rxDataBit(uint8_t u8DataBit)
{
	sg_u16BatteryVoltageMsg <<= 1;
 56c:	20 91 73 00 	lds	r18, 0x0073	; 0x800073 <sg_u16BatteryVoltageMsg>
 570:	30 91 74 00 	lds	r19, 0x0074	; 0x800074 <sg_u16BatteryVoltageMsg+0x1>
 574:	22 0f       	add	r18, r18
 576:	33 1f       	adc	r19, r19
	sg_u16BatteryVoltageMsg |= u8DataBit;
 578:	a9 01       	movw	r20, r18
 57a:	48 2b       	or	r20, r24
 57c:	ca 01       	movw	r24, r20
 57e:	90 93 74 00 	sts	0x0074, r25	; 0x800074 <sg_u16BatteryVoltageMsg+0x1>
 582:	80 93 73 00 	sts	0x0073, r24	; 0x800073 <sg_u16BatteryVoltageMsg>
	sg_u8dn_rxBitCount++;
 586:	20 91 6f 00 	lds	r18, 0x006F	; 0x80006f <sg_u8dn_rxBitCount>
 58a:	2f 5f       	subi	r18, 0xFF	; 255
 58c:	20 93 6f 00 	sts	0x006F, r18	; 0x80006f <sg_u8dn_rxBitCount>

	// Special case after reception of the second data bit - if this is
	// a request for a reading, then signal the foreground code to do
	// a sensor reading. This hastens the response time of the initial request.

	if (2 == sg_u8dn_rxBitCount)
 590:	22 30       	cpi	r18, 0x02	; 2
 592:	91 f4       	brne	.+36     	; 0x5b8 <Celldn_rxDataBit+0x4c>
	{
		// After the second bit, let's see if we send a report. If so, then flag it
		// and record the type. The shift is necessary because we haven't received all 
		// 16 bits yet - just look at the two that we've received.
		if (sg_u16BatteryVoltageMsg & (MSG_CELL_SEND_REPORT >> 14))
 594:	81 ff       	sbrs	r24, 1
 596:	1c c0       	rjmp	.+56     	; 0x5d0 <Celldn_rxDataBit+0x64>
		{
			// Indicates we want the cell CPU to send a report. Figure out which type.
			if (sg_u16BatteryVoltageMsg & (MSG_CELL_SEND_PATTERN >> 14))
 598:	80 ff       	sbrs	r24, 0
 59a:	07 c0       	rjmp	.+14     	; 0x5aa <Celldn_rxDataBit+0x3e>
			{
				sg_eCellAction = EACTION_SEND_PATTERN;
 59c:	82 e0       	ldi	r24, 0x02	; 2
 59e:	90 e0       	ldi	r25, 0x00	; 0
 5a0:	90 93 72 00 	sts	0x0072, r25	; 0x800072 <sg_eCellAction+0x1>
 5a4:	80 93 71 00 	sts	0x0071, r24	; 0x800071 <sg_eCellAction>
 5a8:	08 95       	ret
				// chain, this will cause a reading to occur, then it will
				// originate transmission up the chain by sending its reading
				// to the next neighboring CPU. If it's not the CPU on the end,
				// it will simply perform the reading and wait for the downstream
				// message to append itself to.
				sg_eCellAction = EACTION_SEND_SENSOR_READING;
 5aa:	81 e0       	ldi	r24, 0x01	; 1
 5ac:	90 e0       	ldi	r25, 0x00	; 0
 5ae:	90 93 72 00 	sts	0x0072, r25	; 0x800072 <sg_eCellAction+0x1>
 5b2:	80 93 71 00 	sts	0x0071, r24	; 0x800071 <sg_eCellAction>
 5b6:	08 95       	ret
		{
			// This is a new discharge target - ignore it
		}
	}
	else
	if (16 == sg_u8dn_rxBitCount)
 5b8:	20 31       	cpi	r18, 0x10	; 16
 5ba:	51 f4       	brne	.+20     	; 0x5d0 <Celldn_rxDataBit+0x64>
	{
		if (sg_u16BatteryVoltageMsg & MSG_CELL_SEND_REPORT)
 5bc:	99 23       	and	r25, r25
 5be:	24 f0       	brlt	.+8      	; 0x5c8 <Celldn_rxDataBit+0x5c>
			// We don't do anything because it already happened at bit 2 above.
		}
		else
		{
			// New voltage target - no need to mask off the upper bits since they'll be 0 here
			sg_u16BatteryVoltageTarget = sg_u16BatteryVoltageMsg;
 5c0:	90 93 78 00 	sts	0x0078, r25	; 0x800078 <sg_u16BatteryVoltageTarget+0x1>
 5c4:	80 93 77 00 	sts	0x0077, r24	; 0x800077 <sg_u16BatteryVoltageTarget>
		}
		
		sg_u16BatteryVoltageMsg = 0;
 5c8:	10 92 74 00 	sts	0x0074, r1	; 0x800074 <sg_u16BatteryVoltageMsg+0x1>
 5cc:	10 92 73 00 	sts	0x0073, r1	; 0x800073 <sg_u16BatteryVoltageMsg>
 5d0:	08 95       	ret

000005d2 <main>:
*/

int main(void)
{
	// Stop all interrupts
	cli();
 5d2:	f8 94       	cli
	
	// Shut off the watchdog timer and reset reason
	MCUSR = 0;
 5d4:	14 be       	out	0x34, r1	; 52
	DISABLE_WDT();
 5d6:	81 b5       	in	r24, 0x21	; 33
 5d8:	88 61       	ori	r24, 0x18	; 24
 5da:	81 bd       	out	0x21, r24	; 33
 5dc:	11 bc       	out	0x21, r1	; 33
	
	// Init CPU clock
	CPU_CLOCK_INIT();
 5de:	80 e8       	ldi	r24, 0x80	; 128
 5e0:	86 bd       	out	0x26, r24	; 38
 5e2:	16 bc       	out	0x26, r1	; 38
 5e4:	15 ba       	out	0x15, r1	; 21
 5e6:	10 bc       	out	0x20, r1	; 32
	
	// Ensure pullups aren't globally disabled
	MCUCR &= (uint8_t) ~(1 << PUD);
 5e8:	85 b7       	in	r24, 0x35	; 53
 5ea:	8f 7b       	andi	r24, 0xBF	; 191
 5ec:	85 bf       	out	0x35, r24	; 53
	
	// Initialize virtual UART pins
	vUARTPinInit();
 5ee:	45 df       	rcall	.-374    	; 0x47a <vUARTPinInit>
	
    // Set the ADC input to MUX_SELECT
    ADC_ADMUX_SET();
 5f0:	83 e8       	ldi	r24, 0x83	; 131
 5f2:	87 b9       	out	0x07, r24	; 7
	
	// Drive cell_dn_tx low. This is required so we can detect if we're end-of-chain
	// or not.
	CELL_DN_TX_ASSERT();
 5f4:	88 b3       	in	r24, 0x18	; 24
 5f6:	8f 7d       	andi	r24, 0xDF	; 223
 5f8:	88 bb       	out	0x18, r24	; 24
	
	// Now init timer B
	TIMER_INIT();
 5fa:	1a bc       	out	0x2a, r1	; 42
 5fc:	82 e0       	ldi	r24, 0x02	; 2
 5fe:	83 bf       	out	0x33, r24	; 51
 600:	12 be       	out	0x32, r1	; 50
	
	// Set battery target voltage so the event/discharge is forced off
	sg_u16BatteryVoltageTarget = 0xffff;
 602:	8f ef       	ldi	r24, 0xFF	; 255
 604:	9f ef       	ldi	r25, 0xFF	; 255
 606:	90 93 78 00 	sts	0x0078, r25	; 0x800078 <sg_u16BatteryVoltageTarget+0x1>
 60a:	80 93 77 00 	sts	0x0077, r24	; 0x800077 <sg_u16BatteryVoltageTarget>
	
	// This will cause discharge to get shut off initially
	sg_bDischargeActive = true;
 60e:	91 e0       	ldi	r25, 0x01	; 1
 610:	90 93 76 00 	sts	0x0076, r25	; 0x800076 <sg_bDischargeActive>

	// Turn on interrupt functionality but no specific interrupts
	INT_ENABLE();
 614:	80 e2       	ldi	r24, 0x20	; 32
 616:	8b bf       	out	0x3b, r24	; 59
 618:	85 b7       	in	r24, 0x35	; 53
 61a:	8c 7f       	andi	r24, 0xFC	; 252
 61c:	81 60       	ori	r24, 0x01	; 1
 61e:	85 bf       	out	0x35, r24	; 53
	
	// First thing is an init/sensor read
	sg_eCellAction = EACTION_INIT;
 620:	23 e0       	ldi	r18, 0x03	; 3
 622:	30 e0       	ldi	r19, 0x00	; 0
 624:	30 93 72 00 	sts	0x0072, r19	; 0x800072 <sg_eCellAction+0x1>
 628:	20 93 71 00 	sts	0x0071, r18	; 0x800071 <sg_eCellAction>
	sg_bCellCPULast = true;  // assume we're last in the chain
 62c:	90 93 75 00 	sts	0x0075, r25	; 0x800075 <sg_bCellCPULast>

	// Enable CPU interrupts
	sei();
 630:	78 94       	sei
	{
		uint16_t u16Voltage;
		uint16_t u16Temperature;

		if ((EACTION_SEND_SENSOR_READING == sg_eCellAction) ||
			(EACTION_SEND_PATTERN == sg_eCellAction) || 
 632:	80 91 71 00 	lds	r24, 0x0071	; 0x800071 <sg_eCellAction>
 636:	90 91 72 00 	lds	r25, 0x0072	; 0x800072 <sg_eCellAction+0x1>
 63a:	01 97       	sbiw	r24, 0x01	; 1
	while (1)
	{
		uint16_t u16Voltage;
		uint16_t u16Temperature;

		if ((EACTION_SEND_SENSOR_READING == sg_eCellAction) ||
 63c:	03 97       	sbiw	r24, 0x03	; 3
 63e:	08 f0       	brcs	.+2      	; 0x642 <main+0x70>
 640:	82 c0       	rjmp	.+260    	; 0x746 <main+0x174>
		{
			bool bDischargeActive = false;
			
			// Read the voltage first since the MUX is switched to the ADC
			// by default
			u16Voltage = ADCRead();
 642:	f1 d1       	rcall	.+994    	; 0xa26 <ADCRead>
 644:	ec 01       	movw	r28, r24
			sg_u16BatteryVoltage = u16Voltage;
 646:	90 93 7c 00 	sts	0x007C, r25	; 0x80007c <sg_u16BatteryVoltage+0x1>
 64a:	80 93 7b 00 	sts	0x007B, r24	; 0x80007b <sg_u16BatteryVoltage>
			
			if (IS_PIN_CELL_UP_RX_ASSERTED())  // do a quick detect prior to sensor read, but check again after
 64e:	b4 99       	sbic	0x16, 4	; 22
			{
				// Pin is asserted, we're NOT the last CPU
				sg_bCellCPULast = false;
 650:	10 92 75 00 	sts	0x0075, r1	; 0x800075 <sg_bCellCPULast>
			}

			
			// Now temperature
			u16Temperature = MCP9843ReadTemperature();
 654:	c4 d1       	rcall	.+904    	; 0x9de <MCP9843ReadTemperature>
 656:	8c 01       	movw	r16, r24

			// Analog channel is now an input
			SCL_DISABLE();
 658:	87 b3       	in	r24, 0x17	; 23
 65a:	87 7f       	andi	r24, 0xF7	; 247
 65c:	87 bb       	out	0x17, r24	; 23
 65e:	88 b3       	in	r24, 0x18	; 24
 660:	87 7f       	andi	r24, 0xF7	; 247
 662:	88 bb       	out	0x18, r24	; 24
 664:	88 b3       	in	r24, 0x18	; 24
 666:	87 7f       	andi	r24, 0xF7	; 247
 668:	88 bb       	out	0x18, r24	; 24
			
			// Set SCL back to analog input
			ADC_ADMUX_SET();
 66a:	83 e8       	ldi	r24, 0x83	; 131
 66c:	87 b9       	out	0x07, r24	; 7
			
			if (IS_PIN_CELL_UP_RX_ASSERTED())  // do a quick detect prior to possible event set, it may happen on some cells but not others
 66e:	b4 99       	sbic	0x16, 4	; 22
			{
				// Pin is asserted, we're NOT the last CPU
				sg_bCellCPULast = false;
 670:	10 92 75 00 	sts	0x0075, r1	; 0x800075 <sg_bCellCPULast>
			}
			
			
			// While we have I2C operational, let's evaluate the discharge
			// state and change it if it's updated
			if (u16Voltage > sg_u16BatteryVoltageTarget)
 674:	80 91 77 00 	lds	r24, 0x0077	; 0x800077 <sg_u16BatteryVoltageTarget>
 678:	90 91 78 00 	lds	r25, 0x0078	; 0x800078 <sg_u16BatteryVoltageTarget+0x1>
 67c:	8c 17       	cp	r24, r28
 67e:	9d 07       	cpc	r25, r29
 680:	10 f0       	brcs	.+4      	; 0x686 <main+0xb4>

		if ((EACTION_SEND_SENSOR_READING == sg_eCellAction) ||
			(EACTION_SEND_PATTERN == sg_eCellAction) || 
			(EACTION_INIT == sg_eCellAction))
		{
			bool bDischargeActive = false;
 682:	80 e0       	ldi	r24, 0x00	; 0
 684:	01 c0       	rjmp	.+2      	; 0x688 <main+0xb6>
			
			// While we have I2C operational, let's evaluate the discharge
			// state and change it if it's updated
			if (u16Voltage > sg_u16BatteryVoltageTarget)
			{
				bDischargeActive = true;
 686:	81 e0       	ldi	r24, 0x01	; 1
			}
			
			// If the discharge state has changed, tell the MCP9843 about it
			if (bDischargeActive != sg_bDischargeActive)
 688:	90 91 76 00 	lds	r25, 0x0076	; 0x800076 <sg_bDischargeActive>
 68c:	89 17       	cp	r24, r25
 68e:	a9 f0       	breq	.+42     	; 0x6ba <main+0xe8>
			{
				sg_bDischargeActive = bDischargeActive;
 690:	80 93 76 00 	sts	0x0076, r24	; 0x800076 <sg_bDischargeActive>
				
				// Discharge is active LOW on the EVENT pin
				MCP9843SetEventPin(sg_bDischargeActive ? false : true);
 694:	80 91 76 00 	lds	r24, 0x0076	; 0x800076 <sg_bDischargeActive>
 698:	88 23       	and	r24, r24
 69a:	11 f0       	breq	.+4      	; 0x6a0 <main+0xce>
 69c:	80 e0       	ldi	r24, 0x00	; 0
 69e:	01 c0       	rjmp	.+2      	; 0x6a2 <main+0xd0>
 6a0:	81 e0       	ldi	r24, 0x01	; 1
 6a2:	6f d1       	rcall	.+734    	; 0x982 <MCP9843SetEventPin>
				
				// Analog channel is now an input
				SCL_DISABLE();
 6a4:	87 b3       	in	r24, 0x17	; 23
 6a6:	87 7f       	andi	r24, 0xF7	; 247
 6a8:	87 bb       	out	0x17, r24	; 23
 6aa:	88 b3       	in	r24, 0x18	; 24
 6ac:	87 7f       	andi	r24, 0xF7	; 247
 6ae:	88 bb       	out	0x18, r24	; 24
 6b0:	88 b3       	in	r24, 0x18	; 24
 6b2:	87 7f       	andi	r24, 0xF7	; 247
 6b4:	88 bb       	out	0x18, r24	; 24
			
				// Set SCL back to analog input
				ADC_ADMUX_SET();
 6b6:	83 e8       	ldi	r24, 0x83	; 131
 6b8:	87 b9       	out	0x07, r24	; 7
			}
			
			// If we're discharging, update the battery voltage message
			if (sg_bDischargeActive)
 6ba:	80 91 76 00 	lds	r24, 0x0076	; 0x800076 <sg_bDischargeActive>
 6be:	81 11       	cpse	r24, r1
			{
				// Set the upper bit to indicate we're actively discharging
				u16Voltage |= MSG_CELL_DISCHARGE_ACTIVE;
 6c0:	d0 68       	ori	r29, 0x80	; 128
			}
			
			// If this is set, it will originate (or propagate) a pattern
			if (EACTION_SEND_PATTERN == sg_eCellAction)
 6c2:	80 91 71 00 	lds	r24, 0x0071	; 0x800071 <sg_eCellAction>
 6c6:	90 91 72 00 	lds	r25, 0x0072	; 0x800072 <sg_eCellAction+0x1>
 6ca:	02 97       	sbiw	r24, 0x02	; 2
 6cc:	69 f4       	brne	.+26     	; 0x6e8 <main+0x116>
			{
				sg_u16BatteryTemperature = PATTERN_TEMPERATURE;
 6ce:	82 e4       	ldi	r24, 0x42	; 66
 6d0:	98 e9       	ldi	r25, 0x98	; 152
 6d2:	90 93 7a 00 	sts	0x007A, r25	; 0x80007a <sg_u16BatteryTemperature+0x1>
 6d6:	80 93 79 00 	sts	0x0079, r24	; 0x800079 <sg_u16BatteryTemperature>
				sg_u16BatteryVoltage = PATTERN_VOLTAGE;
 6da:	8c ea       	ldi	r24, 0xAC	; 172
 6dc:	9f eb       	ldi	r25, 0xBF	; 191
 6de:	90 93 7c 00 	sts	0x007C, r25	; 0x80007c <sg_u16BatteryVoltage+0x1>
 6e2:	80 93 7b 00 	sts	0x007B, r24	; 0x80007b <sg_u16BatteryVoltage>
 6e6:	08 c0       	rjmp	.+16     	; 0x6f8 <main+0x126>
			}
			else
			{
				// We're sending the actual reading
				sg_u16BatteryTemperature = u16Temperature;
 6e8:	10 93 7a 00 	sts	0x007A, r17	; 0x80007a <sg_u16BatteryTemperature+0x1>
 6ec:	00 93 79 00 	sts	0x0079, r16	; 0x800079 <sg_u16BatteryTemperature>
				sg_u16BatteryVoltage = u16Voltage;
 6f0:	d0 93 7c 00 	sts	0x007C, r29	; 0x80007c <sg_u16BatteryVoltage+0x1>
 6f4:	c0 93 7b 00 	sts	0x007B, r28	; 0x80007b <sg_u16BatteryVoltage>
			}
		
			// If we're just initializing, go back to sleep. We only needed
			// the first pass to set the discharge/charge state
			// do a sample window for last cpu detection to account for any differences in arriving at this point between adjacent cpus due to I2C
			if (EACTION_INIT == sg_eCellAction)
 6f8:	80 91 71 00 	lds	r24, 0x0071	; 0x800071 <sg_eCellAction>
 6fc:	90 91 72 00 	lds	r25, 0x0072	; 0x800072 <sg_eCellAction+0x1>
 700:	03 97       	sbiw	r24, 0x03	; 3
 702:	d9 f4       	brne	.+54     	; 0x73a <main+0x168>
			{
				uint8_t sample_count = 10;  //number of times to sample UP_RX for last cpu detection
				sg_eCellAction = EACTION_NONE;
 704:	10 92 72 00 	sts	0x0072, r1	; 0x800072 <sg_eCellAction+0x1>
 708:	10 92 71 00 	sts	0x0071, r1	; 0x800071 <sg_eCellAction>
			// If we're just initializing, go back to sleep. We only needed
			// the first pass to set the discharge/charge state
			// do a sample window for last cpu detection to account for any differences in arriving at this point between adjacent cpus due to I2C
			if (EACTION_INIT == sg_eCellAction)
			{
				uint8_t sample_count = 10;  //number of times to sample UP_RX for last cpu detection
 70c:	8a e0       	ldi	r24, 0x0A	; 10
				sg_eCellAction = EACTION_NONE;
				
				// sample every 1ms
				while (sample_count--)
 70e:	07 c0       	rjmp	.+14     	; 0x71e <main+0x14c>
				{
				// If at any point we see the pin asserted, we're NOT the last
					if (IS_PIN_CELL_UP_RX_ASSERTED())
 710:	b4 99       	sbic	0x16, 4	; 22
					{
						// Pin is asserted, we're NOT the last CPU
						sg_bCellCPULast = false;
 712:	10 92 75 00 	sts	0x0075, r1	; 0x800075 <sg_bCellCPULast>
					}
					Delay(1000);  //this also gives the cell below more time to detect us
 716:	88 ee       	ldi	r24, 0xE8	; 232
 718:	93 e0       	ldi	r25, 0x03	; 3
 71a:	e3 de       	rcall	.-570    	; 0x4e2 <Delay>
			{
				uint8_t sample_count = 10;  //number of times to sample UP_RX for last cpu detection
				sg_eCellAction = EACTION_NONE;
				
				// sample every 1ms
				while (sample_count--)
 71c:	8c 2f       	mov	r24, r28
 71e:	cf ef       	ldi	r28, 0xFF	; 255
 720:	c8 0f       	add	r28, r24
 722:	81 11       	cpse	r24, r1
 724:	f5 cf       	rjmp	.-22     	; 0x710 <main+0x13e>
					Delay(1000);  //this also gives the cell below more time to detect us
				}

				
				// If we're not the last cell CPU, turn on receive interrupts
				if (false == sg_bCellCPULast)
 726:	80 91 75 00 	lds	r24, 0x0075	; 0x800075 <sg_bCellCPULast>
 72a:	81 11       	cpse	r24, r1
 72c:	01 c0       	rjmp	.+2      	; 0x730 <main+0x15e>
				{
					// Initialize the UART for receive operation (from cell CPUs to module CPUs)
					vUARTInitReceive();
 72e:	d2 de       	rcall	.-604    	; 0x4d4 <vUARTInitReceive>
					// interrupts.
				}
		
				
				// Initialize transmit communication for module->cell->cell... communication
				CELL_DN_TX_DEASSERT();				// end of last detect sample window for cell below
 730:	88 b3       	in	r24, 0x18	; 24
 732:	80 62       	ori	r24, 0x20	; 32
 734:	88 bb       	out	0x18, r24	; 24
				vUARTInitTransmit(); 
 736:	ca de       	rcall	.-620    	; 0x4cc <vUARTInitTransmit>
 738:	06 c0       	rjmp	.+12     	; 0x746 <main+0x174>
			}
			else
			{
				// We're doing a send of the data!
				sg_eCellAction = EACTION_INITIATE_TRANSMIT;
 73a:	84 e0       	ldi	r24, 0x04	; 4
 73c:	90 e0       	ldi	r25, 0x00	; 0
 73e:	90 93 72 00 	sts	0x0072, r25	; 0x800072 <sg_eCellAction+0x1>
 742:	80 93 71 00 	sts	0x0071, r24	; 0x800071 <sg_eCellAction>
			}
		}
	
		if (EACTION_INITIATE_TRANSMIT == sg_eCellAction)
 746:	80 91 71 00 	lds	r24, 0x0071	; 0x800071 <sg_eCellAction>
 74a:	90 91 72 00 	lds	r25, 0x0072	; 0x800072 <sg_eCellAction+0x1>
 74e:	04 97       	sbiw	r24, 0x04	; 4
 750:	09 f0       	breq	.+2      	; 0x754 <main+0x182>
 752:	6f cf       	rjmp	.-290    	; 0x632 <main+0x60>
		{
			sg_eCellAction = EACTION_NONE;
 754:	10 92 72 00 	sts	0x0072, r1	; 0x800072 <sg_eCellAction+0x1>
 758:	10 92 71 00 	sts	0x0071, r1	; 0x800071 <sg_eCellAction>
			
			
			// If we're the last CPU, then we initiate transmit, otherwise we
			// don't do anything - we wait for the last CPU to start the message
			// transmission.
			if (true == sg_bCellCPULast)
 75c:	80 91 75 00 	lds	r24, 0x0075	; 0x800075 <sg_bCellCPULast>
 760:	88 23       	and	r24, r24
 762:	09 f4       	brne	.+2      	; 0x766 <main+0x194>
 764:	66 cf       	rjmp	.-308    	; 0x632 <main+0x60>
			{
				// While we're receiving something, don't transmit anything. In practice, this
				// should never loop, but during development, it might.
				while (vUARTIscell_dn_rxActive());
 766:	a8 de       	rcall	.-688    	; 0x4b8 <vUARTIscell_dn_rxActive>
 768:	81 11       	cpse	r24, r1
 76a:	fd cf       	rjmp	.-6      	; 0x766 <main+0x194>
				
				// Start transmission. Note this routine stops and starts interrupts, too.
				vUARTStartcell_dn_tx(VUART_BIT_TICKS/2);
 76c:	89 e1       	ldi	r24, 0x19	; 25
 76e:	89 dd       	rcall	.-1262   	; 0x282 <vUARTStartcell_dn_tx>
 770:	60 cf       	rjmp	.-320    	; 0x632 <main+0x60>

00000772 <__vector_1>:
// NOTE: If you're getting unexpected AVR resets, uncomment these unused handlers to see
// if another interrupt is being taken that doesn't have a handler. AVR Defaults to jumping
// to 0 when not vector is programmed.

ISR(INT0_vect, ISR_BLOCK)
{
 772:	1f 92       	push	r1
 774:	0f 92       	push	r0
 776:	0f b6       	in	r0, 0x3f	; 63
 778:	0f 92       	push	r0
 77a:	11 24       	eor	r1, r1
 77c:	ff cf       	rjmp	.-2      	; 0x77c <__vector_1+0xa>

0000077e <__vector_4>:
	while (1);
}

ISR(TIMER1_OVF_vect, ISR_BLOCK)
{
 77e:	1f 92       	push	r1
 780:	0f 92       	push	r0
 782:	0f b6       	in	r0, 0x3f	; 63
 784:	0f 92       	push	r0
 786:	11 24       	eor	r1, r1
 788:	ff cf       	rjmp	.-2      	; 0x788 <__vector_4+0xa>

0000078a <__vector_5>:
	while (1);
}

ISR(TIMER0_OVF_vect, ISR_BLOCK)
{
 78a:	1f 92       	push	r1
 78c:	0f 92       	push	r0
 78e:	0f b6       	in	r0, 0x3f	; 63
 790:	0f 92       	push	r0
 792:	11 24       	eor	r1, r1
 794:	ff cf       	rjmp	.-2      	; 0x794 <__vector_5+0xa>

00000796 <__vector_13>:
	while (1);
}

ISR(USI_START_vect, ISR_BLOCK)
{
 796:	1f 92       	push	r1
 798:	0f 92       	push	r0
 79a:	0f b6       	in	r0, 0x3f	; 63
 79c:	0f 92       	push	r0
 79e:	11 24       	eor	r1, r1
 7a0:	ff cf       	rjmp	.-2      	; 0x7a0 <__vector_13+0xa>

000007a2 <__vector_14>:
	while (1);
}

ISR(USI_OVF_vect, ISR_BLOCK)
{
 7a2:	1f 92       	push	r1
 7a4:	0f 92       	push	r0
 7a6:	0f b6       	in	r0, 0x3f	; 63
 7a8:	0f 92       	push	r0
 7aa:	11 24       	eor	r1, r1
 7ac:	ff cf       	rjmp	.-2      	; 0x7ac <__vector_14+0xa>

000007ae <__vector_6>:
	while (1);
}

ISR(EE_RDY_vect, ISR_BLOCK)
{
 7ae:	1f 92       	push	r1
 7b0:	0f 92       	push	r0
 7b2:	0f b6       	in	r0, 0x3f	; 63
 7b4:	0f 92       	push	r0
 7b6:	11 24       	eor	r1, r1
 7b8:	ff cf       	rjmp	.-2      	; 0x7b8 <__vector_6+0xa>

000007ba <__vector_7>:
	while (1);
}

ISR(ANA_COMP_vect, ISR_BLOCK)
{
 7ba:	1f 92       	push	r1
 7bc:	0f 92       	push	r0
 7be:	0f b6       	in	r0, 0x3f	; 63
 7c0:	0f 92       	push	r0
 7c2:	11 24       	eor	r1, r1
 7c4:	ff cf       	rjmp	.-2      	; 0x7c4 <__vector_7+0xa>

000007c6 <INT1_vect>:
	while (1);
}

ISR(INT1_vect, ISR_BLOCK)
{
 7c6:	1f 92       	push	r1
 7c8:	0f 92       	push	r0
 7ca:	0f b6       	in	r0, 0x3f	; 63
 7cc:	0f 92       	push	r0
 7ce:	11 24       	eor	r1, r1
 7d0:	ff cf       	rjmp	.-2      	; 0x7d0 <INT1_vect+0xa>

000007d2 <TIMER0_CAPT_vect>:
	while (1);
}

ISR(TIMER0_CAPT_vect, ISR_BLOCK)
{
 7d2:	1f 92       	push	r1
 7d4:	0f 92       	push	r0
 7d6:	0f b6       	in	r0, 0x3f	; 63
 7d8:	0f 92       	push	r0
 7da:	11 24       	eor	r1, r1
 7dc:	ff cf       	rjmp	.-2      	; 0x7dc <TIMER0_CAPT_vect+0xa>

000007de <TIMER1_COMPD_vect>:
	while (1);
}

ISR(TIMER1_COMPD_vect, ISR_BLOCK)
{
 7de:	1f 92       	push	r1
 7e0:	0f 92       	push	r0
 7e2:	0f b6       	in	r0, 0x3f	; 63
 7e4:	0f 92       	push	r0
 7e6:	11 24       	eor	r1, r1
 7e8:	ff cf       	rjmp	.-2      	; 0x7e8 <TIMER1_COMPD_vect+0xa>

000007ea <FAULT_PROTECTION_vect>:
	while (1);
}

ISR(FAULT_PROTECTION_vect, ISR_BLOCK)
{
 7ea:	1f 92       	push	r1
 7ec:	0f 92       	push	r0
 7ee:	0f b6       	in	r0, 0x3f	; 63
 7f0:	0f 92       	push	r0
 7f2:	11 24       	eor	r1, r1
 7f4:	ff cf       	rjmp	.-2      	; 0x7f4 <FAULT_PROTECTION_vect+0xa>

Disassembly of section .text:

0000096e <MCP9843SetSensorRegister>:
// Sets the register pointer to the incoming value, ready for subsequent transactions.
// Routine returns true if the device acknowledged the transactions, otherwise false
// is returned.
static bool MCP9843SetSensorRegister(uint8_t u8Register,
									 bool bRead)
{
 96e:	cf 93       	push	r28
 970:	c8 2f       	mov	r28, r24
	// Attempt to start a transaction
	if (false == I2CStartTransaction(MCP9843_SLAVE_ADDRESS_SENSOR,
 972:	80 e3       	ldi	r24, 0x30	; 48
 974:	eb df       	rcall	.-42     	; 0x94c <I2CStartTransaction>
 976:	88 23       	and	r24, r24
 978:	11 f0       	breq	.+4      	; 0x97e <MCP9843SetSensorRegister+0x10>
	{
		return(false);
	}
	
	// Now write the register. Since we're the master, we're monitoring ACK from the slave.
	if (false == I2CTxByte(u8Register))
 97a:	8c 2f       	mov	r24, r28
 97c:	69 df       	rcall	.-302    	; 0x850 <I2CTxByte>
		// Not good.
		return(false);
	}
	
	return(true);
}
 97e:	cf 91       	pop	r28
 980:	08 95       	ret

00000982 <MCP9843SetEventPin>:

// This sets the EVENT pin either high or low depending on the input signal. The 
// logic requires that the thresholds are NOT triggered, as it uses the 
bool MCP9843SetEventPin(bool bHigh)
{
 982:	1f 93       	push	r17
 984:	cf 93       	push	r28
 986:	df 93       	push	r29
 988:	0f 92       	push	r0
 98a:	cd b7       	in	r28, 0x3d	; 61
 98c:	de b7       	in	r29, 0x3e	; 62
 98e:	18 2f       	mov	r17, r24
#if defined(__AVR_ATtiny261A__)
	return(true);
#else
	bool bResult = false;
	volatile uint8_t u8ConfigByteLSB = MCP9843_CONFIG_DEFAULT_LSB;
 990:	8a e1       	ldi	r24, 0x1A	; 26
 992:	89 83       	std	Y+1, r24	; 0x01
	
	// Set up the output pins for I2C operation
	I2CSetup();
 994:	c8 df       	rcall	.-112    	; 0x926 <I2CSetup>
	
	// Write the configuration register
	if (false == MCP9843SetSensorRegister(MCP9843REG_CONFIG,
 996:	60 e0       	ldi	r22, 0x00	; 0
 998:	81 e0       	ldi	r24, 0x01	; 1
 99a:	e9 df       	rcall	.-46     	; 0x96e <MCP9843SetSensorRegister>
 99c:	88 23       	and	r24, r24
 99e:	99 f0       	breq	.+38     	; 0x9c6 <MCP9843SetEventPin+0x44>
	{
		goto i2cFail;
	}
	
	// Config MSB
	if (false == I2CTxByte(MCP9843_CONFIG_DEFAULT_MSB))
 9a0:	80 e0       	ldi	r24, 0x00	; 0
 9a2:	56 df       	rcall	.-340    	; 0x850 <I2CTxByte>
 9a4:	88 23       	and	r24, r24
 9a6:	89 f0       	breq	.+34     	; 0x9ca <MCP9843SetEventPin+0x48>
	{
		goto i2cFail;
	}
	
	if (bHigh)
 9a8:	11 23       	and	r17, r17
 9aa:	21 f0       	breq	.+8      	; 0x9b4 <MCP9843SetEventPin+0x32>
	{
		u8ConfigByteLSB |= MCP9843REG_CONFIG_EV_POLARITY;
 9ac:	89 81       	ldd	r24, Y+1	; 0x01
 9ae:	82 60       	ori	r24, 0x02	; 2
 9b0:	89 83       	std	Y+1, r24	; 0x01
 9b2:	03 c0       	rjmp	.+6      	; 0x9ba <MCP9843SetEventPin+0x38>
	}
	else
	{
		u8ConfigByteLSB &= (uint8_t) (~MCP9843REG_CONFIG_EV_POLARITY);
 9b4:	89 81       	ldd	r24, Y+1	; 0x01
 9b6:	8d 7f       	andi	r24, 0xFD	; 253
 9b8:	89 83       	std	Y+1, r24	; 0x01
	}
	
	// Config LSB
	if (false == I2CTxByte(u8ConfigByteLSB))
 9ba:	89 81       	ldd	r24, Y+1	; 0x01
 9bc:	49 df       	rcall	.-366    	; 0x850 <I2CTxByte>
 9be:	81 11       	cpse	r24, r1
 9c0:	06 c0       	rjmp	.+12     	; 0x9ce <MCP9843SetEventPin+0x4c>
bool MCP9843SetEventPin(bool bHigh)
{
#if defined(__AVR_ATtiny261A__)
	return(true);
#else
	bool bResult = false;
 9c2:	10 e0       	ldi	r17, 0x00	; 0
 9c4:	05 c0       	rjmp	.+10     	; 0x9d0 <MCP9843SetEventPin+0x4e>
 9c6:	10 e0       	ldi	r17, 0x00	; 0
 9c8:	03 c0       	rjmp	.+6      	; 0x9d0 <MCP9843SetEventPin+0x4e>
 9ca:	10 e0       	ldi	r17, 0x00	; 0
 9cc:	01 c0       	rjmp	.+2      	; 0x9d0 <MCP9843SetEventPin+0x4e>
	{
		goto i2cFail;
	}
	
	// Indicate we're OK
	bResult = true;
 9ce:	11 e0       	ldi	r17, 0x01	; 1
	
	// And a stop condition
i2cFail:
	I2CStop();
 9d0:	2e df       	rcall	.-420    	; 0x82e <I2CStop>
	
	return(bResult);
#endif
}
 9d2:	81 2f       	mov	r24, r17
 9d4:	0f 90       	pop	r0
 9d6:	df 91       	pop	r29
 9d8:	cf 91       	pop	r28
 9da:	1f 91       	pop	r17
 9dc:	08 95       	ret

000009de <MCP9843ReadTemperature>:
// Bits 4-11 - Whole degrees C
// Bit 12    - Temperature sign bit - 0=Positive, 1=Negative
// Bits 13-14- Always 0
// Bit 15    - 1=Reading of temperature is valid, 0=Not valid
int16_t MCP9843ReadTemperature(void)
{
 9de:	cf 93       	push	r28
 9e0:	df 93       	push	r29
#if defined(__AVR_ATtiny261A__)
	// Let's try 23.5 degrees
	s16Temperature = (23 << 4) | (0x08);
#else
	// Set up the output pins for I2C operation
	I2CSetup();
 9e2:	a1 df       	rcall	.-190    	; 0x926 <I2CSetup>
	
	// Write the temperature register
	if (false == MCP9843SetSensorRegister(MCP9843REG_TEMP,
 9e4:	60 e0       	ldi	r22, 0x00	; 0
 9e6:	85 e0       	ldi	r24, 0x05	; 5
 9e8:	c2 df       	rcall	.-124    	; 0x96e <MCP9843SetSensorRegister>
 9ea:	88 23       	and	r24, r24
 9ec:	a1 f0       	breq	.+40     	; 0xa16 <MCP9843ReadTemperature+0x38>
	{
		// Not valid
		return(0);											  
	}

	I2CStop();
 9ee:	1f df       	rcall	.-450    	; 0x82e <I2CStop>
	
	// Attempt to start a transaction
	if (false == I2CStartTransaction(MCP9843_SLAVE_ADDRESS_SENSOR,
 9f0:	61 e0       	ldi	r22, 0x01	; 1
 9f2:	80 e3       	ldi	r24, 0x30	; 48
 9f4:	ab df       	rcall	.-170    	; 0x94c <I2CStartTransaction>
 9f6:	88 23       	and	r24, r24
 9f8:	89 f0       	breq	.+34     	; 0xa1c <MCP9843ReadTemperature+0x3e>
		// Not valid
		return(0);
	}
	
	// Now read MSB/LSB
	s16Temperature = I2CRxByte(true) << 8;
 9fa:	81 e0       	ldi	r24, 0x01	; 1
 9fc:	5b df       	rcall	.-330    	; 0x8b4 <I2CRxByte>
 9fe:	c8 2f       	mov	r28, r24
 a00:	d0 e0       	ldi	r29, 0x00	; 0
 a02:	dc 2f       	mov	r29, r28
 a04:	cc 27       	eor	r28, r28
	s16Temperature |= I2CRxByte(false);
 a06:	80 e0       	ldi	r24, 0x00	; 0
 a08:	55 df       	rcall	.-342    	; 0x8b4 <I2CRxByte>
 a0a:	c8 2b       	or	r28, r24
	
	// Now the stop condition
	I2CStop();
 a0c:	10 df       	rcall	.-480    	; 0x82e <I2CStop>

	// Mask off the tcrit/tupper/tlower bits - they aren't useful
#endif
	s16Temperature &= 0xfff;
 a0e:	ce 01       	movw	r24, r28
 a10:	9f 70       	andi	r25, 0x0F	; 15
	s16Temperature |= MSG_CELL_TEMP_I2C_OK;
	
	return(s16Temperature);
 a12:	90 68       	ori	r25, 0x80	; 128
 a14:	05 c0       	rjmp	.+10     	; 0xa20 <MCP9843ReadTemperature+0x42>
	// Write the temperature register
	if (false == MCP9843SetSensorRegister(MCP9843REG_TEMP,
										  false))
	{
		// Not valid
		return(0);											  
 a16:	80 e0       	ldi	r24, 0x00	; 0
 a18:	90 e0       	ldi	r25, 0x00	; 0
 a1a:	02 c0       	rjmp	.+4      	; 0xa20 <MCP9843ReadTemperature+0x42>
	// Attempt to start a transaction
	if (false == I2CStartTransaction(MCP9843_SLAVE_ADDRESS_SENSOR,
									 true))
	{
		// Not valid
		return(0);
 a1c:	80 e0       	ldi	r24, 0x00	; 0
 a1e:	90 e0       	ldi	r25, 0x00	; 0
#endif
	s16Temperature &= 0xfff;
	s16Temperature |= MSG_CELL_TEMP_I2C_OK;
	
	return(s16Temperature);
}
 a20:	df 91       	pop	r29
 a22:	cf 91       	pop	r28
 a24:	08 95       	ret

Disassembly of section .text:

00000074 <__vector_2>:
// Edge correction configuration
#define VUART_BIT_TICK_OFFSET 6  // Timer offset to account for ISR latency

// Pin change interrupt - detecting start bit and edges during reception
ISR(PCINT_VECTOR, ISR_BLOCK)
{
  74:	1f 92       	push	r1
  76:	0f 92       	push	r0
  78:	0f b6       	in	r0, 0x3f	; 63
  7a:	0f 92       	push	r0
  7c:	11 24       	eor	r1, r1
  7e:	2f 93       	push	r18
  80:	3f 93       	push	r19
  82:	4f 93       	push	r20
  84:	5f 93       	push	r21
  86:	6f 93       	push	r22
  88:	7f 93       	push	r23
  8a:	8f 93       	push	r24
  8c:	9f 93       	push	r25
  8e:	af 93       	push	r26
  90:	bf 93       	push	r27
  92:	ef 93       	push	r30
  94:	ff 93       	push	r31
	bool bCellUpRXAsserted = IS_PIN_CELL_UP_RX_ASSERTED();
  96:	86 b3       	in	r24, 0x16	; 22
  98:	98 2f       	mov	r25, r24
  9a:	90 71       	andi	r25, 0x10	; 16
	bool bCellDnRxAsserted = IS_PIN_CELL_DN_RX_ASSERTED();
  9c:	86 b3       	in	r24, 0x16	; 22
  9e:	82 70       	andi	r24, 0x02	; 2
	uint8_t u8CurrentTimer = TIMER_COUNTER();
  a0:	42 b7       	in	r20, 0x32	; 50

	// Handle cell_up_rx - both start bit and edge correction
	if (sg_bcell_up_rx_Enabled)
  a2:	20 91 69 00 	lds	r18, 0x0069	; 0x800069 <sg_bcell_up_rx_Enabled>
  a6:	22 23       	and	r18, r18
  a8:	69 f1       	breq	.+90     	; 0x104 <__DATA_REGION_LENGTH__+0x4>
	{
		// Start bit detection
		if (bCellUpRXAsserted &&
  aa:	99 23       	and	r25, r25
  ac:	09 f1       	breq	.+66     	; 0xf0 <__vector_2+0x7c>
			((ESTATE_IDLE == sg_ecell_up_rxState) ||
  ae:	20 91 6b 00 	lds	r18, 0x006B	; 0x80006b <sg_ecell_up_rxState>
  b2:	30 91 6c 00 	lds	r19, 0x006C	; 0x80006c <sg_ecell_up_rxState+0x1>

	// Handle cell_up_rx - both start bit and edge correction
	if (sg_bcell_up_rx_Enabled)
	{
		// Start bit detection
		if (bCellUpRXAsserted &&
  b6:	23 2b       	or	r18, r19
  b8:	39 f0       	breq	.+14     	; 0xc8 <__vector_2+0x54>
			((ESTATE_IDLE == sg_ecell_up_rxState) ||
			 (ESTATE_NEXT_BYTE == sg_ecell_up_rxState)))
  ba:	20 91 6b 00 	lds	r18, 0x006B	; 0x80006b <sg_ecell_up_rxState>
  be:	30 91 6c 00 	lds	r19, 0x006C	; 0x80006c <sg_ecell_up_rxState+0x1>
	// Handle cell_up_rx - both start bit and edge correction
	if (sg_bcell_up_rx_Enabled)
	{
		// Start bit detection
		if (bCellUpRXAsserted &&
			((ESTATE_IDLE == sg_ecell_up_rxState) ||
  c2:	23 30       	cpi	r18, 0x03	; 3
  c4:	31 05       	cpc	r19, r1
  c6:	a1 f4       	brne	.+40     	; 0xf0 <__vector_2+0x7c>
			 (ESTATE_NEXT_BYTE == sg_ecell_up_rxState)))
		{
			// Set timer to sample at middle of first data bit
			// Start bit + half of first bit - ISR response overhead
			TIMER_CHA_INT(VUART_BIT_TICKS + (VUART_BIT_TICKS/2) - VUART_BIT_TICK_OFFSET);
  c8:	92 b7       	in	r25, 0x32	; 50
  ca:	9b 5b       	subi	r25, 0xBB	; 187
  cc:	99 bd       	out	0x29, r25	; 41
  ce:	90 e1       	ldi	r25, 0x10	; 16
  d0:	98 bf       	out	0x38, r25	; 56
  d2:	99 b7       	in	r25, 0x39	; 57
  d4:	90 61       	ori	r25, 0x10	; 16
  d6:	99 bf       	out	0x39, r25	; 57

			// Note: We keep interrupts ENABLED for edge detection during byte
			// INT_CELL_UP_RX_DISABLE(); // REMOVED - keep enabled for edge correction
			
			// We are now receiving data
			sg_ecell_up_rxState = ESTATE_RX_DATA;
  d8:	21 e0       	ldi	r18, 0x01	; 1
  da:	30 e0       	ldi	r19, 0x00	; 0
  dc:	30 93 6c 00 	sts	0x006C, r19	; 0x80006c <sg_ecell_up_rxState+0x1>
  e0:	20 93 6b 00 	sts	0x006B, r18	; 0x80006b <sg_ecell_up_rxState>
			sg_bcell_up_rxPriorState = true;
  e4:	91 e0       	ldi	r25, 0x01	; 1
  e6:	90 93 6d 00 	sts	0x006D, r25	; 0x80006d <sg_bcell_up_rxPriorState>
			sg_u8Cell_up_rxBitCount = 0;
  ea:	10 92 6e 00 	sts	0x006E, r1	; 0x80006e <sg_u8Cell_up_rxBitCount>
  ee:	0a c0       	rjmp	.+20     	; 0x104 <__DATA_REGION_LENGTH__+0x4>
		}
		// Edge correction during byte reception
		else if (ESTATE_RX_DATA == sg_ecell_up_rxState)
  f0:	20 91 6b 00 	lds	r18, 0x006B	; 0x80006b <sg_ecell_up_rxState>
  f4:	30 91 6c 00 	lds	r19, 0x006C	; 0x80006c <sg_ecell_up_rxState+0x1>
  f8:	21 30       	cpi	r18, 0x01	; 1
  fa:	31 05       	cpc	r19, r1
  fc:	19 f4       	brne	.+6      	; 0x104 <__DATA_REGION_LENGTH__+0x4>
		{
			// Edge just occurred, resync timer to fire at mid-bit
			// Subtract tick offset to account for timer interrupt latency
			OCR0A = (uint8_t)(u8CurrentTimer + (VUART_BIT_TICKS/2) - VUART_BIT_TICK_OFFSET);
  fe:	93 e1       	ldi	r25, 0x13	; 19
 100:	94 0f       	add	r25, r20
 102:	99 bd       	out	0x29, r25	; 41
		}
	}
	
	// Handle cell_dn_rx - both start bit and edge correction
	if ((ESTATE_IDLE == sg_ecell_dn_rxState) ||
 104:	20 91 65 00 	lds	r18, 0x0065	; 0x800065 <sg_ecell_dn_rxState>
 108:	30 91 66 00 	lds	r19, 0x0066	; 0x800066 <sg_ecell_dn_rxState+0x1>
 10c:	23 2b       	or	r18, r19
 10e:	71 f0       	breq	.+28     	; 0x12c <__DATA_REGION_LENGTH__+0x2c>
		(ESTATE_NEXT_BYTE == sg_ecell_dn_rxState) ||
 110:	20 91 65 00 	lds	r18, 0x0065	; 0x800065 <sg_ecell_dn_rxState>
 114:	30 91 66 00 	lds	r19, 0x0066	; 0x800066 <sg_ecell_dn_rxState+0x1>
			OCR0A = (uint8_t)(u8CurrentTimer + (VUART_BIT_TICKS/2) - VUART_BIT_TICK_OFFSET);
		}
	}
	
	// Handle cell_dn_rx - both start bit and edge correction
	if ((ESTATE_IDLE == sg_ecell_dn_rxState) ||
 118:	23 30       	cpi	r18, 0x03	; 3
 11a:	31 05       	cpc	r19, r1
 11c:	39 f0       	breq	.+14     	; 0x12c <__DATA_REGION_LENGTH__+0x2c>
		(ESTATE_NEXT_BYTE == sg_ecell_dn_rxState) ||
		(ESTATE_RX_DATA == sg_ecell_dn_rxState))
 11e:	20 91 65 00 	lds	r18, 0x0065	; 0x800065 <sg_ecell_dn_rxState>
 122:	30 91 66 00 	lds	r19, 0x0066	; 0x800066 <sg_ecell_dn_rxState+0x1>
		}
	}
	
	// Handle cell_dn_rx - both start bit and edge correction
	if ((ESTATE_IDLE == sg_ecell_dn_rxState) ||
		(ESTATE_NEXT_BYTE == sg_ecell_dn_rxState) ||
 126:	21 30       	cpi	r18, 0x01	; 1
 128:	31 05       	cpc	r19, r1
 12a:	81 f5       	brne	.+96     	; 0x18c <__stack+0x2d>
		(ESTATE_RX_DATA == sg_ecell_dn_rxState))
	{
		// Start bit detection
		if (bCellDnRxAsserted &&
 12c:	81 11       	cpse	r24, r1
 12e:	26 c0       	rjmp	.+76     	; 0x17c <__stack+0x1d>
			((ESTATE_IDLE == sg_ecell_dn_rxState) ||
 130:	80 91 65 00 	lds	r24, 0x0065	; 0x800065 <sg_ecell_dn_rxState>
 134:	90 91 66 00 	lds	r25, 0x0066	; 0x800066 <sg_ecell_dn_rxState+0x1>
	if ((ESTATE_IDLE == sg_ecell_dn_rxState) ||
		(ESTATE_NEXT_BYTE == sg_ecell_dn_rxState) ||
		(ESTATE_RX_DATA == sg_ecell_dn_rxState))
	{
		// Start bit detection
		if (bCellDnRxAsserted &&
 138:	89 2b       	or	r24, r25
 13a:	31 f0       	breq	.+12     	; 0x148 <__DATA_REGION_LENGTH__+0x48>
			((ESTATE_IDLE == sg_ecell_dn_rxState) ||
			 (ESTATE_NEXT_BYTE == sg_ecell_dn_rxState)))
 13c:	80 91 65 00 	lds	r24, 0x0065	; 0x800065 <sg_ecell_dn_rxState>
 140:	90 91 66 00 	lds	r25, 0x0066	; 0x800066 <sg_ecell_dn_rxState+0x1>
		(ESTATE_NEXT_BYTE == sg_ecell_dn_rxState) ||
		(ESTATE_RX_DATA == sg_ecell_dn_rxState))
	{
		// Start bit detection
		if (bCellDnRxAsserted &&
			((ESTATE_IDLE == sg_ecell_dn_rxState) ||
 144:	03 97       	sbiw	r24, 0x03	; 3
 146:	d1 f4       	brne	.+52     	; 0x17c <__stack+0x1d>
			 (ESTATE_NEXT_BYTE == sg_ecell_dn_rxState)))
		{
			// Set timer to sample at middle of first data bit
			// Start bit + half of first bit - ISR response overhead
			TIMER_CHB_INT(VUART_BIT_TICKS + (VUART_BIT_TICKS/2) - VUART_BIT_TICK_OFFSET);
 148:	82 b7       	in	r24, 0x32	; 50
 14a:	8b 5b       	subi	r24, 0xBB	; 187
 14c:	88 bd       	out	0x28, r24	; 40
 14e:	88 e0       	ldi	r24, 0x08	; 8
 150:	88 bf       	out	0x38, r24	; 56
 152:	89 b7       	in	r24, 0x39	; 57
 154:	88 60       	ori	r24, 0x08	; 8
 156:	89 bf       	out	0x39, r24	; 57
			// Note: We keep interrupts ENABLED for edge detection during byte
			// INT_CELL_DN_RX_DISABLE(); // REMOVED - keep enabled for edge correction
			
			// Only call the data start routine when it's the actual start of the initial
			// byte, not subsequent bytes.
			if (ESTATE_IDLE == sg_ecell_dn_rxState)
 158:	80 91 65 00 	lds	r24, 0x0065	; 0x800065 <sg_ecell_dn_rxState>
 15c:	90 91 66 00 	lds	r25, 0x0066	; 0x800066 <sg_ecell_dn_rxState+0x1>
 160:	89 2b       	or	r24, r25
 162:	09 f4       	brne	.+2      	; 0x166 <__stack+0x7>
			{
				// Falling edge on cell_dn_rx
				Celldn_rxDataStart();
 164:	fc d1       	rcall	.+1016   	; 0x55e <Celldn_rxDataStart>
			}
			
			// Set the RX data state
			sg_ecell_dn_rxState = ESTATE_RX_DATA;
 166:	81 e0       	ldi	r24, 0x01	; 1
 168:	90 e0       	ldi	r25, 0x00	; 0
 16a:	90 93 66 00 	sts	0x0066, r25	; 0x800066 <sg_ecell_dn_rxState+0x1>
 16e:	80 93 65 00 	sts	0x0065, r24	; 0x800065 <sg_ecell_dn_rxState>
			sg_bcell_dn_rxPriorState = true;
 172:	80 93 67 00 	sts	0x0067, r24	; 0x800067 <sg_bcell_dn_rxPriorState>
			sg_u8Cell_dn_rxBitCount = 0;
 176:	10 92 68 00 	sts	0x0068, r1	; 0x800068 <sg_u8Cell_dn_rxBitCount>
 17a:	08 c0       	rjmp	.+16     	; 0x18c <__stack+0x2d>
		}
		// Edge correction during byte reception
		else if (ESTATE_RX_DATA == sg_ecell_dn_rxState)
 17c:	80 91 65 00 	lds	r24, 0x0065	; 0x800065 <sg_ecell_dn_rxState>
 180:	90 91 66 00 	lds	r25, 0x0066	; 0x800066 <sg_ecell_dn_rxState+0x1>
 184:	01 97       	sbiw	r24, 0x01	; 1
 186:	11 f4       	brne	.+4      	; 0x18c <__stack+0x2d>
		{
			// Edge just occurred, resync timer to fire at mid-bit
			// Subtract tick offset to account for timer interrupt latency
			OCR0B = (uint8_t)(u8CurrentTimer + (VUART_BIT_TICKS/2) - VUART_BIT_TICK_OFFSET);
 188:	4d 5e       	subi	r20, 0xED	; 237
 18a:	48 bd       	out	0x28, r20	; 40
		}
	}
}
 18c:	ff 91       	pop	r31
 18e:	ef 91       	pop	r30
 190:	bf 91       	pop	r27
 192:	af 91       	pop	r26
 194:	9f 91       	pop	r25
 196:	8f 91       	pop	r24
 198:	7f 91       	pop	r23
 19a:	6f 91       	pop	r22
 19c:	5f 91       	pop	r21
 19e:	4f 91       	pop	r20
 1a0:	3f 91       	pop	r19
 1a2:	2f 91       	pop	r18
 1a4:	0f 90       	pop	r0
 1a6:	0f be       	out	0x3f, r0	; 63
 1a8:	0f 90       	pop	r0
 1aa:	1f 90       	pop	r1
 1ac:	18 95       	reti

000001ae <__vector_11>:
	TIMER_CHA_INT_DISABLE();
}

// Timer 0 compare B interrupt (bit clock) for cell_dn_rx
ISR(TIMER_COMPB_VECTOR, ISR_BLOCK)
{
 1ae:	1f 92       	push	r1
 1b0:	0f 92       	push	r0
 1b2:	0f b6       	in	r0, 0x3f	; 63
 1b4:	0f 92       	push	r0
 1b6:	11 24       	eor	r1, r1
 1b8:	2f 93       	push	r18
 1ba:	3f 93       	push	r19
 1bc:	4f 93       	push	r20
 1be:	5f 93       	push	r21
 1c0:	6f 93       	push	r22
 1c2:	7f 93       	push	r23
 1c4:	8f 93       	push	r24
 1c6:	9f 93       	push	r25
 1c8:	af 93       	push	r26
 1ca:	bf 93       	push	r27
 1cc:	ef 93       	push	r30
 1ce:	ff 93       	push	r31
	bool bData;
	
	TIMER_CHB_INT(VUART_BIT_TICKS-VUART_BIT_TICK_OFFSET);
 1d0:	82 b7       	in	r24, 0x32	; 50
 1d2:	84 5d       	subi	r24, 0xD4	; 212
 1d4:	88 bd       	out	0x28, r24	; 40
 1d6:	88 e0       	ldi	r24, 0x08	; 8
 1d8:	88 bf       	out	0x38, r24	; 56
 1da:	89 b7       	in	r24, 0x39	; 57
 1dc:	88 60       	ori	r24, 0x08	; 8
 1de:	89 bf       	out	0x39, r24	; 57
		
	// Set the bit value for what the prior state was
	if (sg_bcell_dn_rxPriorState)
 1e0:	80 91 67 00 	lds	r24, 0x0067	; 0x800067 <sg_bcell_dn_rxPriorState>
 1e4:	88 23       	and	r24, r24
 1e6:	21 f0       	breq	.+8      	; 0x1f0 <__vector_11+0x42>
	{
		CELL_UP_TX_ASSERT();
 1e8:	88 b3       	in	r24, 0x18	; 24
 1ea:	81 60       	ori	r24, 0x01	; 1
 1ec:	88 bb       	out	0x18, r24	; 24
 1ee:	03 c0       	rjmp	.+6      	; 0x1f6 <__vector_11+0x48>
	}
	else
	{
		CELL_UP_TX_DEASSERT();
 1f0:	88 b3       	in	r24, 0x18	; 24
 1f2:	8e 7f       	andi	r24, 0xFE	; 254
 1f4:	88 bb       	out	0x18, r24	; 24
	}

	bData = sg_bcell_dn_rxPriorState;
 1f6:	80 91 67 00 	lds	r24, 0x0067	; 0x800067 <sg_bcell_dn_rxPriorState>
	sg_bcell_dn_rxPriorState = IS_PIN_CELL_DN_RX_ASSERTED();
 1fa:	26 b3       	in	r18, 0x16	; 22
 1fc:	26 95       	lsr	r18
 1fe:	91 e0       	ldi	r25, 0x01	; 1
 200:	29 27       	eor	r18, r25
 202:	21 70       	andi	r18, 0x01	; 1
 204:	20 93 67 00 	sts	0x0067, r18	; 0x800067 <sg_bcell_dn_rxPriorState>
	
	sg_u8Cell_dn_rxBitCount++;
 208:	90 91 68 00 	lds	r25, 0x0068	; 0x800068 <sg_u8Cell_dn_rxBitCount>
 20c:	9f 5f       	subi	r25, 0xFF	; 255
 20e:	90 93 68 00 	sts	0x0068, r25	; 0x800068 <sg_u8Cell_dn_rxBitCount>
	
	// Handles cell_dn_rx
	if (1 == sg_u8Cell_dn_rxBitCount)
 212:	91 30       	cpi	r25, 0x01	; 1
 214:	29 f1       	breq	.+74     	; 0x260 <__vector_11+0xb2>
	{
		// Start bit
	}
	else
	if (sg_u8Cell_dn_rxBitCount < 10)
 216:	9a 30       	cpi	r25, 0x0A	; 10
 218:	10 f4       	brcc	.+4      	; 0x21e <__vector_11+0x70>
	{
		Celldn_rxDataBit(bData);
 21a:	a8 d1       	rcall	.+848    	; 0x56c <Celldn_rxDataBit>
		return;
 21c:	21 c0       	rjmp	.+66     	; 0x260 <__vector_11+0xb2>
	}
	else
	if (10 == sg_u8Cell_dn_rxBitCount)
 21e:	9a 30       	cpi	r25, 0x0A	; 10
 220:	19 f4       	brne	.+6      	; 0x228 <__vector_11+0x7a>
	{
		// This is the more data vs. data stop bit
		sg_bCell_dn_rxMoreData = sg_bcell_dn_rxPriorState;
 222:	20 93 64 00 	sts	0x0064, r18	; 0x800064 <sg_bCell_dn_rxMoreData>
		return;
 226:	1c c0       	rjmp	.+56     	; 0x260 <__vector_11+0xb2>
	}
	else
	if (11 == sg_u8Cell_dn_rxBitCount)
 228:	9b 30       	cpi	r25, 0x0B	; 11
 22a:	19 f4       	brne	.+6      	; 0x232 <__vector_11+0x84>
	{
		// No longer asserted
		sg_bcell_dn_rxPriorState = false;
 22c:	10 92 67 00 	sts	0x0067, r1	; 0x800067 <sg_bcell_dn_rxPriorState>
		return;
 230:	17 c0       	rjmp	.+46     	; 0x260 <__vector_11+0xb2>
	}
	else
	if (12 == sg_u8Cell_dn_rxBitCount)
 232:	9c 30       	cpi	r25, 0x0C	; 12
 234:	a9 f4       	brne	.+42     	; 0x260 <__vector_11+0xb2>
	{
		TIMER_CHB_INT_DISABLE();
 236:	89 b7       	in	r24, 0x39	; 57
 238:	87 7f       	andi	r24, 0xF7	; 247
 23a:	89 bf       	out	0x39, r24	; 57
		
		// Enable cell_dn_rx for next byte
		INT_CELL_DN_RX_ENABLE();
 23c:	85 b3       	in	r24, 0x15	; 21
 23e:	82 60       	ori	r24, 0x02	; 2
 240:	85 bb       	out	0x15, r24	; 21
		
		if (false == sg_bCell_dn_rxMoreData)
 242:	80 91 64 00 	lds	r24, 0x0064	; 0x800064 <sg_bCell_dn_rxMoreData>
 246:	81 11       	cpse	r24, r1
 248:	05 c0       	rjmp	.+10     	; 0x254 <__vector_11+0xa6>
		{
			// Bus is now idle
			sg_ecell_dn_rxState = ESTATE_IDLE;
 24a:	10 92 66 00 	sts	0x0066, r1	; 0x800066 <sg_ecell_dn_rxState+0x1>
 24e:	10 92 65 00 	sts	0x0065, r1	; 0x800065 <sg_ecell_dn_rxState>
 252:	06 c0       	rjmp	.+12     	; 0x260 <__vector_11+0xb2>
		}
		else
		{
			// Flag that more data is coming
			sg_ecell_dn_rxState = ESTATE_NEXT_BYTE;
 254:	83 e0       	ldi	r24, 0x03	; 3
 256:	90 e0       	ldi	r25, 0x00	; 0
 258:	90 93 66 00 	sts	0x0066, r25	; 0x800066 <sg_ecell_dn_rxState+0x1>
 25c:	80 93 65 00 	sts	0x0065, r24	; 0x800065 <sg_ecell_dn_rxState>
		}

		return;
	}
}
 260:	ff 91       	pop	r31
 262:	ef 91       	pop	r30
 264:	bf 91       	pop	r27
 266:	af 91       	pop	r26
 268:	9f 91       	pop	r25
 26a:	8f 91       	pop	r24
 26c:	7f 91       	pop	r23
 26e:	6f 91       	pop	r22
 270:	5f 91       	pop	r21
 272:	4f 91       	pop	r20
 274:	3f 91       	pop	r19
 276:	2f 91       	pop	r18
 278:	0f 90       	pop	r0
 27a:	0f be       	out	0x3f, r0	; 63
 27c:	0f 90       	pop	r0
 27e:	1f 90       	pop	r1
 280:	18 95       	reti

00000282 <vUARTStartcell_dn_tx>:

// This starts a transmission on cell_dn_tx. true Is returned if it 
// was successfully started, but false if the cell_dn_tx vUART is active.
bool vUARTStartcell_dn_tx(uint8_t u8StartDelayTicks)
{
 282:	cf 93       	push	r28
	bool bReturnCode = false;

	// Is our cell_up_rx->cell_dn_tx path busy? If so, we can't start
	if (ESTATE_IDLE == sg_ecell_up_rxState)
 284:	20 91 6b 00 	lds	r18, 0x006B	; 0x80006b <sg_ecell_up_rxState>
 288:	30 91 6c 00 	lds	r19, 0x006C	; 0x80006c <sg_ecell_up_rxState+0x1>
 28c:	23 2b       	or	r18, r19
 28e:	01 f5       	brne	.+64     	; 0x2d0 <vUARTStartcell_dn_tx+0x4e>
 290:	c8 2f       	mov	r28, r24
	{
		// Shut off cell_up_rx interrupts coming from up stream so we don't hit a
		// spurious interrupt while we're transmitting
		INT_CELL_UP_RX_DISABLE();
 292:	85 b3       	in	r24, 0x15	; 21
 294:	8f 7e       	andi	r24, 0xEF	; 239
 296:	85 bb       	out	0x15, r24	; 21

		bReturnCode = true;
		
		// Set the state machine to transmit data.
		sg_ecell_up_rxState = ESTATE_TX_DATA;
 298:	82 e0       	ldi	r24, 0x02	; 2
 29a:	90 e0       	ldi	r25, 0x00	; 0
 29c:	90 93 6c 00 	sts	0x006C, r25	; 0x80006c <sg_ecell_up_rxState+0x1>
 2a0:	80 93 6b 00 	sts	0x006B, r24	; 0x80006b <sg_ecell_up_rxState>

		// Ensure the first bit is a start bit		
		sg_bdn_txNextBit = true;
 2a4:	81 e0       	ldi	r24, 0x01	; 1
 2a6:	80 93 63 00 	sts	0x0063, r24	; 0x800063 <sg_bdn_txNextBit>

		// Let the consumer code know that a transmission is starting
		Celldn_txDataReset();
 2aa:	53 d1       	rcall	.+678    	; 0x552 <Celldn_txDataReset>
		
		// Seed any data to transmit
		sg_u8dn_txDataByte = Celldn_txDataGet();
 2ac:	31 d1       	rcall	.+610    	; 0x510 <Celldn_txDataGet>
 2ae:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <sg_u8dn_txDataByte>
		sg_bdn_txMoreAvailable = Celldn_txDataAvailable();
 2b2:	26 d1       	rcall	.+588    	; 0x500 <Celldn_txDataAvailable>
 2b4:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>

		// Clear our dn_tx bit count
		sg_u8dn_txBitCount = 0;
 2b8:	10 92 62 00 	sts	0x0062, r1	; 0x800062 <sg_u8dn_txBitCount>
		
		// Start up timer A to fire a half a bit later (if it's sloppy, that's OK)
		TIMER_CHA_INT(u8StartDelayTicks);		
 2bc:	82 b7       	in	r24, 0x32	; 50
 2be:	8c 0f       	add	r24, r28
 2c0:	89 bd       	out	0x29, r24	; 41
 2c2:	80 e1       	ldi	r24, 0x10	; 16
 2c4:	88 bf       	out	0x38, r24	; 56
 2c6:	89 b7       	in	r24, 0x39	; 57
 2c8:	80 61       	ori	r24, 0x10	; 16
 2ca:	89 bf       	out	0x39, r24	; 57
	{
		// Shut off cell_up_rx interrupts coming from up stream so we don't hit a
		// spurious interrupt while we're transmitting
		INT_CELL_UP_RX_DISABLE();

		bReturnCode = true;
 2cc:	81 e0       	ldi	r24, 0x01	; 1
 2ce:	01 c0       	rjmp	.+2      	; 0x2d2 <vUARTStartcell_dn_tx+0x50>

// This starts a transmission on cell_dn_tx. true Is returned if it 
// was successfully started, but false if the cell_dn_tx vUART is active.
bool vUARTStartcell_dn_tx(uint8_t u8StartDelayTicks)
{
	bool bReturnCode = false;
 2d0:	80 e0       	ldi	r24, 0x00	; 0
		// Start up timer A to fire a half a bit later (if it's sloppy, that's OK)
		TIMER_CHA_INT(u8StartDelayTicks);		
	}
	
	return(bReturnCode);
}
 2d2:	cf 91       	pop	r28
 2d4:	08 95       	ret

000002d6 <__vector_10>:
	}
}

// Timer 0 compare A interrupt (bit clock) for cell_up_rx
ISR(TIMER_COMPA_VECTOR, ISR_BLOCK)
{
 2d6:	1f 92       	push	r1
 2d8:	0f 92       	push	r0
 2da:	0f b6       	in	r0, 0x3f	; 63
 2dc:	0f 92       	push	r0
 2de:	11 24       	eor	r1, r1
 2e0:	2f 93       	push	r18
 2e2:	3f 93       	push	r19
 2e4:	4f 93       	push	r20
 2e6:	5f 93       	push	r21
 2e8:	6f 93       	push	r22
 2ea:	7f 93       	push	r23
 2ec:	8f 93       	push	r24
 2ee:	9f 93       	push	r25
 2f0:	af 93       	push	r26
 2f2:	bf 93       	push	r27
 2f4:	ef 93       	push	r30
 2f6:	ff 93       	push	r31
	TIMER_CHA_INT(VUART_BIT_TICKS-VUART_BIT_TICK_OFFSET);
 2f8:	82 b7       	in	r24, 0x32	; 50
 2fa:	84 5d       	subi	r24, 0xD4	; 212
 2fc:	89 bd       	out	0x29, r24	; 41
 2fe:	80 e1       	ldi	r24, 0x10	; 16
 300:	88 bf       	out	0x38, r24	; 56
 302:	89 b7       	in	r24, 0x39	; 57
 304:	80 61       	ori	r24, 0x10	; 16
 306:	89 bf       	out	0x39, r24	; 57
	if (ESTATE_RX_DATA == sg_ecell_up_rxState)
 308:	80 91 6b 00 	lds	r24, 0x006B	; 0x80006b <sg_ecell_up_rxState>
 30c:	90 91 6c 00 	lds	r25, 0x006C	; 0x80006c <sg_ecell_up_rxState+0x1>
 310:	01 97       	sbiw	r24, 0x01	; 1
 312:	09 f0       	breq	.+2      	; 0x316 <__vector_10+0x40>
 314:	40 c0       	rjmp	.+128    	; 0x396 <__vector_10+0xc0>
	{
		// Set the bit value for what the prior state was
		if (sg_bcell_up_rxPriorState)
 316:	80 91 6d 00 	lds	r24, 0x006D	; 0x80006d <sg_bcell_up_rxPriorState>
 31a:	88 23       	and	r24, r24
 31c:	21 f0       	breq	.+8      	; 0x326 <__vector_10+0x50>
		{
			CELL_DN_TX_ASSERT();
 31e:	88 b3       	in	r24, 0x18	; 24
 320:	8f 7d       	andi	r24, 0xDF	; 223
 322:	88 bb       	out	0x18, r24	; 24
 324:	03 c0       	rjmp	.+6      	; 0x32c <__vector_10+0x56>
		}
		else
		{
			CELL_DN_TX_DEASSERT();
 326:	88 b3       	in	r24, 0x18	; 24
 328:	80 62       	ori	r24, 0x20	; 32
 32a:	88 bb       	out	0x18, r24	; 24
		}
		
		sg_bcell_up_rxPriorState = IS_PIN_CELL_UP_RX_ASSERTED();
 32c:	96 b3       	in	r25, 0x16	; 22
 32e:	92 95       	swap	r25
 330:	91 70       	andi	r25, 0x01	; 1
 332:	90 93 6d 00 	sts	0x006D, r25	; 0x80006d <sg_bcell_up_rxPriorState>
	
		sg_u8Cell_up_rxBitCount++;
 336:	80 91 6e 00 	lds	r24, 0x006E	; 0x80006e <sg_u8Cell_up_rxBitCount>
 33a:	8f 5f       	subi	r24, 0xFF	; 255
 33c:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <sg_u8Cell_up_rxBitCount>
		
		// Handles incoming start bit and data bits
		if (sg_u8Cell_up_rxBitCount < 9)
 340:	89 30       	cpi	r24, 0x09	; 9
 342:	08 f4       	brcc	.+2      	; 0x346 <__vector_10+0x70>
 344:	89 c0       	rjmp	.+274    	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
		{
			// Data bits
			return;
		}
		else
		if (9 == sg_u8Cell_up_rxBitCount)
 346:	89 30       	cpi	r24, 0x09	; 9
 348:	31 f4       	brne	.+12     	; 0x356 <__vector_10+0x80>
		{
			// This is the more data vs. data stop bit
			sg_bCell_up_rxMoreData = sg_bcell_up_rxPriorState;
 34a:	90 93 6a 00 	sts	0x006A, r25	; 0x80006a <sg_bCell_up_rxMoreData>
			
			// Always ensure that we're signaling more data since the termination
			// bit is done in the transmit phase
			sg_bcell_up_rxPriorState = true;
 34e:	81 e0       	ldi	r24, 0x01	; 1
 350:	80 93 6d 00 	sts	0x006D, r24	; 0x80006d <sg_bcell_up_rxPriorState>
			return;
 354:	81 c0       	rjmp	.+258    	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
		}
		else
		if (10 == sg_u8Cell_up_rxBitCount)
 356:	8a 30       	cpi	r24, 0x0A	; 10
 358:	19 f4       	brne	.+6      	; 0x360 <__vector_10+0x8a>
		{
			// Deassert the dn_tx signal (guard bit)
			sg_bcell_up_rxPriorState = false;
 35a:	10 92 6d 00 	sts	0x006D, r1	; 0x80006d <sg_bcell_up_rxPriorState>
			return;
 35e:	7c c0       	rjmp	.+248    	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
		}
		else
		if (11 == sg_u8Cell_up_rxBitCount)
 360:	8b 30       	cpi	r24, 0x0B	; 11
 362:	09 f0       	breq	.+2      	; 0x366 <__vector_10+0x90>
 364:	79 c0       	rjmp	.+242    	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
		{
			// Only way to get here is if we have more data. We are now at the start of a start
			// cycle now and we can reenable interrupts on cell_up_rx so we wait for the
			// start of the next byte.
			TIMER_CHA_INT_DISABLE();
 366:	89 b7       	in	r24, 0x39	; 57
 368:	8f 7e       	andi	r24, 0xEF	; 239
 36a:	89 bf       	out	0x39, r24	; 57
			
			// Enable cell_up_rx interrupts
			INT_CELL_UP_RX_ENABLE();
 36c:	85 b3       	in	r24, 0x15	; 21
 36e:	80 61       	ori	r24, 0x10	; 16
 370:	85 bb       	out	0x15, r24	; 21
				
			if (sg_bCell_up_rxMoreData)
 372:	80 91 6a 00 	lds	r24, 0x006A	; 0x80006a <sg_bCell_up_rxMoreData>
 376:	88 23       	and	r24, r24
 378:	39 f0       	breq	.+14     	; 0x388 <__vector_10+0xb2>
			{
				// Flag that more data is coming
				sg_ecell_up_rxState = ESTATE_NEXT_BYTE;
 37a:	83 e0       	ldi	r24, 0x03	; 3
 37c:	90 e0       	ldi	r25, 0x00	; 0
 37e:	90 93 6c 00 	sts	0x006C, r25	; 0x80006c <sg_ecell_up_rxState+0x1>
 382:	80 93 6b 00 	sts	0x006B, r24	; 0x80006b <sg_ecell_up_rxState>
 386:	68 c0       	rjmp	.+208    	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
			}
			else
			{
				// Bus is now idle		
				sg_ecell_up_rxState = ESTATE_IDLE;
 388:	10 92 6c 00 	sts	0x006C, r1	; 0x80006c <sg_ecell_up_rxState+0x1>
 38c:	10 92 6b 00 	sts	0x006B, r1	; 0x80006b <sg_ecell_up_rxState>
				
				// Start transmission of our data
				(void) vUARTStartcell_dn_tx(VUART_BIT_TICKS*3);
 390:	86 e9       	ldi	r24, 0x96	; 150
 392:	77 df       	rcall	.-274    	; 0x282 <vUARTStartcell_dn_tx>
 394:	61 c0       	rjmp	.+194    	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
		
		return;
	} 
	
	// This handles the transmission of data when this CPU originates it
	if (ESTATE_TX_DATA == sg_ecell_up_rxState)
 396:	80 91 6b 00 	lds	r24, 0x006B	; 0x80006b <sg_ecell_up_rxState>
 39a:	90 91 6c 00 	lds	r25, 0x006C	; 0x80006c <sg_ecell_up_rxState+0x1>
 39e:	02 97       	sbiw	r24, 0x02	; 2
 3a0:	09 f0       	breq	.+2      	; 0x3a4 <__vector_10+0xce>
 3a2:	57 c0       	rjmp	.+174    	; 0x452 <__LOCK_REGION_LENGTH__+0x52>
	{
		// Set the state of the output pin
		if (sg_bdn_txNextBit)
 3a4:	80 91 63 00 	lds	r24, 0x0063	; 0x800063 <sg_bdn_txNextBit>
 3a8:	88 23       	and	r24, r24
 3aa:	21 f0       	breq	.+8      	; 0x3b4 <__vector_10+0xde>
		{
			CELL_DN_TX_ASSERT();
 3ac:	88 b3       	in	r24, 0x18	; 24
 3ae:	8f 7d       	andi	r24, 0xDF	; 223
 3b0:	88 bb       	out	0x18, r24	; 24
 3b2:	03 c0       	rjmp	.+6      	; 0x3ba <__vector_10+0xe4>
		}
		else
		{
			CELL_DN_TX_DEASSERT();
 3b4:	88 b3       	in	r24, 0x18	; 24
 3b6:	80 62       	ori	r24, 0x20	; 32
 3b8:	88 bb       	out	0x18, r24	; 24
		}
		
		// Preincrement the bit count 
		sg_u8dn_txBitCount++;
 3ba:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <sg_u8dn_txBitCount>
 3be:	8f 5f       	subi	r24, 0xFF	; 255
 3c0:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <sg_u8dn_txBitCount>

		// Transmit start condition and prepare data byte
		// If this is the first bit, fetch the byte
		if( sg_u8dn_txBitCount < 9 )
 3c4:	89 30       	cpi	r24, 0x09	; 9
 3c6:	70 f4       	brcc	.+28     	; 0x3e4 <__vector_10+0x10e>
		{
			// Transmit data! (msb first)
			if (sg_u8dn_txDataByte & 0x80)
 3c8:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <sg_u8dn_txDataByte>
 3cc:	88 23       	and	r24, r24
 3ce:	24 f4       	brge	.+8      	; 0x3d8 <__vector_10+0x102>
			{
				sg_bdn_txNextBit = true;
 3d0:	91 e0       	ldi	r25, 0x01	; 1
 3d2:	90 93 63 00 	sts	0x0063, r25	; 0x800063 <sg_bdn_txNextBit>
 3d6:	02 c0       	rjmp	.+4      	; 0x3dc <__vector_10+0x106>
			}
			else
			{
				sg_bdn_txNextBit = false;
 3d8:	10 92 63 00 	sts	0x0063, r1	; 0x800063 <sg_bdn_txNextBit>
			}
			
			sg_u8dn_txDataByte <<= 1;
 3dc:	88 0f       	add	r24, r24
 3de:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <sg_u8dn_txDataByte>
			return;
 3e2:	3a c0       	rjmp	.+116    	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
		}
		// Transmit stop bit (stop or continue!)
		else 
		if (9 == sg_u8dn_txBitCount)
 3e4:	89 30       	cpi	r24, 0x09	; 9
 3e6:	29 f4       	brne	.+10     	; 0x3f2 <__vector_10+0x11c>
		{
			sg_bdn_txNextBit = sg_bdn_txMoreAvailable;
 3e8:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 3ec:	80 93 63 00 	sts	0x0063, r24	; 0x800063 <sg_bdn_txNextBit>
			return;
 3f0:	33 c0       	rjmp	.+102    	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
		}
		else 
		if (10 == sg_u8dn_txBitCount)
 3f2:	8a 30       	cpi	r24, 0x0A	; 10
 3f4:	19 f4       	brne	.+6      	; 0x3fc <__vector_10+0x126>
		{
			// Guard bit
			sg_bdn_txNextBit = false;
 3f6:	10 92 63 00 	sts	0x0063, r1	; 0x800063 <sg_bdn_txNextBit>
			return;
 3fa:	2e c0       	rjmp	.+92     	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
		}
		else
		if (11 == sg_u8dn_txBitCount)
 3fc:	8b 30       	cpi	r24, 0x0B	; 11
 3fe:	61 f5       	brne	.+88     	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
		{
			// Already deasserted here
			sg_u8dn_txBitCount = 0;
 400:	10 92 62 00 	sts	0x0062, r1	; 0x800062 <sg_u8dn_txBitCount>

			TIMER_CHA_INT_DISABLE();
 404:	89 b7       	in	r24, 0x39	; 57
 406:	8f 7e       	andi	r24, 0xEF	; 239
 408:	89 bf       	out	0x39, r24	; 57
				
			// If more available, reset the bit count and exit
			if (false == sg_bdn_txMoreAvailable)
 40a:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 40e:	81 11       	cpse	r24, r1
 410:	0e c0       	rjmp	.+28     	; 0x42e <__LOCK_REGION_LENGTH__+0x2e>
			{
				sg_ecell_up_rxState = ESTATE_IDLE;
 412:	10 92 6c 00 	sts	0x006C, r1	; 0x80006c <sg_ecell_up_rxState+0x1>
 416:	10 92 6b 00 	sts	0x006B, r1	; 0x80006b <sg_ecell_up_rxState>

				// Terminate! stop the timer interrupts and reenable port pin interrupts
				CELL_DN_TX_DEASSERT();
 41a:	88 b3       	in	r24, 0x18	; 24
 41c:	80 62       	ori	r24, 0x20	; 32
 41e:	88 bb       	out	0x18, r24	; 24
			
				// Allow reception of the cell_up_rx path again
				INT_CELL_UP_RX_ENABLE();
 420:	85 b3       	in	r24, 0x15	; 21
 422:	80 61       	ori	r24, 0x10	; 16
 424:	85 bb       	out	0x15, r24	; 21
				
				// Bail out - don't continue to process anything since it's idle
				CELL_UP_TX_DEASSERT();
 426:	88 b3       	in	r24, 0x18	; 24
 428:	8e 7f       	andi	r24, 0xFE	; 254
 42a:	88 bb       	out	0x18, r24	; 24
				return;
 42c:	15 c0       	rjmp	.+42     	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
			}
			else
			{
				// Set the timer 2 bits later - this can be sloppy since it's in between bytes
				TIMER_CHA_INT(VUART_BIT_TICKS*4);
 42e:	82 b7       	in	r24, 0x32	; 50
 430:	88 53       	subi	r24, 0x38	; 56
 432:	89 bd       	out	0x29, r24	; 41
 434:	80 e1       	ldi	r24, 0x10	; 16
 436:	88 bf       	out	0x38, r24	; 56
 438:	89 b7       	in	r24, 0x39	; 57
 43a:	80 61       	ori	r24, 0x10	; 16
 43c:	89 bf       	out	0x39, r24	; 57

				// Get the next data byte and whether or not
				sg_u8dn_txDataByte = Celldn_txDataGet();
 43e:	68 d0       	rcall	.+208    	; 0x510 <Celldn_txDataGet>
 440:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <sg_u8dn_txDataByte>
				sg_bdn_txMoreAvailable = Celldn_txDataAvailable();
 444:	5d d0       	rcall	.+186    	; 0x500 <Celldn_txDataAvailable>
 446:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
				sg_bdn_txNextBit = true;
 44a:	81 e0       	ldi	r24, 0x01	; 1
 44c:	80 93 63 00 	sts	0x0063, r24	; 0x800063 <sg_bdn_txNextBit>
 450:	03 c0       	rjmp	.+6      	; 0x458 <__LOCK_REGION_LENGTH__+0x58>

		return;
	}
	
	// Stop the timer - not necessary
	TIMER_CHA_INT_DISABLE();
 452:	89 b7       	in	r24, 0x39	; 57
 454:	8f 7e       	andi	r24, 0xEF	; 239
 456:	89 bf       	out	0x39, r24	; 57
}
 458:	ff 91       	pop	r31
 45a:	ef 91       	pop	r30
 45c:	bf 91       	pop	r27
 45e:	af 91       	pop	r26
 460:	9f 91       	pop	r25
 462:	8f 91       	pop	r24
 464:	7f 91       	pop	r23
 466:	6f 91       	pop	r22
 468:	5f 91       	pop	r21
 46a:	4f 91       	pop	r20
 46c:	3f 91       	pop	r19
 46e:	2f 91       	pop	r18
 470:	0f 90       	pop	r0
 472:	0f be       	out	0x3f, r0	; 63
 474:	0f 90       	pop	r0
 476:	1f 90       	pop	r1
 478:	18 95       	reti

0000047a <vUARTPinInit>:
}

void vUARTPinInit(void)
{
	// Set up cell_dn_rx
	PIN_CELL_DN_RX_DDR &= ((uint8_t) ~(1 << PIN_CELL_DN_RX));	// Set as input
 47a:	87 b3       	in	r24, 0x17	; 23
 47c:	8d 7f       	andi	r24, 0xFD	; 253
 47e:	87 bb       	out	0x17, r24	; 23
#if defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__)
	PIN_CELL_DN_RX_PORT &= ((uint8_t) ~(1 << PIN_CELL_DN_RX));	// Turn off pullup
 480:	88 b3       	in	r24, 0x18	; 24
 482:	8d 7f       	andi	r24, 0xFD	; 253
 484:	88 bb       	out	0x18, r24	; 24
#else
#error No target processor defined or target processor type unknown
#endif
		
	// Set up cell_up_tx
	PIN_CELL_UP_TX_DDR |= (1 << PIN_CELL_UP_TX);	// Set as output
 486:	87 b3       	in	r24, 0x17	; 23
 488:	81 60       	ori	r24, 0x01	; 1
 48a:	87 bb       	out	0x17, r24	; 23
#if defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__)
	PIN_CELL_UP_TX_PORT &= ((uint8_t) ~(1 << PIN_CELL_UP_TX));	// Turn off pullup
 48c:	88 b3       	in	r24, 0x18	; 24
 48e:	8e 7f       	andi	r24, 0xFE	; 254
 490:	88 bb       	out	0x18, r24	; 24
#elif defined(__AVR_ATtiny261A__)
	PIN_CELL_UP_TX_PORT |= ((uint8_t) (1 << PIN_CELL_UP_TX));	// Turn on pullup
#else
#error No target processor defined or target processor type unknown
#endif
	CELL_UP_TX_DEASSERT();							// Deassert cell_up_tx
 492:	88 b3       	in	r24, 0x18	; 24
 494:	8e 7f       	andi	r24, 0xFE	; 254
 496:	88 bb       	out	0x18, r24	; 24
	
	// Set up cell_up_rx
	PIN_CELL_UP_RX_DDR &= ((uint8_t) ~(1 << PIN_CELL_UP_RX));	// Set as input
 498:	87 b3       	in	r24, 0x17	; 23
 49a:	8f 7e       	andi	r24, 0xEF	; 239
 49c:	87 bb       	out	0x17, r24	; 23
#if defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__)
	PIN_CELL_UP_RX_PORT &= ((uint8_t) ~(1 << PIN_CELL_UP_RX));	// Turn off pullup
 49e:	88 b3       	in	r24, 0x18	; 24
 4a0:	8f 7e       	andi	r24, 0xEF	; 239
 4a2:	88 bb       	out	0x18, r24	; 24
#else
#error No target processor defined or target processor type unknown
#endif
	
	// Set up cell_dn_tx
	PIN_CELL_DN_TX_DDR |= (1 << PIN_CELL_DN_TX);	// Set as output
 4a4:	87 b3       	in	r24, 0x17	; 23
 4a6:	80 62       	ori	r24, 0x20	; 32
 4a8:	87 bb       	out	0x17, r24	; 23
#if defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__)
	PIN_CELL_DN_TX_PORT &= ((uint8_t) ~(1 << PIN_CELL_DN_TX));	// Turn off pullup
 4aa:	88 b3       	in	r24, 0x18	; 24
 4ac:	8f 7d       	andi	r24, 0xDF	; 223
 4ae:	88 bb       	out	0x18, r24	; 24
	PIN_CELL_DN_TX_PORT |= ((uint8_t) (1 << PIN_CELL_DN_TX));	// Turn on pullup
#else
#error No target processor defined or target processor type unknown
#endif

	CELL_DN_TX_DEASSERT();							// Deassert cell_dn_tx
 4b0:	88 b3       	in	r24, 0x18	; 24
 4b2:	80 62       	ori	r24, 0x20	; 32
 4b4:	88 bb       	out	0x18, r24	; 24
 4b6:	08 95       	ret

000004b8 <vUARTIscell_dn_rxActive>:
	PROFILER_INIT();
}

bool vUARTIscell_dn_rxActive(void)
{
	if (ESTATE_IDLE == sg_ecell_dn_rxState)
 4b8:	80 91 65 00 	lds	r24, 0x0065	; 0x800065 <sg_ecell_dn_rxState>
 4bc:	90 91 66 00 	lds	r25, 0x0066	; 0x800066 <sg_ecell_dn_rxState+0x1>
 4c0:	89 2b       	or	r24, r25
 4c2:	11 f4       	brne	.+4      	; 0x4c8 <vUARTIscell_dn_rxActive+0x10>
	{
		return(false);
 4c4:	80 e0       	ldi	r24, 0x00	; 0
 4c6:	08 95       	ret
	}
	else
	{
		return(true);
 4c8:	81 e0       	ldi	r24, 0x01	; 1
	}
}
 4ca:	08 95       	ret

000004cc <vUARTInitTransmit>:
{
	// Fire up the profiler (if available)
	PROFILER_INIT();

	// Cell_dn_rx to allow receives. We do not need cell_up_tx interrupts
	INT_CELL_DN_RX_ENABLE();
 4cc:	85 b3       	in	r24, 0x15	; 21
 4ce:	82 60       	ori	r24, 0x02	; 2
 4d0:	85 bb       	out	0x15, r24	; 21
 4d2:	08 95       	ret

000004d4 <vUARTInitReceive>:
}

// Enables receive communication from cell CPUs to module CPU
void vUARTInitReceive(void)
{
	sg_bcell_up_rx_Enabled = true;
 4d4:	81 e0       	ldi	r24, 0x01	; 1
 4d6:	80 93 69 00 	sts	0x0069, r24	; 0x800069 <sg_bcell_up_rx_Enabled>
	
	// Set up receives in the cell_up_tx direction
	INT_CELL_UP_RX_ENABLE();
 4da:	85 b3       	in	r24, 0x15	; 21
 4dc:	80 61       	ori	r24, 0x10	; 16
 4de:	85 bb       	out	0x15, r24	; 21
 4e0:	08 95       	ret

Disassembly of section .text.__dummy_fini:

00000a5a <_fini>:
 a5a:	08 95       	ret

Disassembly of section .text.__dummy_funcs_on_exit:

00000a5c <__funcs_on_exit>:
 a5c:	08 95       	ret

Disassembly of section .text.__dummy_simulator_exit:

00000a5e <__simulator_exit>:
 a5e:	08 95       	ret

Disassembly of section .text.exit:

00000a4a <exit>:
 a4a:	ec 01       	movw	r28, r24
 a4c:	07 d0       	rcall	.+14     	; 0xa5c <__funcs_on_exit>
 a4e:	05 d0       	rcall	.+10     	; 0xa5a <_fini>
 a50:	ce 01       	movw	r24, r28
 a52:	05 d0       	rcall	.+10     	; 0xa5e <__simulator_exit>
 a54:	ce 01       	movw	r24, r28
 a56:	04 d0       	rcall	.+8      	; 0xa60 <_Exit>

Disassembly of section .text._Exit:

00000a60 <_Exit>:
 a60:	07 db       	rcall	.-2546   	; 0x70 <_exit>
