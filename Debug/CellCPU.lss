
CellCPU.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000074  00000000  00000000  000000f4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00000074  0000058c  2**0
                  ALLOC
  2 .fuse         00000003  00820000  00820000  00000b0c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  3 .comment      0000002f  00000000  00000000  00000b0f  2**0
                  CONTENTS, READONLY
  4 .stack.descriptors.hdr 0000000e  00000000  00000000  00000b3e  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 000000b8  00000000  00000000  00000b4c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002051  00000000  00000000  00000c04  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000945  00000000  00000000  00002c55  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000d78  00000000  00000000  0000359a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000048c  00000000  00000000  00004314  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000280  00000000  00000000  000047a0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000a5c  00000000  00000000  00004a20  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .text         00000002  00000a0e  00000a0e  00000b02  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 13 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000547c  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .text         00000024  000009dc  000009dc  00000ad0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 15 .text         00000178  000007ac  000007ac  000008a0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 16 .text         00000314  00000498  00000498  0000058c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 17 .bss          0000000e  0080006f  0080006f  00000b0c  2**0
                  ALLOC
 18 .text         000000b8  00000924  00000924  00000a18  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 19 .text         00000424  00000074  00000074  00000168  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 20 .bss          0000000f  00800060  00800060  00000b0c  2**0
                  ALLOC
 21 .text.__dummy_fini 00000002  00000a10  00000a10  00000b04  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 22 .text.__dummy_funcs_on_exit 00000002  00000a12  00000a12  00000b06  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 23 .text.__dummy_simulator_exit 00000002  00000a14  00000a14  00000b08  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 24 .text.exit    0000000e  00000a00  00000a00  00000af4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 25 .text._Exit   00000002  00000a16  00000a16  00000b0a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE

Disassembly of section .text:

00000000 <__vectors>:
   0:	11 c0       	rjmp	.+34     	; 0x24 <__ctors_end>
   2:	92 c3       	rjmp	.+1828   	; 0x728 <__vector_1>
   4:	37 c0       	rjmp	.+110    	; 0x74 <_etext>
   6:	03 c5       	rjmp	.+2566   	; 0xa0e <__bad_interrupt>
   8:	95 c3       	rjmp	.+1834   	; 0x734 <__vector_4>
   a:	9a c3       	rjmp	.+1844   	; 0x740 <__vector_5>
   c:	ab c3       	rjmp	.+1878   	; 0x764 <__vector_6>
   e:	b0 c3       	rjmp	.+1888   	; 0x770 <__vector_7>
  10:	fe c4       	rjmp	.+2556   	; 0xa0e <__bad_interrupt>
  12:	fd c4       	rjmp	.+2554   	; 0xa0e <__bad_interrupt>
  14:	3b c1       	rjmp	.+630    	; 0x28c <__vector_10>
  16:	a6 c0       	rjmp	.+332    	; 0x164 <__vector_11>
  18:	fa c4       	rjmp	.+2548   	; 0xa0e <__bad_interrupt>
  1a:	98 c3       	rjmp	.+1840   	; 0x74c <__vector_13>
  1c:	9d c3       	rjmp	.+1850   	; 0x758 <__vector_14>

0000001e <.dinit>:
  1e:	00 60       	ori	r16, 0x00	; 0
  20:	00 7d       	andi	r16, 0xD0	; 208
  22:	80 00       	.word	0x0080	; ????

00000024 <__ctors_end>:
  24:	11 24       	eor	r1, r1
  26:	1f be       	out	0x3f, r1	; 63
  28:	cf e5       	ldi	r28, 0x5F	; 95
  2a:	d1 e0       	ldi	r29, 0x01	; 1
  2c:	de bf       	out	0x3e, r29	; 62
  2e:	cd bf       	out	0x3d, r28	; 61

00000030 <__do_copy_data>:
  30:	ee e1       	ldi	r30, 0x1E	; 30
  32:	f0 e0       	ldi	r31, 0x00	; 0
  34:	40 e0       	ldi	r20, 0x00	; 0
  36:	17 c0       	rjmp	.+46     	; 0x66 <__do_clear_bss+0x8>
  38:	b5 91       	lpm	r27, Z+
  3a:	a5 91       	lpm	r26, Z+
  3c:	35 91       	lpm	r19, Z+
  3e:	25 91       	lpm	r18, Z+
  40:	05 91       	lpm	r16, Z+
  42:	07 fd       	sbrc	r16, 7
  44:	0c c0       	rjmp	.+24     	; 0x5e <__do_clear_bss>
  46:	95 91       	lpm	r25, Z+
  48:	85 91       	lpm	r24, Z+
  4a:	ef 01       	movw	r28, r30
  4c:	f9 2f       	mov	r31, r25
  4e:	e8 2f       	mov	r30, r24
  50:	05 90       	lpm	r0, Z+
  52:	0d 92       	st	X+, r0
  54:	a2 17       	cp	r26, r18
  56:	b3 07       	cpc	r27, r19
  58:	d9 f7       	brne	.-10     	; 0x50 <__SREG__+0x11>
  5a:	fe 01       	movw	r30, r28
  5c:	04 c0       	rjmp	.+8      	; 0x66 <__do_clear_bss+0x8>

0000005e <__do_clear_bss>:
  5e:	1d 92       	st	X+, r1
  60:	a2 17       	cp	r26, r18
  62:	b3 07       	cpc	r27, r19
  64:	e1 f7       	brne	.-8      	; 0x5e <__do_clear_bss>
  66:	e3 32       	cpi	r30, 0x23	; 35
  68:	f4 07       	cpc	r31, r20
  6a:	31 f7       	brne	.-52     	; 0x38 <__do_copy_data+0x8>
  6c:	8d d2       	rcall	.+1306   	; 0x588 <main>
  6e:	c8 c4       	rjmp	.+2448   	; 0xa00 <exit>

00000070 <_exit>:
  70:	f8 94       	cli

00000072 <__stop_program>:
  72:	ff cf       	rjmp	.-2      	; 0x72 <__stop_program>

Disassembly of section .text:

00000a0e <__bad_interrupt>:
 a0e:	f8 ca       	rjmp	.-2576   	; 0x0 <__TEXT_REGION_ORIGIN__>

Disassembly of section .text:

000009dc <ADCRead>:
uint16_t ADCRead(void)
{
	uint16_t u16Reading;
	
    // Set the prescaler to clock/2 & enable ADC
    ADCSRA |= (1 << ADPS0) | (1 << ADEN);
 9dc:	86 b1       	in	r24, 0x06	; 6
 9de:	81 68       	ori	r24, 0x81	; 129
 9e0:	86 b9       	out	0x06, r24	; 6

	// Minor delay so we get a reasonable value
	Delay(20);
 9e2:	84 e1       	ldi	r24, 0x14	; 20
 9e4:	90 e0       	ldi	r25, 0x00	; 0
 9e6:	58 dd       	rcall	.-1360   	; 0x498 <Delay>
    
    // Read the ADC in order to get a 10 bit reading of where it is.
    // Start the conversion
    ADCSRA |= (1 << ADSC);
 9e8:	86 b1       	in	r24, 0x06	; 6
 9ea:	80 64       	ori	r24, 0x40	; 64
 9ec:	86 b9       	out	0x06, r24	; 6

    // Wait for it to finish - blocking
    while (ADCSRA & (1 << ADSC));
 9ee:	36 99       	sbic	0x06, 6	; 6
 9f0:	fe cf       	rjmp	.-4      	; 0x9ee <ADCRead+0x12>
	
	// Get the actual reading
	u16Reading = ADC;
 9f2:	24 b1       	in	r18, 0x04	; 4
 9f4:	35 b1       	in	r19, 0x05	; 5
	
	// Power down the ADC
	ADCSRA &= ~(1 << ADEN);
 9f6:	96 b1       	in	r25, 0x06	; 6
 9f8:	9f 77       	andi	r25, 0x7F	; 127
 9fa:	96 b9       	out	0x06, r25	; 6
    
    return(u16Reading);
}
 9fc:	c9 01       	movw	r24, r18
 9fe:	08 95       	ret

Disassembly of section .text:

000007ac <I2CQuantizeTiming>:
}

// Causes the code to become synchronized with 
static void I2CQuantizeTiming(void)
{
	Delay(1);
 7ac:	81 e0       	ldi	r24, 0x01	; 1
 7ae:	90 e0       	ldi	r25, 0x00	; 0
 7b0:	73 de       	rcall	.-794    	; 0x498 <Delay>
 7b2:	08 95       	ret

000007b4 <I2CBitDelay>:
#include "Platform.h"

// Delays for one I2C bit's worth of time
static void I2CBitDelay(void)
{
	Delay(5);
 7b4:	85 e0       	ldi	r24, 0x05	; 5
 7b6:	90 e0       	ldi	r25, 0x00	; 0
 7b8:	6f de       	rcall	.-802    	; 0x498 <Delay>
 7ba:	08 95       	ret

000007bc <I2CStart>:

// Send an I2C start sequence and quantize foreground code to the overflow
// timer
void I2CStart(void)
{
	I2CQuantizeTiming();
 7bc:	f7 df       	rcall	.-18     	; 0x7ac <I2CQuantizeTiming>

	SDA_SET_OUTPUT();
 7be:	87 b3       	in	r24, 0x17	; 23
 7c0:	84 60       	ori	r24, 0x04	; 4
 7c2:	87 bb       	out	0x17, r24	; 23
	SDA_HIGH();
 7c4:	88 b3       	in	r24, 0x18	; 24
 7c6:	84 60       	ori	r24, 0x04	; 4
 7c8:	88 bb       	out	0x18, r24	; 24
	SCL_HIGH();
 7ca:	88 b3       	in	r24, 0x18	; 24
 7cc:	88 60       	ori	r24, 0x08	; 8
 7ce:	88 bb       	out	0x18, r24	; 24
	I2CBitDelay();
 7d0:	f1 df       	rcall	.-30     	; 0x7b4 <I2CBitDelay>
	SDA_LOW();
 7d2:	88 b3       	in	r24, 0x18	; 24
 7d4:	8b 7f       	andi	r24, 0xFB	; 251
 7d6:	88 bb       	out	0x18, r24	; 24
	I2CBitDelay();
 7d8:	ed df       	rcall	.-38     	; 0x7b4 <I2CBitDelay>
	SCL_LOW();
 7da:	88 b3       	in	r24, 0x18	; 24
 7dc:	87 7f       	andi	r24, 0xF7	; 247
 7de:	88 bb       	out	0x18, r24	; 24
	I2CBitDelay();
 7e0:	e9 df       	rcall	.-46     	; 0x7b4 <I2CBitDelay>
 7e2:	08 95       	ret

000007e4 <I2CStop>:
}

// Send an I2C stop sequence
void I2CStop(void)
{
	I2CQuantizeTiming();
 7e4:	e3 df       	rcall	.-58     	; 0x7ac <I2CQuantizeTiming>

	SDA_LOW();
 7e6:	88 b3       	in	r24, 0x18	; 24
 7e8:	8b 7f       	andi	r24, 0xFB	; 251
 7ea:	88 bb       	out	0x18, r24	; 24
	I2CBitDelay();
 7ec:	e3 df       	rcall	.-58     	; 0x7b4 <I2CBitDelay>
	SCL_HIGH();
 7ee:	88 b3       	in	r24, 0x18	; 24
 7f0:	88 60       	ori	r24, 0x08	; 8
 7f2:	88 bb       	out	0x18, r24	; 24
	I2CBitDelay();
 7f4:	df df       	rcall	.-66     	; 0x7b4 <I2CBitDelay>
	SDA_SET_INPUT();
 7f6:	87 b3       	in	r24, 0x17	; 23
 7f8:	8b 7f       	andi	r24, 0xFB	; 251
 7fa:	87 bb       	out	0x17, r24	; 23
 7fc:	88 b3       	in	r24, 0x18	; 24
 7fe:	84 60       	ori	r24, 0x04	; 4
 800:	88 bb       	out	0x18, r24	; 24
	I2CBitDelay();
 802:	d8 df       	rcall	.-80     	; 0x7b4 <I2CBitDelay>
 804:	08 95       	ret

00000806 <I2CTxByte>:
}

// Sends a single I2C byte. Returns false if the byte is not acked, or true if it is.
bool I2CTxByte(uint8_t u8Byte)
{
 806:	cf 93       	push	r28
 808:	df 93       	push	r29
 80a:	d8 2f       	mov	r29, r24
	uint8_t u8Length = 8;			// 8 Bits to send
	bool bAck = false;

	I2CQuantizeTiming();
 80c:	cf df       	rcall	.-98     	; 0x7ac <I2CQuantizeTiming>
	SDA_SET_OUTPUT();
 80e:	87 b3       	in	r24, 0x17	; 23
 810:	84 60       	ori	r24, 0x04	; 4
 812:	87 bb       	out	0x17, r24	; 23
}

// Sends a single I2C byte. Returns false if the byte is not acked, or true if it is.
bool I2CTxByte(uint8_t u8Byte)
{
	uint8_t u8Length = 8;			// 8 Bits to send
 814:	c8 e0       	ldi	r28, 0x08	; 8
	bool bAck = false;

	I2CQuantizeTiming();
	SDA_SET_OUTPUT();

	while (u8Length)
 816:	13 c0       	rjmp	.+38     	; 0x83e <I2CTxByte+0x38>
	{
		if (u8Byte & 0x80)
 818:	dd 23       	and	r29, r29
 81a:	24 f4       	brge	.+8      	; 0x824 <I2CTxByte+0x1e>
		{
			SDA_HIGH();
 81c:	88 b3       	in	r24, 0x18	; 24
 81e:	84 60       	ori	r24, 0x04	; 4
 820:	88 bb       	out	0x18, r24	; 24
 822:	03 c0       	rjmp	.+6      	; 0x82a <I2CTxByte+0x24>
		}
		else
		{
			SDA_LOW();
 824:	88 b3       	in	r24, 0x18	; 24
 826:	8b 7f       	andi	r24, 0xFB	; 251
 828:	88 bb       	out	0x18, r24	; 24
		}
		
		// Drive SCL high
		SCL_HIGH();
 82a:	88 b3       	in	r24, 0x18	; 24
 82c:	88 60       	ori	r24, 0x08	; 8
 82e:	88 bb       	out	0x18, r24	; 24
		
		I2CBitDelay();
 830:	c1 df       	rcall	.-126    	; 0x7b4 <I2CBitDelay>
		
		// Ensure SCL is low
		SCL_LOW();
 832:	88 b3       	in	r24, 0x18	; 24
 834:	87 7f       	andi	r24, 0xF7	; 247
 836:	88 bb       	out	0x18, r24	; 24
	
		// SDA Is now set. Delay.
		I2CBitDelay();
 838:	bd df       	rcall	.-134    	; 0x7b4 <I2CBitDelay>
		
		// Next bit
		u8Byte <<= 1;	
 83a:	dd 0f       	add	r29, r29
		u8Length--;
 83c:	c1 50       	subi	r28, 0x01	; 1
	bool bAck = false;

	I2CQuantizeTiming();
	SDA_SET_OUTPUT();

	while (u8Length)
 83e:	c1 11       	cpse	r28, r1
 840:	eb cf       	rjmp	.-42     	; 0x818 <I2CTxByte+0x12>
		// Next bit
		u8Byte <<= 1;	
		u8Length--;
	}
	
	SDA_SET_INPUT();
 842:	87 b3       	in	r24, 0x17	; 23
 844:	8b 7f       	andi	r24, 0xFB	; 251
 846:	87 bb       	out	0x17, r24	; 23
 848:	88 b3       	in	r24, 0x18	; 24
 84a:	84 60       	ori	r24, 0x04	; 4
 84c:	88 bb       	out	0x18, r24	; 24
	SCL_HIGH();
 84e:	88 b3       	in	r24, 0x18	; 24
 850:	88 60       	ori	r24, 0x08	; 8
 852:	88 bb       	out	0x18, r24	; 24
	I2CBitDelay();
 854:	af df       	rcall	.-162    	; 0x7b4 <I2CBitDelay>
	
	// See if the byte was acknowledged
	if (SDA_READ())
 856:	b2 9b       	sbis	0x16, 2	; 22
	{
		bAck = false;
	}
	else
	{
		bAck = true;
 858:	c1 e0       	ldi	r28, 0x01	; 1
	}
	
	SCL_LOW();
 85a:	88 b3       	in	r24, 0x18	; 24
 85c:	87 7f       	andi	r24, 0xF7	; 247
 85e:	88 bb       	out	0x18, r24	; 24
	I2CBitDelay();
 860:	a9 df       	rcall	.-174    	; 0x7b4 <I2CBitDelay>
	return(bAck);
}
 862:	8c 2f       	mov	r24, r28
 864:	df 91       	pop	r29
 866:	cf 91       	pop	r28
 868:	08 95       	ret

0000086a <I2CRxByte>:

// Receives a single I2C byte and will optionally generate an ack at the end
uint8_t I2CRxByte(bool bAck)
{
 86a:	1f 93       	push	r17
 86c:	cf 93       	push	r28
 86e:	df 93       	push	r29
 870:	18 2f       	mov	r17, r24
	uint8_t u8Data = 0;
	uint8_t u8Count = 8;
	
	I2CQuantizeTiming();
 872:	9c df       	rcall	.-200    	; 0x7ac <I2CQuantizeTiming>

	SDA_SET_INPUT();
 874:	87 b3       	in	r24, 0x17	; 23
 876:	8b 7f       	andi	r24, 0xFB	; 251
 878:	87 bb       	out	0x17, r24	; 23
 87a:	88 b3       	in	r24, 0x18	; 24
 87c:	84 60       	ori	r24, 0x04	; 4
 87e:	88 bb       	out	0x18, r24	; 24

// Receives a single I2C byte and will optionally generate an ack at the end
uint8_t I2CRxByte(bool bAck)
{
	uint8_t u8Data = 0;
	uint8_t u8Count = 8;
 880:	c8 e0       	ldi	r28, 0x08	; 8
}

// Receives a single I2C byte and will optionally generate an ack at the end
uint8_t I2CRxByte(bool bAck)
{
	uint8_t u8Data = 0;
 882:	d0 e0       	ldi	r29, 0x00	; 0
	I2CQuantizeTiming();

	SDA_SET_INPUT();
	
	// Consume all 8 data bits
	while (u8Count)
 884:	0c c0       	rjmp	.+24     	; 0x89e <I2CRxByte+0x34>
	{
		u8Data <<= 1;
 886:	dd 0f       	add	r29, r29

		SCL_HIGH();
 888:	88 b3       	in	r24, 0x18	; 24
 88a:	88 60       	ori	r24, 0x08	; 8
 88c:	88 bb       	out	0x18, r24	; 24
		I2CBitDelay();
 88e:	92 df       	rcall	.-220    	; 0x7b4 <I2CBitDelay>
			
		if (SDA_READ())
 890:	b2 99       	sbic	0x16, 2	; 22
		{
			u8Data |= 1;
 892:	d1 60       	ori	r29, 0x01	; 1
		}
		
		SCL_LOW();
 894:	88 b3       	in	r24, 0x18	; 24
 896:	87 7f       	andi	r24, 0xF7	; 247
 898:	88 bb       	out	0x18, r24	; 24
		I2CBitDelay();
 89a:	8c df       	rcall	.-232    	; 0x7b4 <I2CBitDelay>
		u8Count--;
 89c:	c1 50       	subi	r28, 0x01	; 1
	I2CQuantizeTiming();

	SDA_SET_INPUT();
	
	// Consume all 8 data bits
	while (u8Count)
 89e:	c1 11       	cpse	r28, r1
 8a0:	f2 cf       	rjmp	.-28     	; 0x886 <I2CRxByte+0x1c>
		I2CBitDelay();
		u8Count--;
	}

	// See if we acknowledge this
	SDA_SET_OUTPUT();
 8a2:	87 b3       	in	r24, 0x17	; 23
 8a4:	84 60       	ori	r24, 0x04	; 4
 8a6:	87 bb       	out	0x17, r24	; 23
	if (bAck)
 8a8:	11 23       	and	r17, r17
 8aa:	21 f0       	breq	.+8      	; 0x8b4 <I2CRxByte+0x4a>
	{
		SDA_LOW();
 8ac:	88 b3       	in	r24, 0x18	; 24
 8ae:	8b 7f       	andi	r24, 0xFB	; 251
 8b0:	88 bb       	out	0x18, r24	; 24
 8b2:	03 c0       	rjmp	.+6      	; 0x8ba <I2CRxByte+0x50>
	}
	else
	{
		SDA_HIGH();
 8b4:	88 b3       	in	r24, 0x18	; 24
 8b6:	84 60       	ori	r24, 0x04	; 4
 8b8:	88 bb       	out	0x18, r24	; 24
	}
	
	I2CBitDelay();
 8ba:	7c df       	rcall	.-264    	; 0x7b4 <I2CBitDelay>
	SCL_HIGH();
 8bc:	88 b3       	in	r24, 0x18	; 24
 8be:	88 60       	ori	r24, 0x08	; 8
 8c0:	88 bb       	out	0x18, r24	; 24
	I2CBitDelay();
 8c2:	78 df       	rcall	.-272    	; 0x7b4 <I2CBitDelay>
	SCL_LOW();
 8c4:	88 b3       	in	r24, 0x18	; 24
 8c6:	87 7f       	andi	r24, 0xF7	; 247
 8c8:	88 bb       	out	0x18, r24	; 24
	I2CBitDelay();
 8ca:	74 df       	rcall	.-280    	; 0x7b4 <I2CBitDelay>
	SDA_LOW();
 8cc:	88 b3       	in	r24, 0x18	; 24
 8ce:	8b 7f       	andi	r24, 0xFB	; 251
 8d0:	88 bb       	out	0x18, r24	; 24

	return(u8Data);	
}
 8d2:	8d 2f       	mov	r24, r29
 8d4:	df 91       	pop	r29
 8d6:	cf 91       	pop	r28
 8d8:	1f 91       	pop	r17
 8da:	08 95       	ret

000008dc <I2CSetup>:
// Prepares the SCL/SDA pins for I2C operation and returns when the CPU is
// quantized to the timer (for consistent bit alignment)
void I2CSetup(void)
{
	// Deassert SCL and SDA
	SCL_HIGH();
 8dc:	88 b3       	in	r24, 0x18	; 24
 8de:	88 60       	ori	r24, 0x08	; 8
 8e0:	88 bb       	out	0x18, r24	; 24
	SDA_HIGH();
 8e2:	88 b3       	in	r24, 0x18	; 24
 8e4:	84 60       	ori	r24, 0x04	; 4
 8e6:	88 bb       	out	0x18, r24	; 24

	// Set SCL and SDA lines as push/pull output drives
	SCL_SET_OUTPUT();
 8e8:	87 b3       	in	r24, 0x17	; 23
 8ea:	88 60       	ori	r24, 0x08	; 8
 8ec:	87 bb       	out	0x17, r24	; 23
	
	// Turn on SDA, set as an input
	SDA_SET_INPUT();
 8ee:	87 b3       	in	r24, 0x17	; 23
 8f0:	8b 7f       	andi	r24, 0xFB	; 251
 8f2:	87 bb       	out	0x17, r24	; 23
 8f4:	88 b3       	in	r24, 0x18	; 24
 8f6:	84 60       	ori	r24, 0x04	; 4
 8f8:	88 bb       	out	0x18, r24	; 24
	
	Delay(20);
 8fa:	84 e1       	ldi	r24, 0x14	; 20
 8fc:	90 e0       	ldi	r25, 0x00	; 0
 8fe:	cc dd       	rcall	.-1128   	; 0x498 <Delay>
 900:	08 95       	ret

00000902 <I2CStartTransaction>:

// Sets up the I2C pins, sends slave address/read/write byte, and waits for acknowledgment.
// Returns false if no device is responding.
bool I2CStartTransaction(uint8_t u8SlaveAddress,
						 bool bRead)
{
 902:	cf 93       	push	r28
 904:	df 93       	push	r29
 906:	c8 2f       	mov	r28, r24
 908:	d6 2f       	mov	r29, r22
	// Set up the pins for I2C operation
	I2CSetup();
 90a:	e8 df       	rcall	.-48     	; 0x8dc <I2CSetup>
	
	// I2C Start condition
	I2CStart();
 90c:	57 df       	rcall	.-338    	; 0x7bc <I2CStart>

	// If it's a read operation, clear the lower bit
	if (bRead)
 90e:	dd 23       	and	r29, r29
 910:	19 f0       	breq	.+6      	; 0x918 <I2CStartTransaction+0x16>
	{
		u8SlaveAddress |= 1;
 912:	8c 2f       	mov	r24, r28
 914:	81 60       	ori	r24, 0x01	; 1
 916:	02 c0       	rjmp	.+4      	; 0x91c <I2CStartTransaction+0x1a>
	}
	else
	{
		// Otherwise set it
		u8SlaveAddress &= (uint8_t) (~1);
 918:	8c 2f       	mov	r24, r28
 91a:	8e 7f       	andi	r24, 0xFE	; 254
	}
	
	// Now send out the slave address + the read/write bit
	return(I2CTxByte(u8SlaveAddress));
 91c:	74 df       	rcall	.-280    	; 0x806 <I2CTxByte>
}
 91e:	df 91       	pop	r29
 920:	cf 91       	pop	r28
 922:	08 95       	ret

Disassembly of section .text:

00000498 <Delay>:
// next timer tick change.
void Delay(uint16_t u16Ticks)
{
	uint8_t u8Sample;
	
	u16Ticks++;
 498:	ac 01       	movw	r20, r24
 49a:	4f 5f       	subi	r20, 0xFF	; 255
 49c:	5f 4f       	sbci	r21, 0xFF	; 255
	
	u8Sample = TIMER_COUNTER();
 49e:	22 b7       	in	r18, 0x32	; 50
	while (u16Ticks)
 4a0:	06 c0       	rjmp	.+12     	; 0x4ae <Delay+0x16>
	{
		// Wait until we quantize
		while (u8Sample == TIMER_COUNTER());
 4a2:	92 b7       	in	r25, 0x32	; 50
 4a4:	29 17       	cp	r18, r25
 4a6:	e9 f3       	breq	.-6      	; 0x4a2 <Delay+0xa>
		
		u8Sample = TIMER_COUNTER();
 4a8:	22 b7       	in	r18, 0x32	; 50
		--u16Ticks;
 4aa:	41 50       	subi	r20, 0x01	; 1
 4ac:	51 09       	sbc	r21, r1
	uint8_t u8Sample;
	
	u16Ticks++;
	
	u8Sample = TIMER_COUNTER();
	while (u16Ticks)
 4ae:	41 15       	cp	r20, r1
 4b0:	51 05       	cpc	r21, r1
 4b2:	b9 f7       	brne	.-18     	; 0x4a2 <Delay+0xa>
		while (u8Sample == TIMER_COUNTER());
		
		u8Sample = TIMER_COUNTER();
		--u16Ticks;
	}
}
 4b4:	08 95       	ret

000004b6 <Celldn_txDataAvailable>:
// Returns true if cell data is available. See message above for the meaning of >=4
bool Celldn_txDataAvailable(void)
{
	// We signal no more data available at the 4th byte (offset 3)
	// but still need to transmit the final byte.
	if (sg_u8TransmitOffset >= 4)
 4b6:	80 91 70 00 	lds	r24, 0x0070	; 0x800070 <sg_u8TransmitOffset>
 4ba:	84 30       	cpi	r24, 0x04	; 4
 4bc:	10 f0       	brcs	.+4      	; 0x4c2 <Celldn_txDataAvailable+0xc>
	{
		return(false);
 4be:	80 e0       	ldi	r24, 0x00	; 0
 4c0:	08 95       	ret
	}
	
	return(true);
 4c2:	81 e0       	ldi	r24, 0x01	; 1
}
 4c4:	08 95       	ret

000004c6 <Celldn_txDataGet>:
// Returns the next byte of cell data we want to transmit to the next cell, etc... module controller
uint8_t Celldn_txDataGet(void)
{
	uint8_t u8Data = 0xff;
	
	if (0 == sg_u8TransmitOffset)
 4c6:	90 91 70 00 	lds	r25, 0x0070	; 0x800070 <sg_u8TransmitOffset>
 4ca:	91 11       	cpse	r25, r1
 4cc:	03 c0       	rjmp	.+6      	; 0x4d4 <Celldn_txDataGet+0xe>
	{
		// 0 - LSB Voltage
		u8Data = (uint8_t) sg_u16BatteryVoltage;
 4ce:	80 91 7b 00 	lds	r24, 0x007B	; 0x80007b <sg_u16BatteryVoltage>
 4d2:	16 c0       	rjmp	.+44     	; 0x500 <Celldn_txDataGet+0x3a>
	}
	else
	if (1 == sg_u8TransmitOffset)
 4d4:	91 30       	cpi	r25, 0x01	; 1
 4d6:	19 f4       	brne	.+6      	; 0x4de <Celldn_txDataGet+0x18>
	{
		// 1 - MSB Voltage
		u8Data = (uint8_t) (sg_u16BatteryVoltage >> 8);
 4d8:	80 91 7c 00 	lds	r24, 0x007C	; 0x80007c <sg_u16BatteryVoltage+0x1>
 4dc:	11 c0       	rjmp	.+34     	; 0x500 <Celldn_txDataGet+0x3a>
	}
	else
	if (2 == sg_u8TransmitOffset)
 4de:	92 30       	cpi	r25, 0x02	; 2
 4e0:	31 f4       	brne	.+12     	; 0x4ee <Celldn_txDataGet+0x28>
	{
		// 2 - LSB Temperature
		u8Data = (uint8_t) sg_u16BatteryTemperature;
 4e2:	20 91 79 00 	lds	r18, 0x0079	; 0x800079 <sg_u16BatteryTemperature>
 4e6:	30 91 7a 00 	lds	r19, 0x007A	; 0x80007a <sg_u16BatteryTemperature+0x1>
 4ea:	82 2f       	mov	r24, r18
 4ec:	09 c0       	rjmp	.+18     	; 0x500 <Celldn_txDataGet+0x3a>
	}
	else
	if (3 == sg_u8TransmitOffset)
 4ee:	93 30       	cpi	r25, 0x03	; 3
 4f0:	31 f4       	brne	.+12     	; 0x4fe <Celldn_txDataGet+0x38>
	{
		// 3 - MSB Temperature
		u8Data = (uint8_t) (sg_u16BatteryTemperature >> 8);
 4f2:	20 91 79 00 	lds	r18, 0x0079	; 0x800079 <sg_u16BatteryTemperature>
 4f6:	30 91 7a 00 	lds	r19, 0x007A	; 0x80007a <sg_u16BatteryTemperature+0x1>
 4fa:	83 2f       	mov	r24, r19
 4fc:	01 c0       	rjmp	.+2      	; 0x500 <Celldn_txDataGet+0x3a>
}

// Returns the next byte of cell data we want to transmit to the next cell, etc... module controller
uint8_t Celldn_txDataGet(void)
{
	uint8_t u8Data = 0xff;
 4fe:	8f ef       	ldi	r24, 0xFF	; 255
	{
		// 3 - MSB Temperature
		u8Data = (uint8_t) (sg_u16BatteryTemperature >> 8);
	}
	
	sg_u8TransmitOffset++;
 500:	9f 5f       	subi	r25, 0xFF	; 255
 502:	90 93 70 00 	sts	0x0070, r25	; 0x800070 <sg_u8TransmitOffset>
	return(u8Data);
}
 506:	08 95       	ret

00000508 <Celldn_txDataReset>:
// Resets the cell data state machine if necessary. This is called upon the falling
// edge of the start of a receive stream.
void Celldn_txDataReset(void)
{
	// Offset back to 0
	sg_u8TransmitOffset = 0;
 508:	10 92 70 00 	sts	0x0070, r1	; 0x800070 <sg_u8TransmitOffset>
 50c:	08 95       	ret

0000050e <Celldn_txTransmitStart>:

// Called right before data is transmitted/appended
void Celldn_txTransmitStart(void)
{
	// Sending the 0th byte
	sg_u8TransmitOffset = 0;
 50e:	10 92 70 00 	sts	0x0070, r1	; 0x800070 <sg_u8TransmitOffset>
 512:	08 95       	ret

00000514 <Celldn_rxDataStart>:
// type.

// Called when start of message from module controller or upstream is started
void Celldn_rxDataStart(void)
{
	sg_u8dn_rxBitCount = 0;
 514:	10 92 6f 00 	sts	0x006F, r1	; 0x80006f <sg_u8dn_rxBitCount>
	sg_u16BatteryVoltageMsg = 0;
 518:	10 92 74 00 	sts	0x0074, r1	; 0x800074 <sg_u16BatteryVoltageMsg+0x1>
 51c:	10 92 73 00 	sts	0x0073, r1	; 0x800073 <sg_u16BatteryVoltageMsg>
 520:	08 95       	ret

00000522 <Celldn_rxDataBit>:
// for further specific illustration.

// Called for each received bit from the dn_rx direction (from the module controller)
void Celldn_rxDataBit(uint8_t u8DataBit)
{
	sg_u16BatteryVoltageMsg <<= 1;
 522:	20 91 73 00 	lds	r18, 0x0073	; 0x800073 <sg_u16BatteryVoltageMsg>
 526:	30 91 74 00 	lds	r19, 0x0074	; 0x800074 <sg_u16BatteryVoltageMsg+0x1>
 52a:	22 0f       	add	r18, r18
 52c:	33 1f       	adc	r19, r19
	sg_u16BatteryVoltageMsg |= u8DataBit;
 52e:	a9 01       	movw	r20, r18
 530:	48 2b       	or	r20, r24
 532:	ca 01       	movw	r24, r20
 534:	90 93 74 00 	sts	0x0074, r25	; 0x800074 <sg_u16BatteryVoltageMsg+0x1>
 538:	80 93 73 00 	sts	0x0073, r24	; 0x800073 <sg_u16BatteryVoltageMsg>
	sg_u8dn_rxBitCount++;
 53c:	20 91 6f 00 	lds	r18, 0x006F	; 0x80006f <sg_u8dn_rxBitCount>
 540:	2f 5f       	subi	r18, 0xFF	; 255
 542:	20 93 6f 00 	sts	0x006F, r18	; 0x80006f <sg_u8dn_rxBitCount>

	// Special case after reception of the second data bit - if this is
	// a request for a reading, then signal the foreground code to do
	// a sensor reading. This hastens the response time of the initial request.

	if (2 == sg_u8dn_rxBitCount)
 546:	22 30       	cpi	r18, 0x02	; 2
 548:	91 f4       	brne	.+36     	; 0x56e <Celldn_rxDataBit+0x4c>
	{
		// After the second bit, let's see if we send a report. If so, then flag it
		// and record the type. The shift is necessary because we haven't received all 
		// 16 bits yet - just look at the two that we've received.
		if (sg_u16BatteryVoltageMsg & (MSG_CELL_SEND_REPORT >> 14))
 54a:	81 ff       	sbrs	r24, 1
 54c:	1c c0       	rjmp	.+56     	; 0x586 <Celldn_rxDataBit+0x64>
		{
			// Indicates we want the cell CPU to send a report. Figure out which type.
			if (sg_u16BatteryVoltageMsg & (MSG_CELL_SEND_PATTERN >> 14))
 54e:	80 ff       	sbrs	r24, 0
 550:	07 c0       	rjmp	.+14     	; 0x560 <Celldn_rxDataBit+0x3e>
			{
				sg_eCellAction = EACTION_SEND_PATTERN;
 552:	82 e0       	ldi	r24, 0x02	; 2
 554:	90 e0       	ldi	r25, 0x00	; 0
 556:	90 93 72 00 	sts	0x0072, r25	; 0x800072 <sg_eCellAction+0x1>
 55a:	80 93 71 00 	sts	0x0071, r24	; 0x800071 <sg_eCellAction>
 55e:	08 95       	ret
				// chain, this will cause a reading to occur, then it will
				// originate transmission up the chain by sending its reading
				// to the next neighboring CPU. If it's not the CPU on the end,
				// it will simply perform the reading and wait for the downstream
				// message to append itself to.
				sg_eCellAction = EACTION_SEND_SENSOR_READING;
 560:	81 e0       	ldi	r24, 0x01	; 1
 562:	90 e0       	ldi	r25, 0x00	; 0
 564:	90 93 72 00 	sts	0x0072, r25	; 0x800072 <sg_eCellAction+0x1>
 568:	80 93 71 00 	sts	0x0071, r24	; 0x800071 <sg_eCellAction>
 56c:	08 95       	ret
		{
			// This is a new discharge target - ignore it
		}
	}
	else
	if (16 == sg_u8dn_rxBitCount)
 56e:	20 31       	cpi	r18, 0x10	; 16
 570:	51 f4       	brne	.+20     	; 0x586 <Celldn_rxDataBit+0x64>
	{
		if (sg_u16BatteryVoltageMsg & MSG_CELL_SEND_REPORT)
 572:	99 23       	and	r25, r25
 574:	24 f0       	brlt	.+8      	; 0x57e <Celldn_rxDataBit+0x5c>
			// We don't do anything because it already happened at bit 2 above.
		}
		else
		{
			// New voltage target - no need to mask off the upper bits since they'll be 0 here
			sg_u16BatteryVoltageTarget = sg_u16BatteryVoltageMsg;
 576:	90 93 78 00 	sts	0x0078, r25	; 0x800078 <sg_u16BatteryVoltageTarget+0x1>
 57a:	80 93 77 00 	sts	0x0077, r24	; 0x800077 <sg_u16BatteryVoltageTarget>
		}
		
		sg_u16BatteryVoltageMsg = 0;
 57e:	10 92 74 00 	sts	0x0074, r1	; 0x800074 <sg_u16BatteryVoltageMsg+0x1>
 582:	10 92 73 00 	sts	0x0073, r1	; 0x800073 <sg_u16BatteryVoltageMsg>
 586:	08 95       	ret

00000588 <main>:
*/

int main(void)
{
	// Stop all interrupts
	cli();
 588:	f8 94       	cli
	
	// Shut off the watchdog timer and reset reason
	MCUSR = 0;
 58a:	14 be       	out	0x34, r1	; 52
	DISABLE_WDT();
 58c:	81 b5       	in	r24, 0x21	; 33
 58e:	88 61       	ori	r24, 0x18	; 24
 590:	81 bd       	out	0x21, r24	; 33
 592:	11 bc       	out	0x21, r1	; 33
	
	// Init CPU clock
	CPU_CLOCK_INIT();
 594:	80 e8       	ldi	r24, 0x80	; 128
 596:	86 bd       	out	0x26, r24	; 38
 598:	16 bc       	out	0x26, r1	; 38
 59a:	15 ba       	out	0x15, r1	; 21
 59c:	10 bc       	out	0x20, r1	; 32
	
	// Ensure pullups aren't globally disabled
	MCUCR &= (uint8_t) ~(1 << PUD);
 59e:	85 b7       	in	r24, 0x35	; 53
 5a0:	8f 7b       	andi	r24, 0xBF	; 191
 5a2:	85 bf       	out	0x35, r24	; 53
	
	// Initialize virtual UART pins
	vUARTPinInit();
 5a4:	45 df       	rcall	.-374    	; 0x430 <vUARTPinInit>
	
    // Set the ADC input to MUX_SELECT
    ADC_ADMUX_SET();
 5a6:	83 e8       	ldi	r24, 0x83	; 131
 5a8:	87 b9       	out	0x07, r24	; 7
	
	// Drive cell_dn_tx low. This is required so we can detect if we're end-of-chain
	// or not.
	CELL_DN_TX_ASSERT();
 5aa:	88 b3       	in	r24, 0x18	; 24
 5ac:	8f 7d       	andi	r24, 0xDF	; 223
 5ae:	88 bb       	out	0x18, r24	; 24
	
	// Now init timer B
	TIMER_INIT();
 5b0:	1a bc       	out	0x2a, r1	; 42
 5b2:	82 e0       	ldi	r24, 0x02	; 2
 5b4:	83 bf       	out	0x33, r24	; 51
 5b6:	12 be       	out	0x32, r1	; 50
	
	// Set battery target voltage so the event/discharge is forced off
	sg_u16BatteryVoltageTarget = 0xffff;
 5b8:	8f ef       	ldi	r24, 0xFF	; 255
 5ba:	9f ef       	ldi	r25, 0xFF	; 255
 5bc:	90 93 78 00 	sts	0x0078, r25	; 0x800078 <sg_u16BatteryVoltageTarget+0x1>
 5c0:	80 93 77 00 	sts	0x0077, r24	; 0x800077 <sg_u16BatteryVoltageTarget>
	
	// This will cause discharge to get shut off initially
	sg_bDischargeActive = true;
 5c4:	91 e0       	ldi	r25, 0x01	; 1
 5c6:	90 93 76 00 	sts	0x0076, r25	; 0x800076 <sg_bDischargeActive>

	// Turn on interrupt functionality but no specific interrupts
	INT_ENABLE();
 5ca:	80 e2       	ldi	r24, 0x20	; 32
 5cc:	8b bf       	out	0x3b, r24	; 59
 5ce:	85 b7       	in	r24, 0x35	; 53
 5d0:	8c 7f       	andi	r24, 0xFC	; 252
 5d2:	81 60       	ori	r24, 0x01	; 1
 5d4:	85 bf       	out	0x35, r24	; 53
	
	// First thing is an init/sensor read
	sg_eCellAction = EACTION_INIT;
 5d6:	23 e0       	ldi	r18, 0x03	; 3
 5d8:	30 e0       	ldi	r19, 0x00	; 0
 5da:	30 93 72 00 	sts	0x0072, r19	; 0x800072 <sg_eCellAction+0x1>
 5de:	20 93 71 00 	sts	0x0071, r18	; 0x800071 <sg_eCellAction>
	sg_bCellCPULast = true;  // assume we're last in the chain
 5e2:	90 93 75 00 	sts	0x0075, r25	; 0x800075 <sg_bCellCPULast>

	// Enable CPU interrupts
	sei();
 5e6:	78 94       	sei
	{
		uint16_t u16Voltage;
		uint16_t u16Temperature;

		if ((EACTION_SEND_SENSOR_READING == sg_eCellAction) ||
			(EACTION_SEND_PATTERN == sg_eCellAction) || 
 5e8:	80 91 71 00 	lds	r24, 0x0071	; 0x800071 <sg_eCellAction>
 5ec:	90 91 72 00 	lds	r25, 0x0072	; 0x800072 <sg_eCellAction+0x1>
 5f0:	01 97       	sbiw	r24, 0x01	; 1
	while (1)
	{
		uint16_t u16Voltage;
		uint16_t u16Temperature;

		if ((EACTION_SEND_SENSOR_READING == sg_eCellAction) ||
 5f2:	03 97       	sbiw	r24, 0x03	; 3
 5f4:	08 f0       	brcs	.+2      	; 0x5f8 <main+0x70>
 5f6:	82 c0       	rjmp	.+260    	; 0x6fc <main+0x174>
		{
			bool bDischargeActive = false;
			
			// Read the voltage first since the MUX is switched to the ADC
			// by default
			u16Voltage = ADCRead();
 5f8:	f1 d1       	rcall	.+994    	; 0x9dc <ADCRead>
 5fa:	ec 01       	movw	r28, r24
			sg_u16BatteryVoltage = u16Voltage;
 5fc:	90 93 7c 00 	sts	0x007C, r25	; 0x80007c <sg_u16BatteryVoltage+0x1>
 600:	80 93 7b 00 	sts	0x007B, r24	; 0x80007b <sg_u16BatteryVoltage>
			
			if (IS_PIN_CELL_UP_RX_ASSERTED())  // do a quick detect prior to sensor read, but check again after
 604:	b4 99       	sbic	0x16, 4	; 22
			{
				// Pin is asserted, we're NOT the last CPU
				sg_bCellCPULast = false;
 606:	10 92 75 00 	sts	0x0075, r1	; 0x800075 <sg_bCellCPULast>
			}

			
			// Now temperature
			u16Temperature = MCP9843ReadTemperature();
 60a:	c4 d1       	rcall	.+904    	; 0x994 <MCP9843ReadTemperature>
 60c:	8c 01       	movw	r16, r24

			// Analog channel is now an input
			SCL_DISABLE();
 60e:	87 b3       	in	r24, 0x17	; 23
 610:	87 7f       	andi	r24, 0xF7	; 247
 612:	87 bb       	out	0x17, r24	; 23
 614:	88 b3       	in	r24, 0x18	; 24
 616:	87 7f       	andi	r24, 0xF7	; 247
 618:	88 bb       	out	0x18, r24	; 24
 61a:	88 b3       	in	r24, 0x18	; 24
 61c:	87 7f       	andi	r24, 0xF7	; 247
 61e:	88 bb       	out	0x18, r24	; 24
			
			// Set SCL back to analog input
			ADC_ADMUX_SET();
 620:	83 e8       	ldi	r24, 0x83	; 131
 622:	87 b9       	out	0x07, r24	; 7
			
			if (IS_PIN_CELL_UP_RX_ASSERTED())  // do a quick detect prior to possible event set, it may happen on some cells but not others
 624:	b4 99       	sbic	0x16, 4	; 22
			{
				// Pin is asserted, we're NOT the last CPU
				sg_bCellCPULast = false;
 626:	10 92 75 00 	sts	0x0075, r1	; 0x800075 <sg_bCellCPULast>
			}
			
			
			// While we have I2C operational, let's evaluate the discharge
			// state and change it if it's updated
			if (u16Voltage > sg_u16BatteryVoltageTarget)
 62a:	80 91 77 00 	lds	r24, 0x0077	; 0x800077 <sg_u16BatteryVoltageTarget>
 62e:	90 91 78 00 	lds	r25, 0x0078	; 0x800078 <sg_u16BatteryVoltageTarget+0x1>
 632:	8c 17       	cp	r24, r28
 634:	9d 07       	cpc	r25, r29
 636:	10 f0       	brcs	.+4      	; 0x63c <main+0xb4>

		if ((EACTION_SEND_SENSOR_READING == sg_eCellAction) ||
			(EACTION_SEND_PATTERN == sg_eCellAction) || 
			(EACTION_INIT == sg_eCellAction))
		{
			bool bDischargeActive = false;
 638:	80 e0       	ldi	r24, 0x00	; 0
 63a:	01 c0       	rjmp	.+2      	; 0x63e <main+0xb6>
			
			// While we have I2C operational, let's evaluate the discharge
			// state and change it if it's updated
			if (u16Voltage > sg_u16BatteryVoltageTarget)
			{
				bDischargeActive = true;
 63c:	81 e0       	ldi	r24, 0x01	; 1
			}
			
			// If the discharge state has changed, tell the MCP9843 about it
			if (bDischargeActive != sg_bDischargeActive)
 63e:	90 91 76 00 	lds	r25, 0x0076	; 0x800076 <sg_bDischargeActive>
 642:	89 17       	cp	r24, r25
 644:	a9 f0       	breq	.+42     	; 0x670 <main+0xe8>
			{
				sg_bDischargeActive = bDischargeActive;
 646:	80 93 76 00 	sts	0x0076, r24	; 0x800076 <sg_bDischargeActive>
				
				// Discharge is active LOW on the EVENT pin
				MCP9843SetEventPin(sg_bDischargeActive ? false : true);
 64a:	80 91 76 00 	lds	r24, 0x0076	; 0x800076 <sg_bDischargeActive>
 64e:	88 23       	and	r24, r24
 650:	11 f0       	breq	.+4      	; 0x656 <main+0xce>
 652:	80 e0       	ldi	r24, 0x00	; 0
 654:	01 c0       	rjmp	.+2      	; 0x658 <main+0xd0>
 656:	81 e0       	ldi	r24, 0x01	; 1
 658:	6f d1       	rcall	.+734    	; 0x938 <MCP9843SetEventPin>
				
				// Analog channel is now an input
				SCL_DISABLE();
 65a:	87 b3       	in	r24, 0x17	; 23
 65c:	87 7f       	andi	r24, 0xF7	; 247
 65e:	87 bb       	out	0x17, r24	; 23
 660:	88 b3       	in	r24, 0x18	; 24
 662:	87 7f       	andi	r24, 0xF7	; 247
 664:	88 bb       	out	0x18, r24	; 24
 666:	88 b3       	in	r24, 0x18	; 24
 668:	87 7f       	andi	r24, 0xF7	; 247
 66a:	88 bb       	out	0x18, r24	; 24
			
				// Set SCL back to analog input
				ADC_ADMUX_SET();
 66c:	83 e8       	ldi	r24, 0x83	; 131
 66e:	87 b9       	out	0x07, r24	; 7
			}
			
			// If we're discharging, update the battery voltage message
			if (sg_bDischargeActive)
 670:	80 91 76 00 	lds	r24, 0x0076	; 0x800076 <sg_bDischargeActive>
 674:	81 11       	cpse	r24, r1
			{
				// Set the upper bit to indicate we're actively discharging
				u16Voltage |= MSG_CELL_DISCHARGE_ACTIVE;
 676:	d0 68       	ori	r29, 0x80	; 128
			}
			
			// If this is set, it will originate (or propagate) a pattern
			if (EACTION_SEND_PATTERN == sg_eCellAction)
 678:	80 91 71 00 	lds	r24, 0x0071	; 0x800071 <sg_eCellAction>
 67c:	90 91 72 00 	lds	r25, 0x0072	; 0x800072 <sg_eCellAction+0x1>
 680:	02 97       	sbiw	r24, 0x02	; 2
 682:	69 f4       	brne	.+26     	; 0x69e <main+0x116>
			{
				sg_u16BatteryTemperature = PATTERN_TEMPERATURE;
 684:	82 e4       	ldi	r24, 0x42	; 66
 686:	98 e9       	ldi	r25, 0x98	; 152
 688:	90 93 7a 00 	sts	0x007A, r25	; 0x80007a <sg_u16BatteryTemperature+0x1>
 68c:	80 93 79 00 	sts	0x0079, r24	; 0x800079 <sg_u16BatteryTemperature>
				sg_u16BatteryVoltage = PATTERN_VOLTAGE;
 690:	8c ea       	ldi	r24, 0xAC	; 172
 692:	9f eb       	ldi	r25, 0xBF	; 191
 694:	90 93 7c 00 	sts	0x007C, r25	; 0x80007c <sg_u16BatteryVoltage+0x1>
 698:	80 93 7b 00 	sts	0x007B, r24	; 0x80007b <sg_u16BatteryVoltage>
 69c:	08 c0       	rjmp	.+16     	; 0x6ae <main+0x126>
			}
			else
			{
				// We're sending the actual reading
				sg_u16BatteryTemperature = u16Temperature;
 69e:	10 93 7a 00 	sts	0x007A, r17	; 0x80007a <sg_u16BatteryTemperature+0x1>
 6a2:	00 93 79 00 	sts	0x0079, r16	; 0x800079 <sg_u16BatteryTemperature>
				sg_u16BatteryVoltage = u16Voltage;
 6a6:	d0 93 7c 00 	sts	0x007C, r29	; 0x80007c <sg_u16BatteryVoltage+0x1>
 6aa:	c0 93 7b 00 	sts	0x007B, r28	; 0x80007b <sg_u16BatteryVoltage>
			}
		
			// If we're just initializing, go back to sleep. We only needed
			// the first pass to set the discharge/charge state
			// do a sample window for last cpu detection to account for any differences in arriving at this point between adjacent cpus due to I2C
			if (EACTION_INIT == sg_eCellAction)
 6ae:	80 91 71 00 	lds	r24, 0x0071	; 0x800071 <sg_eCellAction>
 6b2:	90 91 72 00 	lds	r25, 0x0072	; 0x800072 <sg_eCellAction+0x1>
 6b6:	03 97       	sbiw	r24, 0x03	; 3
 6b8:	d9 f4       	brne	.+54     	; 0x6f0 <main+0x168>
			{
				uint8_t sample_count = 10;  //number of times to sample UP_RX for last cpu detection
				sg_eCellAction = EACTION_NONE;
 6ba:	10 92 72 00 	sts	0x0072, r1	; 0x800072 <sg_eCellAction+0x1>
 6be:	10 92 71 00 	sts	0x0071, r1	; 0x800071 <sg_eCellAction>
			// If we're just initializing, go back to sleep. We only needed
			// the first pass to set the discharge/charge state
			// do a sample window for last cpu detection to account for any differences in arriving at this point between adjacent cpus due to I2C
			if (EACTION_INIT == sg_eCellAction)
			{
				uint8_t sample_count = 10;  //number of times to sample UP_RX for last cpu detection
 6c2:	8a e0       	ldi	r24, 0x0A	; 10
				sg_eCellAction = EACTION_NONE;
				
				// sample every 1ms
				while (sample_count--)
 6c4:	07 c0       	rjmp	.+14     	; 0x6d4 <main+0x14c>
				{
				// If at any point we see the pin asserted, we're NOT the last
					if (IS_PIN_CELL_UP_RX_ASSERTED())
 6c6:	b4 99       	sbic	0x16, 4	; 22
					{
						// Pin is asserted, we're NOT the last CPU
						sg_bCellCPULast = false;
 6c8:	10 92 75 00 	sts	0x0075, r1	; 0x800075 <sg_bCellCPULast>
					}
					Delay(1000);  //this also gives the cell below more time to detect us
 6cc:	88 ee       	ldi	r24, 0xE8	; 232
 6ce:	93 e0       	ldi	r25, 0x03	; 3
 6d0:	e3 de       	rcall	.-570    	; 0x498 <Delay>
			{
				uint8_t sample_count = 10;  //number of times to sample UP_RX for last cpu detection
				sg_eCellAction = EACTION_NONE;
				
				// sample every 1ms
				while (sample_count--)
 6d2:	8c 2f       	mov	r24, r28
 6d4:	cf ef       	ldi	r28, 0xFF	; 255
 6d6:	c8 0f       	add	r28, r24
 6d8:	81 11       	cpse	r24, r1
 6da:	f5 cf       	rjmp	.-22     	; 0x6c6 <main+0x13e>
					Delay(1000);  //this also gives the cell below more time to detect us
				}

				
				// If we're not the last cell CPU, turn on receive interrupts
				if (false == sg_bCellCPULast)
 6dc:	80 91 75 00 	lds	r24, 0x0075	; 0x800075 <sg_bCellCPULast>
 6e0:	81 11       	cpse	r24, r1
 6e2:	01 c0       	rjmp	.+2      	; 0x6e6 <main+0x15e>
				{
					// Initialize the UART for receive operation (from cell CPUs to module CPUs)
					vUARTInitReceive();
 6e4:	d2 de       	rcall	.-604    	; 0x48a <vUARTInitReceive>
					// interrupts.
				}
		
				
				// Initialize transmit communication for module->cell->cell... communication
				CELL_DN_TX_DEASSERT();				// end of last detect sample window for cell below
 6e6:	88 b3       	in	r24, 0x18	; 24
 6e8:	80 62       	ori	r24, 0x20	; 32
 6ea:	88 bb       	out	0x18, r24	; 24
				vUARTInitTransmit(); 
 6ec:	ca de       	rcall	.-620    	; 0x482 <vUARTInitTransmit>
 6ee:	06 c0       	rjmp	.+12     	; 0x6fc <main+0x174>
			}
			else
			{
				// We're doing a send of the data!
				sg_eCellAction = EACTION_INITIATE_TRANSMIT;
 6f0:	84 e0       	ldi	r24, 0x04	; 4
 6f2:	90 e0       	ldi	r25, 0x00	; 0
 6f4:	90 93 72 00 	sts	0x0072, r25	; 0x800072 <sg_eCellAction+0x1>
 6f8:	80 93 71 00 	sts	0x0071, r24	; 0x800071 <sg_eCellAction>
			}
		}
	
		if (EACTION_INITIATE_TRANSMIT == sg_eCellAction)
 6fc:	80 91 71 00 	lds	r24, 0x0071	; 0x800071 <sg_eCellAction>
 700:	90 91 72 00 	lds	r25, 0x0072	; 0x800072 <sg_eCellAction+0x1>
 704:	04 97       	sbiw	r24, 0x04	; 4
 706:	09 f0       	breq	.+2      	; 0x70a <main+0x182>
 708:	6f cf       	rjmp	.-290    	; 0x5e8 <main+0x60>
		{
			sg_eCellAction = EACTION_NONE;
 70a:	10 92 72 00 	sts	0x0072, r1	; 0x800072 <sg_eCellAction+0x1>
 70e:	10 92 71 00 	sts	0x0071, r1	; 0x800071 <sg_eCellAction>
			
			
			// If we're the last CPU, then we initiate transmit, otherwise we
			// don't do anything - we wait for the last CPU to start the message
			// transmission.
			if (true == sg_bCellCPULast)
 712:	80 91 75 00 	lds	r24, 0x0075	; 0x800075 <sg_bCellCPULast>
 716:	88 23       	and	r24, r24
 718:	09 f4       	brne	.+2      	; 0x71c <main+0x194>
 71a:	66 cf       	rjmp	.-308    	; 0x5e8 <main+0x60>
			{
				// While we're receiving something, don't transmit anything. In practice, this
				// should never loop, but during development, it might.
				while (vUARTIscell_dn_rxActive());
 71c:	a8 de       	rcall	.-688    	; 0x46e <vUARTIscell_dn_rxActive>
 71e:	81 11       	cpse	r24, r1
 720:	fd cf       	rjmp	.-6      	; 0x71c <main+0x194>
				
				// Start transmission. Note this routine stops and starts interrupts, too.
				vUARTStartcell_dn_tx(VUART_BIT_TICKS/2);
 722:	89 e1       	ldi	r24, 0x19	; 25
 724:	89 dd       	rcall	.-1262   	; 0x238 <vUARTStartcell_dn_tx>
 726:	60 cf       	rjmp	.-320    	; 0x5e8 <main+0x60>

00000728 <__vector_1>:
// NOTE: If you're getting unexpected AVR resets, uncomment these unused handlers to see
// if another interrupt is being taken that doesn't have a handler. AVR Defaults to jumping
// to 0 when not vector is programmed.

ISR(INT0_vect, ISR_BLOCK)
{
 728:	1f 92       	push	r1
 72a:	0f 92       	push	r0
 72c:	0f b6       	in	r0, 0x3f	; 63
 72e:	0f 92       	push	r0
 730:	11 24       	eor	r1, r1
 732:	ff cf       	rjmp	.-2      	; 0x732 <__vector_1+0xa>

00000734 <__vector_4>:
	while (1);
}

ISR(TIMER1_OVF_vect, ISR_BLOCK)
{
 734:	1f 92       	push	r1
 736:	0f 92       	push	r0
 738:	0f b6       	in	r0, 0x3f	; 63
 73a:	0f 92       	push	r0
 73c:	11 24       	eor	r1, r1
 73e:	ff cf       	rjmp	.-2      	; 0x73e <__vector_4+0xa>

00000740 <__vector_5>:
	while (1);
}

ISR(TIMER0_OVF_vect, ISR_BLOCK)
{
 740:	1f 92       	push	r1
 742:	0f 92       	push	r0
 744:	0f b6       	in	r0, 0x3f	; 63
 746:	0f 92       	push	r0
 748:	11 24       	eor	r1, r1
 74a:	ff cf       	rjmp	.-2      	; 0x74a <__vector_5+0xa>

0000074c <__vector_13>:
	while (1);
}

ISR(USI_START_vect, ISR_BLOCK)
{
 74c:	1f 92       	push	r1
 74e:	0f 92       	push	r0
 750:	0f b6       	in	r0, 0x3f	; 63
 752:	0f 92       	push	r0
 754:	11 24       	eor	r1, r1
 756:	ff cf       	rjmp	.-2      	; 0x756 <__vector_13+0xa>

00000758 <__vector_14>:
	while (1);
}

ISR(USI_OVF_vect, ISR_BLOCK)
{
 758:	1f 92       	push	r1
 75a:	0f 92       	push	r0
 75c:	0f b6       	in	r0, 0x3f	; 63
 75e:	0f 92       	push	r0
 760:	11 24       	eor	r1, r1
 762:	ff cf       	rjmp	.-2      	; 0x762 <__vector_14+0xa>

00000764 <__vector_6>:
	while (1);
}

ISR(EE_RDY_vect, ISR_BLOCK)
{
 764:	1f 92       	push	r1
 766:	0f 92       	push	r0
 768:	0f b6       	in	r0, 0x3f	; 63
 76a:	0f 92       	push	r0
 76c:	11 24       	eor	r1, r1
 76e:	ff cf       	rjmp	.-2      	; 0x76e <__vector_6+0xa>

00000770 <__vector_7>:
	while (1);
}

ISR(ANA_COMP_vect, ISR_BLOCK)
{
 770:	1f 92       	push	r1
 772:	0f 92       	push	r0
 774:	0f b6       	in	r0, 0x3f	; 63
 776:	0f 92       	push	r0
 778:	11 24       	eor	r1, r1
 77a:	ff cf       	rjmp	.-2      	; 0x77a <__vector_7+0xa>

0000077c <INT1_vect>:
	while (1);
}

ISR(INT1_vect, ISR_BLOCK)
{
 77c:	1f 92       	push	r1
 77e:	0f 92       	push	r0
 780:	0f b6       	in	r0, 0x3f	; 63
 782:	0f 92       	push	r0
 784:	11 24       	eor	r1, r1
 786:	ff cf       	rjmp	.-2      	; 0x786 <INT1_vect+0xa>

00000788 <TIMER0_CAPT_vect>:
	while (1);
}

ISR(TIMER0_CAPT_vect, ISR_BLOCK)
{
 788:	1f 92       	push	r1
 78a:	0f 92       	push	r0
 78c:	0f b6       	in	r0, 0x3f	; 63
 78e:	0f 92       	push	r0
 790:	11 24       	eor	r1, r1
 792:	ff cf       	rjmp	.-2      	; 0x792 <TIMER0_CAPT_vect+0xa>

00000794 <TIMER1_COMPD_vect>:
	while (1);
}

ISR(TIMER1_COMPD_vect, ISR_BLOCK)
{
 794:	1f 92       	push	r1
 796:	0f 92       	push	r0
 798:	0f b6       	in	r0, 0x3f	; 63
 79a:	0f 92       	push	r0
 79c:	11 24       	eor	r1, r1
 79e:	ff cf       	rjmp	.-2      	; 0x79e <TIMER1_COMPD_vect+0xa>

000007a0 <FAULT_PROTECTION_vect>:
	while (1);
}

ISR(FAULT_PROTECTION_vect, ISR_BLOCK)
{
 7a0:	1f 92       	push	r1
 7a2:	0f 92       	push	r0
 7a4:	0f b6       	in	r0, 0x3f	; 63
 7a6:	0f 92       	push	r0
 7a8:	11 24       	eor	r1, r1
 7aa:	ff cf       	rjmp	.-2      	; 0x7aa <FAULT_PROTECTION_vect+0xa>

Disassembly of section .text:

00000924 <MCP9843SetSensorRegister>:
// Sets the register pointer to the incoming value, ready for subsequent transactions.
// Routine returns true if the device acknowledged the transactions, otherwise false
// is returned.
static bool MCP9843SetSensorRegister(uint8_t u8Register,
									 bool bRead)
{
 924:	cf 93       	push	r28
 926:	c8 2f       	mov	r28, r24
	// Attempt to start a transaction
	if (false == I2CStartTransaction(MCP9843_SLAVE_ADDRESS_SENSOR,
 928:	80 e3       	ldi	r24, 0x30	; 48
 92a:	eb df       	rcall	.-42     	; 0x902 <I2CStartTransaction>
 92c:	88 23       	and	r24, r24
 92e:	11 f0       	breq	.+4      	; 0x934 <MCP9843SetSensorRegister+0x10>
	{
		return(false);
	}
	
	// Now write the register. Since we're the master, we're monitoring ACK from the slave.
	if (false == I2CTxByte(u8Register))
 930:	8c 2f       	mov	r24, r28
 932:	69 df       	rcall	.-302    	; 0x806 <I2CTxByte>
		// Not good.
		return(false);
	}
	
	return(true);
}
 934:	cf 91       	pop	r28
 936:	08 95       	ret

00000938 <MCP9843SetEventPin>:

// This sets the EVENT pin either high or low depending on the input signal. The 
// logic requires that the thresholds are NOT triggered, as it uses the 
bool MCP9843SetEventPin(bool bHigh)
{
 938:	1f 93       	push	r17
 93a:	cf 93       	push	r28
 93c:	df 93       	push	r29
 93e:	0f 92       	push	r0
 940:	cd b7       	in	r28, 0x3d	; 61
 942:	de b7       	in	r29, 0x3e	; 62
 944:	18 2f       	mov	r17, r24
#if defined(__AVR_ATtiny261A__)
	return(true);
#else
	bool bResult = false;
	volatile uint8_t u8ConfigByteLSB = MCP9843_CONFIG_DEFAULT_LSB;
 946:	8a e1       	ldi	r24, 0x1A	; 26
 948:	89 83       	std	Y+1, r24	; 0x01
	
	// Set up the output pins for I2C operation
	I2CSetup();
 94a:	c8 df       	rcall	.-112    	; 0x8dc <I2CSetup>
	
	// Write the configuration register
	if (false == MCP9843SetSensorRegister(MCP9843REG_CONFIG,
 94c:	60 e0       	ldi	r22, 0x00	; 0
 94e:	81 e0       	ldi	r24, 0x01	; 1
 950:	e9 df       	rcall	.-46     	; 0x924 <MCP9843SetSensorRegister>
 952:	88 23       	and	r24, r24
 954:	99 f0       	breq	.+38     	; 0x97c <MCP9843SetEventPin+0x44>
	{
		goto i2cFail;
	}
	
	// Config MSB
	if (false == I2CTxByte(MCP9843_CONFIG_DEFAULT_MSB))
 956:	80 e0       	ldi	r24, 0x00	; 0
 958:	56 df       	rcall	.-340    	; 0x806 <I2CTxByte>
 95a:	88 23       	and	r24, r24
 95c:	89 f0       	breq	.+34     	; 0x980 <MCP9843SetEventPin+0x48>
	{
		goto i2cFail;
	}
	
	if (bHigh)
 95e:	11 23       	and	r17, r17
 960:	21 f0       	breq	.+8      	; 0x96a <MCP9843SetEventPin+0x32>
	{
		u8ConfigByteLSB |= MCP9843REG_CONFIG_EV_POLARITY;
 962:	89 81       	ldd	r24, Y+1	; 0x01
 964:	82 60       	ori	r24, 0x02	; 2
 966:	89 83       	std	Y+1, r24	; 0x01
 968:	03 c0       	rjmp	.+6      	; 0x970 <MCP9843SetEventPin+0x38>
	}
	else
	{
		u8ConfigByteLSB &= (uint8_t) (~MCP9843REG_CONFIG_EV_POLARITY);
 96a:	89 81       	ldd	r24, Y+1	; 0x01
 96c:	8d 7f       	andi	r24, 0xFD	; 253
 96e:	89 83       	std	Y+1, r24	; 0x01
	}
	
	// Config LSB
	if (false == I2CTxByte(u8ConfigByteLSB))
 970:	89 81       	ldd	r24, Y+1	; 0x01
 972:	49 df       	rcall	.-366    	; 0x806 <I2CTxByte>
 974:	81 11       	cpse	r24, r1
 976:	06 c0       	rjmp	.+12     	; 0x984 <MCP9843SetEventPin+0x4c>
bool MCP9843SetEventPin(bool bHigh)
{
#if defined(__AVR_ATtiny261A__)
	return(true);
#else
	bool bResult = false;
 978:	10 e0       	ldi	r17, 0x00	; 0
 97a:	05 c0       	rjmp	.+10     	; 0x986 <MCP9843SetEventPin+0x4e>
 97c:	10 e0       	ldi	r17, 0x00	; 0
 97e:	03 c0       	rjmp	.+6      	; 0x986 <MCP9843SetEventPin+0x4e>
 980:	10 e0       	ldi	r17, 0x00	; 0
 982:	01 c0       	rjmp	.+2      	; 0x986 <MCP9843SetEventPin+0x4e>
	{
		goto i2cFail;
	}
	
	// Indicate we're OK
	bResult = true;
 984:	11 e0       	ldi	r17, 0x01	; 1
	
	// And a stop condition
i2cFail:
	I2CStop();
 986:	2e df       	rcall	.-420    	; 0x7e4 <I2CStop>
	
	return(bResult);
#endif
}
 988:	81 2f       	mov	r24, r17
 98a:	0f 90       	pop	r0
 98c:	df 91       	pop	r29
 98e:	cf 91       	pop	r28
 990:	1f 91       	pop	r17
 992:	08 95       	ret

00000994 <MCP9843ReadTemperature>:
// Bits 4-11 - Whole degrees C
// Bit 12    - Temperature sign bit - 0=Positive, 1=Negative
// Bits 13-14- Always 0
// Bit 15    - 1=Reading of temperature is valid, 0=Not valid
int16_t MCP9843ReadTemperature(void)
{
 994:	cf 93       	push	r28
 996:	df 93       	push	r29
#if defined(__AVR_ATtiny261A__)
	// Let's try 23.5 degrees
	s16Temperature = (23 << 4) | (0x08);
#else
	// Set up the output pins for I2C operation
	I2CSetup();
 998:	a1 df       	rcall	.-190    	; 0x8dc <I2CSetup>
	
	// Write the temperature register
	if (false == MCP9843SetSensorRegister(MCP9843REG_TEMP,
 99a:	60 e0       	ldi	r22, 0x00	; 0
 99c:	85 e0       	ldi	r24, 0x05	; 5
 99e:	c2 df       	rcall	.-124    	; 0x924 <MCP9843SetSensorRegister>
 9a0:	88 23       	and	r24, r24
 9a2:	a1 f0       	breq	.+40     	; 0x9cc <MCP9843ReadTemperature+0x38>
	{
		// Not valid
		return(0);											  
	}

	I2CStop();
 9a4:	1f df       	rcall	.-450    	; 0x7e4 <I2CStop>
	
	// Attempt to start a transaction
	if (false == I2CStartTransaction(MCP9843_SLAVE_ADDRESS_SENSOR,
 9a6:	61 e0       	ldi	r22, 0x01	; 1
 9a8:	80 e3       	ldi	r24, 0x30	; 48
 9aa:	ab df       	rcall	.-170    	; 0x902 <I2CStartTransaction>
 9ac:	88 23       	and	r24, r24
 9ae:	89 f0       	breq	.+34     	; 0x9d2 <MCP9843ReadTemperature+0x3e>
		// Not valid
		return(0);
	}
	
	// Now read MSB/LSB
	s16Temperature = I2CRxByte(true) << 8;
 9b0:	81 e0       	ldi	r24, 0x01	; 1
 9b2:	5b df       	rcall	.-330    	; 0x86a <I2CRxByte>
 9b4:	c8 2f       	mov	r28, r24
 9b6:	d0 e0       	ldi	r29, 0x00	; 0
 9b8:	dc 2f       	mov	r29, r28
 9ba:	cc 27       	eor	r28, r28
	s16Temperature |= I2CRxByte(false);
 9bc:	80 e0       	ldi	r24, 0x00	; 0
 9be:	55 df       	rcall	.-342    	; 0x86a <I2CRxByte>
 9c0:	c8 2b       	or	r28, r24
	
	// Now the stop condition
	I2CStop();
 9c2:	10 df       	rcall	.-480    	; 0x7e4 <I2CStop>

	// Mask off the tcrit/tupper/tlower bits - they aren't useful
#endif
	s16Temperature &= 0xfff;
 9c4:	ce 01       	movw	r24, r28
 9c6:	9f 70       	andi	r25, 0x0F	; 15
	s16Temperature |= MSG_CELL_TEMP_I2C_OK;
	
	return(s16Temperature);
 9c8:	90 68       	ori	r25, 0x80	; 128
 9ca:	05 c0       	rjmp	.+10     	; 0x9d6 <MCP9843ReadTemperature+0x42>
	// Write the temperature register
	if (false == MCP9843SetSensorRegister(MCP9843REG_TEMP,
										  false))
	{
		// Not valid
		return(0);											  
 9cc:	80 e0       	ldi	r24, 0x00	; 0
 9ce:	90 e0       	ldi	r25, 0x00	; 0
 9d0:	02 c0       	rjmp	.+4      	; 0x9d6 <MCP9843ReadTemperature+0x42>
	// Attempt to start a transaction
	if (false == I2CStartTransaction(MCP9843_SLAVE_ADDRESS_SENSOR,
									 true))
	{
		// Not valid
		return(0);
 9d2:	80 e0       	ldi	r24, 0x00	; 0
 9d4:	90 e0       	ldi	r25, 0x00	; 0
#endif
	s16Temperature &= 0xfff;
	s16Temperature |= MSG_CELL_TEMP_I2C_OK;
	
	return(s16Temperature);
}
 9d6:	df 91       	pop	r29
 9d8:	cf 91       	pop	r28
 9da:	08 95       	ret

Disassembly of section .text:

00000074 <__vector_2>:
static uint8_t sg_u8dn_txDataByte;
static bool sg_bdn_txMoreAvailable;

// Pin change interrupt - detecting start bit
ISR(PCINT_VECTOR, ISR_BLOCK)
{
  74:	1f 92       	push	r1
  76:	0f 92       	push	r0
  78:	0f b6       	in	r0, 0x3f	; 63
  7a:	0f 92       	push	r0
  7c:	11 24       	eor	r1, r1
  7e:	2f 93       	push	r18
  80:	3f 93       	push	r19
  82:	4f 93       	push	r20
  84:	5f 93       	push	r21
  86:	6f 93       	push	r22
  88:	7f 93       	push	r23
  8a:	8f 93       	push	r24
  8c:	9f 93       	push	r25
  8e:	af 93       	push	r26
  90:	bf 93       	push	r27
  92:	ef 93       	push	r30
  94:	ff 93       	push	r31
	bool bCellUpRXAsserted = IS_PIN_CELL_UP_RX_ASSERTED();
  96:	96 b3       	in	r25, 0x16	; 22
	bool bCellDnRxAsserted = IS_PIN_CELL_DN_RX_ASSERTED();
  98:	86 b3       	in	r24, 0x16	; 22
  9a:	82 70       	andi	r24, 0x02	; 2

	// If we have timers we need to start, start them at the top of the procedure	
	// so the sample times are tighter/more consistent
	if (bCellUpRXAsserted && sg_bcell_up_rx_Enabled &&
  9c:	94 ff       	sbrs	r25, 4
  9e:	27 c0       	rjmp	.+78     	; 0xee <__vector_2+0x7a>
  a0:	90 91 69 00 	lds	r25, 0x0069	; 0x800069 <sg_bcell_up_rx_Enabled>
  a4:	99 23       	and	r25, r25
  a6:	19 f1       	breq	.+70     	; 0xee <__vector_2+0x7a>
		((ESTATE_IDLE == sg_ecell_up_rxState) ||
  a8:	20 91 6b 00 	lds	r18, 0x006B	; 0x80006b <sg_ecell_up_rxState>
  ac:	30 91 6c 00 	lds	r19, 0x006C	; 0x80006c <sg_ecell_up_rxState+0x1>
	bool bCellUpRXAsserted = IS_PIN_CELL_UP_RX_ASSERTED();
	bool bCellDnRxAsserted = IS_PIN_CELL_DN_RX_ASSERTED();

	// If we have timers we need to start, start them at the top of the procedure	
	// so the sample times are tighter/more consistent
	if (bCellUpRXAsserted && sg_bcell_up_rx_Enabled &&
  b0:	23 2b       	or	r18, r19
  b2:	39 f0       	breq	.+14     	; 0xc2 <__vector_2+0x4e>
		((ESTATE_IDLE == sg_ecell_up_rxState) ||
		 (ESTATE_NEXT_BYTE == sg_ecell_up_rxState)))
  b4:	20 91 6b 00 	lds	r18, 0x006B	; 0x80006b <sg_ecell_up_rxState>
  b8:	30 91 6c 00 	lds	r19, 0x006C	; 0x80006c <sg_ecell_up_rxState+0x1>
	bool bCellDnRxAsserted = IS_PIN_CELL_DN_RX_ASSERTED();

	// If we have timers we need to start, start them at the top of the procedure	
	// so the sample times are tighter/more consistent
	if (bCellUpRXAsserted && sg_bcell_up_rx_Enabled &&
		((ESTATE_IDLE == sg_ecell_up_rxState) ||
  bc:	23 30       	cpi	r18, 0x03	; 3
  be:	31 05       	cpc	r19, r1
  c0:	b1 f4       	brne	.+44     	; 0xee <__vector_2+0x7a>
		 (ESTATE_NEXT_BYTE == sg_ecell_up_rxState)))
	{
		// This causes a sampling in the middle of the waveform
		// and accounts for code overhead.
		TIMER_CHA_INT(VUART_BIT_TICKS);
  c2:	92 b7       	in	r25, 0x32	; 50
  c4:	9e 5c       	subi	r25, 0xCE	; 206
  c6:	99 bd       	out	0x29, r25	; 41
  c8:	90 e1       	ldi	r25, 0x10	; 16
  ca:	98 bf       	out	0x38, r25	; 56
  cc:	99 b7       	in	r25, 0x39	; 57
  ce:	90 61       	ori	r25, 0x10	; 16
  d0:	99 bf       	out	0x39, r25	; 57

		// Stop cell_up_rx interrupts
		INT_CELL_UP_RX_DISABLE();
  d2:	95 b3       	in	r25, 0x15	; 21
  d4:	9f 7e       	andi	r25, 0xEF	; 239
  d6:	95 bb       	out	0x15, r25	; 21
		
		// We are now receiving data
		sg_ecell_up_rxState = ESTATE_RX_DATA;
  d8:	21 e0       	ldi	r18, 0x01	; 1
  da:	30 e0       	ldi	r19, 0x00	; 0
  dc:	30 93 6c 00 	sts	0x006C, r19	; 0x80006c <sg_ecell_up_rxState+0x1>
  e0:	20 93 6b 00 	sts	0x006B, r18	; 0x80006b <sg_ecell_up_rxState>
		sg_bcell_up_rxPriorState = true;
  e4:	91 e0       	ldi	r25, 0x01	; 1
  e6:	90 93 6d 00 	sts	0x006D, r25	; 0x80006d <sg_bcell_up_rxPriorState>
		sg_u8Cell_up_rxBitCount = 0;
  ea:	10 92 6e 00 	sts	0x006E, r1	; 0x80006e <sg_u8Cell_up_rxBitCount>
	}
	
	// Handle cell_dn_rx incomings
	if ((bCellDnRxAsserted) &&
  ee:	81 11       	cpse	r24, r1
  f0:	28 c0       	rjmp	.+80     	; 0x142 <__DATA_REGION_LENGTH__+0x42>
		((ESTATE_IDLE == sg_ecell_dn_rxState) ||
  f2:	80 91 65 00 	lds	r24, 0x0065	; 0x800065 <sg_ecell_dn_rxState>
  f6:	90 91 66 00 	lds	r25, 0x0066	; 0x800066 <sg_ecell_dn_rxState+0x1>
		sg_bcell_up_rxPriorState = true;
		sg_u8Cell_up_rxBitCount = 0;
	}
	
	// Handle cell_dn_rx incomings
	if ((bCellDnRxAsserted) &&
  fa:	89 2b       	or	r24, r25
  fc:	31 f0       	breq	.+12     	; 0x10a <__DATA_REGION_LENGTH__+0xa>
		((ESTATE_IDLE == sg_ecell_dn_rxState) ||
		 (ESTATE_NEXT_BYTE == sg_ecell_dn_rxState)))
  fe:	80 91 65 00 	lds	r24, 0x0065	; 0x800065 <sg_ecell_dn_rxState>
 102:	90 91 66 00 	lds	r25, 0x0066	; 0x800066 <sg_ecell_dn_rxState+0x1>
		sg_u8Cell_up_rxBitCount = 0;
	}
	
	// Handle cell_dn_rx incomings
	if ((bCellDnRxAsserted) &&
		((ESTATE_IDLE == sg_ecell_dn_rxState) ||
 106:	03 97       	sbiw	r24, 0x03	; 3
 108:	e1 f4       	brne	.+56     	; 0x142 <__DATA_REGION_LENGTH__+0x42>
		 (ESTATE_NEXT_BYTE == sg_ecell_dn_rxState)))
	{
		// This causes sampling closer to the middle of the waveform
		// and accounts for code overhead.
		TIMER_CHB_INT(VUART_BIT_TICKS + (VUART_BIT_TICKS / 10));
 10a:	82 b7       	in	r24, 0x32	; 50
 10c:	89 5c       	subi	r24, 0xC9	; 201
 10e:	88 bd       	out	0x28, r24	; 40
 110:	88 e0       	ldi	r24, 0x08	; 8
 112:	88 bf       	out	0x38, r24	; 56
 114:	89 b7       	in	r24, 0x39	; 57
 116:	88 60       	ori	r24, 0x08	; 8
 118:	89 bf       	out	0x39, r24	; 57

		// Stop cell_dn_rx interrupts
		INT_CELL_DN_RX_DISABLE();
 11a:	85 b3       	in	r24, 0x15	; 21
 11c:	8d 7f       	andi	r24, 0xFD	; 253
 11e:	85 bb       	out	0x15, r24	; 21
		
		// Only call the data start routine when it's the actual start of the initial
		// byte, not subsequent bytes.
		if (ESTATE_IDLE == sg_ecell_dn_rxState)
 120:	80 91 65 00 	lds	r24, 0x0065	; 0x800065 <sg_ecell_dn_rxState>
 124:	90 91 66 00 	lds	r25, 0x0066	; 0x800066 <sg_ecell_dn_rxState+0x1>
 128:	89 2b       	or	r24, r25
 12a:	09 f4       	brne	.+2      	; 0x12e <__DATA_REGION_LENGTH__+0x2e>
		{
			// Falling edge on cell_dn_rx
			Celldn_rxDataStart();
 12c:	f3 d1       	rcall	.+998    	; 0x514 <Celldn_rxDataStart>
		}
		
		// Set the RX data state
		sg_ecell_dn_rxState = ESTATE_RX_DATA;
 12e:	81 e0       	ldi	r24, 0x01	; 1
 130:	90 e0       	ldi	r25, 0x00	; 0
 132:	90 93 66 00 	sts	0x0066, r25	; 0x800066 <sg_ecell_dn_rxState+0x1>
 136:	80 93 65 00 	sts	0x0065, r24	; 0x800065 <sg_ecell_dn_rxState>
		sg_bcell_dn_rxPriorState = true;
 13a:	80 93 67 00 	sts	0x0067, r24	; 0x800067 <sg_bcell_dn_rxPriorState>
		sg_u8Cell_dn_rxBitCount = 0;
 13e:	10 92 68 00 	sts	0x0068, r1	; 0x800068 <sg_u8Cell_dn_rxBitCount>
	}
}
 142:	ff 91       	pop	r31
 144:	ef 91       	pop	r30
 146:	bf 91       	pop	r27
 148:	af 91       	pop	r26
 14a:	9f 91       	pop	r25
 14c:	8f 91       	pop	r24
 14e:	7f 91       	pop	r23
 150:	6f 91       	pop	r22
 152:	5f 91       	pop	r21
 154:	4f 91       	pop	r20
 156:	3f 91       	pop	r19
 158:	2f 91       	pop	r18
 15a:	0f 90       	pop	r0
 15c:	0f be       	out	0x3f, r0	; 63
 15e:	0f 90       	pop	r0
 160:	1f 90       	pop	r1
 162:	18 95       	reti

00000164 <__vector_11>:
	TIMER_CHA_INT_DISABLE();
}

// Timer 0 compare B interrupt (bit clock) for cell_dn_rx
ISR(TIMER_COMPB_VECTOR, ISR_BLOCK)
{
 164:	1f 92       	push	r1
 166:	0f 92       	push	r0
 168:	0f b6       	in	r0, 0x3f	; 63
 16a:	0f 92       	push	r0
 16c:	11 24       	eor	r1, r1
 16e:	2f 93       	push	r18
 170:	3f 93       	push	r19
 172:	4f 93       	push	r20
 174:	5f 93       	push	r21
 176:	6f 93       	push	r22
 178:	7f 93       	push	r23
 17a:	8f 93       	push	r24
 17c:	9f 93       	push	r25
 17e:	af 93       	push	r26
 180:	bf 93       	push	r27
 182:	ef 93       	push	r30
 184:	ff 93       	push	r31
	bool bData;
	
	TIMER_CHB_INT(VUART_BIT_TICKS-6);
 186:	82 b7       	in	r24, 0x32	; 50
 188:	84 5d       	subi	r24, 0xD4	; 212
 18a:	88 bd       	out	0x28, r24	; 40
 18c:	88 e0       	ldi	r24, 0x08	; 8
 18e:	88 bf       	out	0x38, r24	; 56
 190:	89 b7       	in	r24, 0x39	; 57
 192:	88 60       	ori	r24, 0x08	; 8
 194:	89 bf       	out	0x39, r24	; 57
		
	// Set the bit value for what the prior state was
	if (sg_bcell_dn_rxPriorState)
 196:	80 91 67 00 	lds	r24, 0x0067	; 0x800067 <sg_bcell_dn_rxPriorState>
 19a:	88 23       	and	r24, r24
 19c:	21 f0       	breq	.+8      	; 0x1a6 <__vector_11+0x42>
	{
		CELL_UP_TX_ASSERT();
 19e:	88 b3       	in	r24, 0x18	; 24
 1a0:	81 60       	ori	r24, 0x01	; 1
 1a2:	88 bb       	out	0x18, r24	; 24
 1a4:	03 c0       	rjmp	.+6      	; 0x1ac <__vector_11+0x48>
	}
	else
	{
		CELL_UP_TX_DEASSERT();
 1a6:	88 b3       	in	r24, 0x18	; 24
 1a8:	8e 7f       	andi	r24, 0xFE	; 254
 1aa:	88 bb       	out	0x18, r24	; 24
	}

	bData = sg_bcell_dn_rxPriorState;
 1ac:	80 91 67 00 	lds	r24, 0x0067	; 0x800067 <sg_bcell_dn_rxPriorState>
	sg_bcell_dn_rxPriorState = IS_PIN_CELL_DN_RX_ASSERTED();
 1b0:	26 b3       	in	r18, 0x16	; 22
 1b2:	26 95       	lsr	r18
 1b4:	91 e0       	ldi	r25, 0x01	; 1
 1b6:	29 27       	eor	r18, r25
 1b8:	21 70       	andi	r18, 0x01	; 1
 1ba:	20 93 67 00 	sts	0x0067, r18	; 0x800067 <sg_bcell_dn_rxPriorState>
	
	sg_u8Cell_dn_rxBitCount++;
 1be:	90 91 68 00 	lds	r25, 0x0068	; 0x800068 <sg_u8Cell_dn_rxBitCount>
 1c2:	9f 5f       	subi	r25, 0xFF	; 255
 1c4:	90 93 68 00 	sts	0x0068, r25	; 0x800068 <sg_u8Cell_dn_rxBitCount>
	
	// Handles cell_dn_rx
	if (1 == sg_u8Cell_dn_rxBitCount)
 1c8:	91 30       	cpi	r25, 0x01	; 1
 1ca:	29 f1       	breq	.+74     	; 0x216 <__vector_11+0xb2>
	{
		// Start bit
	}
	else
	if (sg_u8Cell_dn_rxBitCount < 10)
 1cc:	9a 30       	cpi	r25, 0x0A	; 10
 1ce:	10 f4       	brcc	.+4      	; 0x1d4 <__vector_11+0x70>
	{
		Celldn_rxDataBit(bData);
 1d0:	a8 d1       	rcall	.+848    	; 0x522 <Celldn_rxDataBit>
		return;
 1d2:	21 c0       	rjmp	.+66     	; 0x216 <__vector_11+0xb2>
	}
	else
	if (10 == sg_u8Cell_dn_rxBitCount)
 1d4:	9a 30       	cpi	r25, 0x0A	; 10
 1d6:	19 f4       	brne	.+6      	; 0x1de <__vector_11+0x7a>
	{
		// This is the more data vs. data stop bit
		sg_bCell_dn_rxMoreData = sg_bcell_dn_rxPriorState;
 1d8:	20 93 64 00 	sts	0x0064, r18	; 0x800064 <sg_bCell_dn_rxMoreData>
		return;
 1dc:	1c c0       	rjmp	.+56     	; 0x216 <__vector_11+0xb2>
	}
	else
	if (11 == sg_u8Cell_dn_rxBitCount)
 1de:	9b 30       	cpi	r25, 0x0B	; 11
 1e0:	19 f4       	brne	.+6      	; 0x1e8 <__vector_11+0x84>
	{
		// No longer asserted
		sg_bcell_dn_rxPriorState = false;
 1e2:	10 92 67 00 	sts	0x0067, r1	; 0x800067 <sg_bcell_dn_rxPriorState>
		return;
 1e6:	17 c0       	rjmp	.+46     	; 0x216 <__vector_11+0xb2>
	}
	else
	if (12 == sg_u8Cell_dn_rxBitCount)
 1e8:	9c 30       	cpi	r25, 0x0C	; 12
 1ea:	a9 f4       	brne	.+42     	; 0x216 <__vector_11+0xb2>
	{
		TIMER_CHB_INT_DISABLE();
 1ec:	89 b7       	in	r24, 0x39	; 57
 1ee:	87 7f       	andi	r24, 0xF7	; 247
 1f0:	89 bf       	out	0x39, r24	; 57
		
		// Enable cell_dn_rx for next byte
		INT_CELL_DN_RX_ENABLE();
 1f2:	85 b3       	in	r24, 0x15	; 21
 1f4:	82 60       	ori	r24, 0x02	; 2
 1f6:	85 bb       	out	0x15, r24	; 21
		
		if (false == sg_bCell_dn_rxMoreData)
 1f8:	80 91 64 00 	lds	r24, 0x0064	; 0x800064 <sg_bCell_dn_rxMoreData>
 1fc:	81 11       	cpse	r24, r1
 1fe:	05 c0       	rjmp	.+10     	; 0x20a <__vector_11+0xa6>
		{
			// Bus is now idle
			sg_ecell_dn_rxState = ESTATE_IDLE;
 200:	10 92 66 00 	sts	0x0066, r1	; 0x800066 <sg_ecell_dn_rxState+0x1>
 204:	10 92 65 00 	sts	0x0065, r1	; 0x800065 <sg_ecell_dn_rxState>
 208:	06 c0       	rjmp	.+12     	; 0x216 <__vector_11+0xb2>
		}
		else
		{
			// Flag that more data is coming
			sg_ecell_dn_rxState = ESTATE_NEXT_BYTE;
 20a:	83 e0       	ldi	r24, 0x03	; 3
 20c:	90 e0       	ldi	r25, 0x00	; 0
 20e:	90 93 66 00 	sts	0x0066, r25	; 0x800066 <sg_ecell_dn_rxState+0x1>
 212:	80 93 65 00 	sts	0x0065, r24	; 0x800065 <sg_ecell_dn_rxState>
		}

		return;
	}
}
 216:	ff 91       	pop	r31
 218:	ef 91       	pop	r30
 21a:	bf 91       	pop	r27
 21c:	af 91       	pop	r26
 21e:	9f 91       	pop	r25
 220:	8f 91       	pop	r24
 222:	7f 91       	pop	r23
 224:	6f 91       	pop	r22
 226:	5f 91       	pop	r21
 228:	4f 91       	pop	r20
 22a:	3f 91       	pop	r19
 22c:	2f 91       	pop	r18
 22e:	0f 90       	pop	r0
 230:	0f be       	out	0x3f, r0	; 63
 232:	0f 90       	pop	r0
 234:	1f 90       	pop	r1
 236:	18 95       	reti

00000238 <vUARTStartcell_dn_tx>:

// This starts a transmission on cell_dn_tx. true Is returned if it 
// was successfully started, but false if the cell_dn_tx vUART is active.
bool vUARTStartcell_dn_tx(uint8_t u8StartDelayTicks)
{
 238:	cf 93       	push	r28
	bool bReturnCode = false;

	// Is our cell_up_rx->cell_dn_tx path busy? If so, we can't start
	if (ESTATE_IDLE == sg_ecell_up_rxState)
 23a:	20 91 6b 00 	lds	r18, 0x006B	; 0x80006b <sg_ecell_up_rxState>
 23e:	30 91 6c 00 	lds	r19, 0x006C	; 0x80006c <sg_ecell_up_rxState+0x1>
 242:	23 2b       	or	r18, r19
 244:	01 f5       	brne	.+64     	; 0x286 <vUARTStartcell_dn_tx+0x4e>
 246:	c8 2f       	mov	r28, r24
	{
		// Shut off cell_up_rx interrupts coming from up stream so we don't hit a
		// spurious interrupt while we're transmitting
		INT_CELL_UP_RX_DISABLE();
 248:	85 b3       	in	r24, 0x15	; 21
 24a:	8f 7e       	andi	r24, 0xEF	; 239
 24c:	85 bb       	out	0x15, r24	; 21

		bReturnCode = true;
		
		// Set the state machine to transmit data.
		sg_ecell_up_rxState = ESTATE_TX_DATA;
 24e:	82 e0       	ldi	r24, 0x02	; 2
 250:	90 e0       	ldi	r25, 0x00	; 0
 252:	90 93 6c 00 	sts	0x006C, r25	; 0x80006c <sg_ecell_up_rxState+0x1>
 256:	80 93 6b 00 	sts	0x006B, r24	; 0x80006b <sg_ecell_up_rxState>

		// Ensure the first bit is a start bit		
		sg_bdn_txNextBit = true;
 25a:	81 e0       	ldi	r24, 0x01	; 1
 25c:	80 93 63 00 	sts	0x0063, r24	; 0x800063 <sg_bdn_txNextBit>

		// Let the consumer code know that a transmission is starting
		Celldn_txDataReset();
 260:	53 d1       	rcall	.+678    	; 0x508 <Celldn_txDataReset>
		
		// Seed any data to transmit
		sg_u8dn_txDataByte = Celldn_txDataGet();
 262:	31 d1       	rcall	.+610    	; 0x4c6 <Celldn_txDataGet>
 264:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <sg_u8dn_txDataByte>
		sg_bdn_txMoreAvailable = Celldn_txDataAvailable();
 268:	26 d1       	rcall	.+588    	; 0x4b6 <Celldn_txDataAvailable>
 26a:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>

		// Clear our dn_tx bit count
		sg_u8dn_txBitCount = 0;
 26e:	10 92 62 00 	sts	0x0062, r1	; 0x800062 <sg_u8dn_txBitCount>
		
		// Start up timer A to fire a half a bit later (if it's sloppy, that's OK)
		TIMER_CHA_INT(u8StartDelayTicks);		
 272:	82 b7       	in	r24, 0x32	; 50
 274:	8c 0f       	add	r24, r28
 276:	89 bd       	out	0x29, r24	; 41
 278:	80 e1       	ldi	r24, 0x10	; 16
 27a:	88 bf       	out	0x38, r24	; 56
 27c:	89 b7       	in	r24, 0x39	; 57
 27e:	80 61       	ori	r24, 0x10	; 16
 280:	89 bf       	out	0x39, r24	; 57
	{
		// Shut off cell_up_rx interrupts coming from up stream so we don't hit a
		// spurious interrupt while we're transmitting
		INT_CELL_UP_RX_DISABLE();

		bReturnCode = true;
 282:	81 e0       	ldi	r24, 0x01	; 1
 284:	01 c0       	rjmp	.+2      	; 0x288 <vUARTStartcell_dn_tx+0x50>

// This starts a transmission on cell_dn_tx. true Is returned if it 
// was successfully started, but false if the cell_dn_tx vUART is active.
bool vUARTStartcell_dn_tx(uint8_t u8StartDelayTicks)
{
	bool bReturnCode = false;
 286:	80 e0       	ldi	r24, 0x00	; 0
		// Start up timer A to fire a half a bit later (if it's sloppy, that's OK)
		TIMER_CHA_INT(u8StartDelayTicks);		
	}
	
	return(bReturnCode);
}
 288:	cf 91       	pop	r28
 28a:	08 95       	ret

0000028c <__vector_10>:
	}
}

// Timer 0 compare A interrupt (bit clock) for cell_up_rx
ISR(TIMER_COMPA_VECTOR, ISR_BLOCK)
{
 28c:	1f 92       	push	r1
 28e:	0f 92       	push	r0
 290:	0f b6       	in	r0, 0x3f	; 63
 292:	0f 92       	push	r0
 294:	11 24       	eor	r1, r1
 296:	2f 93       	push	r18
 298:	3f 93       	push	r19
 29a:	4f 93       	push	r20
 29c:	5f 93       	push	r21
 29e:	6f 93       	push	r22
 2a0:	7f 93       	push	r23
 2a2:	8f 93       	push	r24
 2a4:	9f 93       	push	r25
 2a6:	af 93       	push	r26
 2a8:	bf 93       	push	r27
 2aa:	ef 93       	push	r30
 2ac:	ff 93       	push	r31
	TIMER_CHA_INT(VUART_BIT_TICKS-6);
 2ae:	82 b7       	in	r24, 0x32	; 50
 2b0:	84 5d       	subi	r24, 0xD4	; 212
 2b2:	89 bd       	out	0x29, r24	; 41
 2b4:	80 e1       	ldi	r24, 0x10	; 16
 2b6:	88 bf       	out	0x38, r24	; 56
 2b8:	89 b7       	in	r24, 0x39	; 57
 2ba:	80 61       	ori	r24, 0x10	; 16
 2bc:	89 bf       	out	0x39, r24	; 57
	if (ESTATE_RX_DATA == sg_ecell_up_rxState)
 2be:	80 91 6b 00 	lds	r24, 0x006B	; 0x80006b <sg_ecell_up_rxState>
 2c2:	90 91 6c 00 	lds	r25, 0x006C	; 0x80006c <sg_ecell_up_rxState+0x1>
 2c6:	01 97       	sbiw	r24, 0x01	; 1
 2c8:	09 f0       	breq	.+2      	; 0x2cc <__vector_10+0x40>
 2ca:	40 c0       	rjmp	.+128    	; 0x34c <__vector_10+0xc0>
	{
		// Set the bit value for what the prior state was
		if (sg_bcell_up_rxPriorState)
 2cc:	80 91 6d 00 	lds	r24, 0x006D	; 0x80006d <sg_bcell_up_rxPriorState>
 2d0:	88 23       	and	r24, r24
 2d2:	21 f0       	breq	.+8      	; 0x2dc <__vector_10+0x50>
		{
			CELL_DN_TX_ASSERT();
 2d4:	88 b3       	in	r24, 0x18	; 24
 2d6:	8f 7d       	andi	r24, 0xDF	; 223
 2d8:	88 bb       	out	0x18, r24	; 24
 2da:	03 c0       	rjmp	.+6      	; 0x2e2 <__vector_10+0x56>
		}
		else
		{
			CELL_DN_TX_DEASSERT();
 2dc:	88 b3       	in	r24, 0x18	; 24
 2de:	80 62       	ori	r24, 0x20	; 32
 2e0:	88 bb       	out	0x18, r24	; 24
		}
		
		sg_bcell_up_rxPriorState = IS_PIN_CELL_UP_RX_ASSERTED();
 2e2:	96 b3       	in	r25, 0x16	; 22
 2e4:	92 95       	swap	r25
 2e6:	91 70       	andi	r25, 0x01	; 1
 2e8:	90 93 6d 00 	sts	0x006D, r25	; 0x80006d <sg_bcell_up_rxPriorState>
	
		sg_u8Cell_up_rxBitCount++;
 2ec:	80 91 6e 00 	lds	r24, 0x006E	; 0x80006e <sg_u8Cell_up_rxBitCount>
 2f0:	8f 5f       	subi	r24, 0xFF	; 255
 2f2:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <sg_u8Cell_up_rxBitCount>
		
		// Handles incoming start bit and data bits
		if (sg_u8Cell_up_rxBitCount < 9)
 2f6:	89 30       	cpi	r24, 0x09	; 9
 2f8:	08 f4       	brcc	.+2      	; 0x2fc <__vector_10+0x70>
 2fa:	89 c0       	rjmp	.+274    	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
		{
			// Data bits
			return;
		}
		else
		if (9 == sg_u8Cell_up_rxBitCount)
 2fc:	89 30       	cpi	r24, 0x09	; 9
 2fe:	31 f4       	brne	.+12     	; 0x30c <__vector_10+0x80>
		{
			// This is the more data vs. data stop bit
			sg_bCell_up_rxMoreData = sg_bcell_up_rxPriorState;
 300:	90 93 6a 00 	sts	0x006A, r25	; 0x80006a <sg_bCell_up_rxMoreData>
			
			// Always ensure that we're signaling more data since the termination
			// bit is done in the transmit phase
			sg_bcell_up_rxPriorState = true;
 304:	81 e0       	ldi	r24, 0x01	; 1
 306:	80 93 6d 00 	sts	0x006D, r24	; 0x80006d <sg_bcell_up_rxPriorState>
			return;
 30a:	81 c0       	rjmp	.+258    	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
		}
		else
		if (10 == sg_u8Cell_up_rxBitCount)
 30c:	8a 30       	cpi	r24, 0x0A	; 10
 30e:	19 f4       	brne	.+6      	; 0x316 <__vector_10+0x8a>
		{
			// Deassert the dn_tx signal (guard bit)
			sg_bcell_up_rxPriorState = false;
 310:	10 92 6d 00 	sts	0x006D, r1	; 0x80006d <sg_bcell_up_rxPriorState>
			return;
 314:	7c c0       	rjmp	.+248    	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
		}
		else
		if (11 == sg_u8Cell_up_rxBitCount)
 316:	8b 30       	cpi	r24, 0x0B	; 11
 318:	09 f0       	breq	.+2      	; 0x31c <__vector_10+0x90>
 31a:	79 c0       	rjmp	.+242    	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
		{
			// Only way to get here is if we have more data. We are now at the start of a start
			// cycle now and we can reenable interrupts on cell_up_rx so we wait for the
			// start of the next byte.
			TIMER_CHA_INT_DISABLE();
 31c:	89 b7       	in	r24, 0x39	; 57
 31e:	8f 7e       	andi	r24, 0xEF	; 239
 320:	89 bf       	out	0x39, r24	; 57
			
			// Enable cell_up_rx interrupts
			INT_CELL_UP_RX_ENABLE();
 322:	85 b3       	in	r24, 0x15	; 21
 324:	80 61       	ori	r24, 0x10	; 16
 326:	85 bb       	out	0x15, r24	; 21
				
			if (sg_bCell_up_rxMoreData)
 328:	80 91 6a 00 	lds	r24, 0x006A	; 0x80006a <sg_bCell_up_rxMoreData>
 32c:	88 23       	and	r24, r24
 32e:	39 f0       	breq	.+14     	; 0x33e <__vector_10+0xb2>
			{
				// Flag that more data is coming
				sg_ecell_up_rxState = ESTATE_NEXT_BYTE;
 330:	83 e0       	ldi	r24, 0x03	; 3
 332:	90 e0       	ldi	r25, 0x00	; 0
 334:	90 93 6c 00 	sts	0x006C, r25	; 0x80006c <sg_ecell_up_rxState+0x1>
 338:	80 93 6b 00 	sts	0x006B, r24	; 0x80006b <sg_ecell_up_rxState>
 33c:	68 c0       	rjmp	.+208    	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
			}
			else
			{
				// Bus is now idle		
				sg_ecell_up_rxState = ESTATE_IDLE;
 33e:	10 92 6c 00 	sts	0x006C, r1	; 0x80006c <sg_ecell_up_rxState+0x1>
 342:	10 92 6b 00 	sts	0x006B, r1	; 0x80006b <sg_ecell_up_rxState>
				
				// Start transmission of our data
				(void) vUARTStartcell_dn_tx(VUART_BIT_TICKS*3);
 346:	86 e9       	ldi	r24, 0x96	; 150
 348:	77 df       	rcall	.-274    	; 0x238 <vUARTStartcell_dn_tx>
 34a:	61 c0       	rjmp	.+194    	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
		
		return;
	} 
	
	// This handles the transmission of data when this CPU originates it
	if (ESTATE_TX_DATA == sg_ecell_up_rxState)
 34c:	80 91 6b 00 	lds	r24, 0x006B	; 0x80006b <sg_ecell_up_rxState>
 350:	90 91 6c 00 	lds	r25, 0x006C	; 0x80006c <sg_ecell_up_rxState+0x1>
 354:	02 97       	sbiw	r24, 0x02	; 2
 356:	09 f0       	breq	.+2      	; 0x35a <__vector_10+0xce>
 358:	57 c0       	rjmp	.+174    	; 0x408 <__LOCK_REGION_LENGTH__+0x8>
	{
		// Set the state of the output pin
		if (sg_bdn_txNextBit)
 35a:	80 91 63 00 	lds	r24, 0x0063	; 0x800063 <sg_bdn_txNextBit>
 35e:	88 23       	and	r24, r24
 360:	21 f0       	breq	.+8      	; 0x36a <__vector_10+0xde>
		{
			CELL_DN_TX_ASSERT();
 362:	88 b3       	in	r24, 0x18	; 24
 364:	8f 7d       	andi	r24, 0xDF	; 223
 366:	88 bb       	out	0x18, r24	; 24
 368:	03 c0       	rjmp	.+6      	; 0x370 <__vector_10+0xe4>
		}
		else
		{
			CELL_DN_TX_DEASSERT();
 36a:	88 b3       	in	r24, 0x18	; 24
 36c:	80 62       	ori	r24, 0x20	; 32
 36e:	88 bb       	out	0x18, r24	; 24
		}
		
		// Preincrement the bit count 
		sg_u8dn_txBitCount++;
 370:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <sg_u8dn_txBitCount>
 374:	8f 5f       	subi	r24, 0xFF	; 255
 376:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <sg_u8dn_txBitCount>

		// Transmit start condition and prepare data byte
		// If this is the first bit, fetch the byte
		if( sg_u8dn_txBitCount < 9 )
 37a:	89 30       	cpi	r24, 0x09	; 9
 37c:	70 f4       	brcc	.+28     	; 0x39a <__vector_10+0x10e>
		{
			// Transmit data! (msb first)
			if (sg_u8dn_txDataByte & 0x80)
 37e:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <sg_u8dn_txDataByte>
 382:	88 23       	and	r24, r24
 384:	24 f4       	brge	.+8      	; 0x38e <__vector_10+0x102>
			{
				sg_bdn_txNextBit = true;
 386:	91 e0       	ldi	r25, 0x01	; 1
 388:	90 93 63 00 	sts	0x0063, r25	; 0x800063 <sg_bdn_txNextBit>
 38c:	02 c0       	rjmp	.+4      	; 0x392 <__vector_10+0x106>
			}
			else
			{
				sg_bdn_txNextBit = false;
 38e:	10 92 63 00 	sts	0x0063, r1	; 0x800063 <sg_bdn_txNextBit>
			}
			
			sg_u8dn_txDataByte <<= 1;
 392:	88 0f       	add	r24, r24
 394:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <sg_u8dn_txDataByte>
			return;
 398:	3a c0       	rjmp	.+116    	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
		}
		// Transmit stop bit (stop or continue!)
		else 
		if (9 == sg_u8dn_txBitCount)
 39a:	89 30       	cpi	r24, 0x09	; 9
 39c:	29 f4       	brne	.+10     	; 0x3a8 <__vector_10+0x11c>
		{
			sg_bdn_txNextBit = sg_bdn_txMoreAvailable;
 39e:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 3a2:	80 93 63 00 	sts	0x0063, r24	; 0x800063 <sg_bdn_txNextBit>
			return;
 3a6:	33 c0       	rjmp	.+102    	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
		}
		else 
		if (10 == sg_u8dn_txBitCount)
 3a8:	8a 30       	cpi	r24, 0x0A	; 10
 3aa:	19 f4       	brne	.+6      	; 0x3b2 <__vector_10+0x126>
		{
			// Guard bit
			sg_bdn_txNextBit = false;
 3ac:	10 92 63 00 	sts	0x0063, r1	; 0x800063 <sg_bdn_txNextBit>
			return;
 3b0:	2e c0       	rjmp	.+92     	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
		}
		else
		if (11 == sg_u8dn_txBitCount)
 3b2:	8b 30       	cpi	r24, 0x0B	; 11
 3b4:	61 f5       	brne	.+88     	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
		{
			// Already deasserted here
			sg_u8dn_txBitCount = 0;
 3b6:	10 92 62 00 	sts	0x0062, r1	; 0x800062 <sg_u8dn_txBitCount>

			TIMER_CHA_INT_DISABLE();
 3ba:	89 b7       	in	r24, 0x39	; 57
 3bc:	8f 7e       	andi	r24, 0xEF	; 239
 3be:	89 bf       	out	0x39, r24	; 57
				
			// If more available, reset the bit count and exit
			if (false == sg_bdn_txMoreAvailable)
 3c0:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 3c4:	81 11       	cpse	r24, r1
 3c6:	0e c0       	rjmp	.+28     	; 0x3e4 <__vector_10+0x158>
			{
				sg_ecell_up_rxState = ESTATE_IDLE;
 3c8:	10 92 6c 00 	sts	0x006C, r1	; 0x80006c <sg_ecell_up_rxState+0x1>
 3cc:	10 92 6b 00 	sts	0x006B, r1	; 0x80006b <sg_ecell_up_rxState>

				// Terminate! stop the timer interrupts and reenable port pin interrupts
				CELL_DN_TX_DEASSERT();
 3d0:	88 b3       	in	r24, 0x18	; 24
 3d2:	80 62       	ori	r24, 0x20	; 32
 3d4:	88 bb       	out	0x18, r24	; 24
			
				// Allow reception of the cell_up_rx path again
				INT_CELL_UP_RX_ENABLE();
 3d6:	85 b3       	in	r24, 0x15	; 21
 3d8:	80 61       	ori	r24, 0x10	; 16
 3da:	85 bb       	out	0x15, r24	; 21
				
				// Bail out - don't continue to process anything since it's idle
				CELL_UP_TX_DEASSERT();
 3dc:	88 b3       	in	r24, 0x18	; 24
 3de:	8e 7f       	andi	r24, 0xFE	; 254
 3e0:	88 bb       	out	0x18, r24	; 24
				return;
 3e2:	15 c0       	rjmp	.+42     	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
			}
			else
			{
				// Set the timer 2 bits later - this can be sloppy since it's in between bytes
				TIMER_CHA_INT(VUART_BIT_TICKS*4);
 3e4:	82 b7       	in	r24, 0x32	; 50
 3e6:	88 53       	subi	r24, 0x38	; 56
 3e8:	89 bd       	out	0x29, r24	; 41
 3ea:	80 e1       	ldi	r24, 0x10	; 16
 3ec:	88 bf       	out	0x38, r24	; 56
 3ee:	89 b7       	in	r24, 0x39	; 57
 3f0:	80 61       	ori	r24, 0x10	; 16
 3f2:	89 bf       	out	0x39, r24	; 57

				// Get the next data byte and whether or not
				sg_u8dn_txDataByte = Celldn_txDataGet();
 3f4:	68 d0       	rcall	.+208    	; 0x4c6 <Celldn_txDataGet>
 3f6:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <sg_u8dn_txDataByte>
				sg_bdn_txMoreAvailable = Celldn_txDataAvailable();
 3fa:	5d d0       	rcall	.+186    	; 0x4b6 <Celldn_txDataAvailable>
 3fc:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
				sg_bdn_txNextBit = true;
 400:	81 e0       	ldi	r24, 0x01	; 1
 402:	80 93 63 00 	sts	0x0063, r24	; 0x800063 <sg_bdn_txNextBit>
 406:	03 c0       	rjmp	.+6      	; 0x40e <__LOCK_REGION_LENGTH__+0xe>

		return;
	}
	
	// Stop the timer - not necessary
	TIMER_CHA_INT_DISABLE();
 408:	89 b7       	in	r24, 0x39	; 57
 40a:	8f 7e       	andi	r24, 0xEF	; 239
 40c:	89 bf       	out	0x39, r24	; 57
}
 40e:	ff 91       	pop	r31
 410:	ef 91       	pop	r30
 412:	bf 91       	pop	r27
 414:	af 91       	pop	r26
 416:	9f 91       	pop	r25
 418:	8f 91       	pop	r24
 41a:	7f 91       	pop	r23
 41c:	6f 91       	pop	r22
 41e:	5f 91       	pop	r21
 420:	4f 91       	pop	r20
 422:	3f 91       	pop	r19
 424:	2f 91       	pop	r18
 426:	0f 90       	pop	r0
 428:	0f be       	out	0x3f, r0	; 63
 42a:	0f 90       	pop	r0
 42c:	1f 90       	pop	r1
 42e:	18 95       	reti

00000430 <vUARTPinInit>:
}

void vUARTPinInit(void)
{
	// Set up cell_dn_rx
	PIN_CELL_DN_RX_DDR &= ((uint8_t) ~(1 << PIN_CELL_DN_RX));	// Set as input
 430:	87 b3       	in	r24, 0x17	; 23
 432:	8d 7f       	andi	r24, 0xFD	; 253
 434:	87 bb       	out	0x17, r24	; 23
#if defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__)
	PIN_CELL_DN_RX_PORT &= ((uint8_t) ~(1 << PIN_CELL_DN_RX));	// Turn off pullup
 436:	88 b3       	in	r24, 0x18	; 24
 438:	8d 7f       	andi	r24, 0xFD	; 253
 43a:	88 bb       	out	0x18, r24	; 24
#else
#error No target processor defined or target processor type unknown
#endif
		
	// Set up cell_up_tx
	PIN_CELL_UP_TX_DDR |= (1 << PIN_CELL_UP_TX);	// Set as output
 43c:	87 b3       	in	r24, 0x17	; 23
 43e:	81 60       	ori	r24, 0x01	; 1
 440:	87 bb       	out	0x17, r24	; 23
#if defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__)
	PIN_CELL_UP_TX_PORT &= ((uint8_t) ~(1 << PIN_CELL_UP_TX));	// Turn off pullup
 442:	88 b3       	in	r24, 0x18	; 24
 444:	8e 7f       	andi	r24, 0xFE	; 254
 446:	88 bb       	out	0x18, r24	; 24
#elif defined(__AVR_ATtiny261A__)
	PIN_CELL_UP_TX_PORT |= ((uint8_t) (1 << PIN_CELL_UP_TX));	// Turn on pullup
#else
#error No target processor defined or target processor type unknown
#endif
	CELL_UP_TX_DEASSERT();							// Deassert cell_up_tx
 448:	88 b3       	in	r24, 0x18	; 24
 44a:	8e 7f       	andi	r24, 0xFE	; 254
 44c:	88 bb       	out	0x18, r24	; 24
	
	// Set up cell_up_rx
	PIN_CELL_UP_RX_DDR &= ((uint8_t) ~(1 << PIN_CELL_UP_RX));	// Set as input
 44e:	87 b3       	in	r24, 0x17	; 23
 450:	8f 7e       	andi	r24, 0xEF	; 239
 452:	87 bb       	out	0x17, r24	; 23
#if defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__)
	PIN_CELL_UP_RX_PORT &= ((uint8_t) ~(1 << PIN_CELL_UP_RX));	// Turn off pullup
 454:	88 b3       	in	r24, 0x18	; 24
 456:	8f 7e       	andi	r24, 0xEF	; 239
 458:	88 bb       	out	0x18, r24	; 24
#else
#error No target processor defined or target processor type unknown
#endif
	
	// Set up cell_dn_tx
	PIN_CELL_DN_TX_DDR |= (1 << PIN_CELL_DN_TX);	// Set as output
 45a:	87 b3       	in	r24, 0x17	; 23
 45c:	80 62       	ori	r24, 0x20	; 32
 45e:	87 bb       	out	0x17, r24	; 23
#if defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__)
	PIN_CELL_DN_TX_PORT &= ((uint8_t) ~(1 << PIN_CELL_DN_TX));	// Turn off pullup
 460:	88 b3       	in	r24, 0x18	; 24
 462:	8f 7d       	andi	r24, 0xDF	; 223
 464:	88 bb       	out	0x18, r24	; 24
	PIN_CELL_DN_TX_PORT |= ((uint8_t) (1 << PIN_CELL_DN_TX));	// Turn on pullup
#else
#error No target processor defined or target processor type unknown
#endif

	CELL_DN_TX_DEASSERT();							// Deassert cell_dn_tx
 466:	88 b3       	in	r24, 0x18	; 24
 468:	80 62       	ori	r24, 0x20	; 32
 46a:	88 bb       	out	0x18, r24	; 24
 46c:	08 95       	ret

0000046e <vUARTIscell_dn_rxActive>:
	PROFILER_INIT();
}

bool vUARTIscell_dn_rxActive(void)
{
	if (ESTATE_IDLE == sg_ecell_dn_rxState)
 46e:	80 91 65 00 	lds	r24, 0x0065	; 0x800065 <sg_ecell_dn_rxState>
 472:	90 91 66 00 	lds	r25, 0x0066	; 0x800066 <sg_ecell_dn_rxState+0x1>
 476:	89 2b       	or	r24, r25
 478:	11 f4       	brne	.+4      	; 0x47e <vUARTIscell_dn_rxActive+0x10>
	{
		return(false);
 47a:	80 e0       	ldi	r24, 0x00	; 0
 47c:	08 95       	ret
	}
	else
	{
		return(true);
 47e:	81 e0       	ldi	r24, 0x01	; 1
	}
}
 480:	08 95       	ret

00000482 <vUARTInitTransmit>:
{
	// Fire up the profiler (if available)
	PROFILER_INIT();

	// Cell_dn_rx to allow receives. We do not need cell_up_tx interrupts
	INT_CELL_DN_RX_ENABLE();
 482:	85 b3       	in	r24, 0x15	; 21
 484:	82 60       	ori	r24, 0x02	; 2
 486:	85 bb       	out	0x15, r24	; 21
 488:	08 95       	ret

0000048a <vUARTInitReceive>:
}

// Enables receive communication from cell CPUs to module CPU
void vUARTInitReceive(void)
{
	sg_bcell_up_rx_Enabled = true;
 48a:	81 e0       	ldi	r24, 0x01	; 1
 48c:	80 93 69 00 	sts	0x0069, r24	; 0x800069 <sg_bcell_up_rx_Enabled>
	
	// Set up receives in the cell_up_tx direction
	INT_CELL_UP_RX_ENABLE();
 490:	85 b3       	in	r24, 0x15	; 21
 492:	80 61       	ori	r24, 0x10	; 16
 494:	85 bb       	out	0x15, r24	; 21
 496:	08 95       	ret

Disassembly of section .text.__dummy_fini:

00000a10 <_fini>:
 a10:	08 95       	ret

Disassembly of section .text.__dummy_funcs_on_exit:

00000a12 <__funcs_on_exit>:
 a12:	08 95       	ret

Disassembly of section .text.__dummy_simulator_exit:

00000a14 <__simulator_exit>:
 a14:	08 95       	ret

Disassembly of section .text.exit:

00000a00 <exit>:
 a00:	ec 01       	movw	r28, r24
 a02:	07 d0       	rcall	.+14     	; 0xa12 <__funcs_on_exit>
 a04:	05 d0       	rcall	.+10     	; 0xa10 <_fini>
 a06:	ce 01       	movw	r24, r28
 a08:	05 d0       	rcall	.+10     	; 0xa14 <__simulator_exit>
 a0a:	ce 01       	movw	r24, r28
 a0c:	04 d0       	rcall	.+8      	; 0xa16 <_Exit>

Disassembly of section .text._Exit:

00000a16 <_Exit>:
 a16:	2c db       	rcall	.-2472   	; 0x70 <_exit>
