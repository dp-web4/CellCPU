/* CellCPU
 *
 * Cell controller firmware - ADC module header
 *
 * (C) Copyright 2023-2024 Modular Battery Technologies, Inc.
 * US Patents 11,380,942; 11,469,470; 11,575,270; others. All
 * rights reserved
 */

#ifndef _ADC_H_
#define _ADC_H_

extern uint16_t ADCRead(void);

#endif
/* CellCPU
 *
 * Cell controller firmware - bit bang I2C module header
 *
 * (C) Copyright 2023-2024 Modular Battery Technologies, Inc.
 * US Patents 11,380,942; 11,469,470; 11,575,270; others. All
 * rights reserved
 */

#ifndef I2C_H_
#define I2C_H_

extern void I2CSetup(void);
extern bool I2CTxByte(uint8_t u8Byte);
extern uint8_t I2CRxByte(bool bAck);
extern void I2CStart(void);
extern void I2CStop(void);
extern void I2CUnstick(void);
extern bool I2CStartTransaction(uint8_t u8SlaveAddress,
								bool bRead);

#endif
/* CellCPU
 *
 * Cell controller firmware - main module header
 *
 * (C) Copyright 2023-2024 Modular Battery Technologies, Inc.
 * US Patents 11,380,942; 11,469,470; 11,575,270; others. All
 * rights reserved
 */

#ifndef _MAIN_H_
#define _MAIN_H_

// CPU speed (in hz) - internal clock
#define CPU_SPEED						8000000

// Virtual UART timing - How many timer ticks is a single data/start/stop bit? This is the baud rate in ticks.
#define VUART_BIT_TICKS					50

// APIs to handle cell_up_rx->cell_dn_tx
extern bool Celldn_txDataAvailable(void);
extern uint8_t Celldn_txDataGet(void);
extern void Celldn_txDataReset(void);

// APIs to handle cell_dn_rx->cell_up_tx
extern void Celldn_rxDataStart(void);
extern void Celldn_rxDataBit(uint8_t u8DataBit);
extern void Celldn_rxDataEnd(void);

extern void Delay(uint16_t u16Ticks);

#endif
/* CellCPU
 *
 * Cell controller firmware - MCP9843 driver header
 *
 * (C) Copyright 2023-2024 Modular Battery Technologies, Inc.
 * US Patents 11,380,942; 11,469,470; 11,575,270; others. All
 * rights reserved
 */

#ifndef MPC9843_H_
#define MPC9843_H_

extern int16_t MCP9843ReadTemperature(void);
extern bool MCP9843SetEventPin(bool bHigh);

#endif
/* CellCPU
 *
 * Cell controller firmware - Platform specific definitions (mini-HAL)
 *
 * (C) Copyright 2023-2024 Modular Battery Technologies, Inc.
 * US Patents 11,380,942; 11,469,470; 11,575,270; others. All
 * rights reserved
 */

#ifndef _PLATFORM_H_
#define _PLATFORM_H_

// Common to all processors
#include <stdint.h>
#include <xc.h>
#include <stdbool.h>
#include <avr/io.h>
#include <avr/interrupt.h>

/*
 * Cell CPU definitions:
 *
 * PB0 - cell up tx
 * PB1 - cell dn rx
 * PB2 - I2C SDA
 * PB3 - I2C SDL/ADC1 (sense cell plus voltage through resistor divider)
 * PB4 - cell up rx
 * PB5 - cell dn tx (note: This has the net effect of inverting the signal between CPUs)
 *
 * Discharge is on the MPC9843T on the "event" pin. MCP9843T is at I2C addresses (A0-A2 are low):
 *
 * Temperature sensor		- 0x30
 * EEPROM					- 0xa0
 * EEPROM Write protect	-	- 0x60
 */

// Specific CPU defines

#if defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__)

// *************************************************************************************************
// ATTINY25/45 defines
// *************************************************************************************************

#define CPU_CLOCK_INIT()					CLKPR = (1 << CLKPCE); CLKPR = 0; PCMSK = 0; PRR = 0;
#define TIMER_INIT()						TCCR0A = 0; TCCR0B = (1 << CS01); TCNT0 = 0;	// /8 On main CPU
#define TIMER_COUNTER()						TCNT0
#define TIMER_OVF_VECTOR					TIM0_OVF_vect
#define PCINT_VECTOR						PCINT0_vect
#define TIMER_COMPA_VECTOR					TIM0_COMPA_vect
#define TIMER_COMPB_VECTOR					TIM0_COMPB_vect

// ADC Input related
#define ADC_ADMUX_SET()						ADMUX = (1 << MUX1) | (1 << MUX0) | (1 << REFS1)		// ADC3, internal 1.1V reference

#define	INT_ENABLE()						GIMSK = (1 << PCIE); MCUCR = (MCUCR & ~3) | (1 << ISC00);	// Set to logical pin change interrupt - ensure INT0 isn't active

#define PIN_CELL_DN_RX						PB1
#define PIN_CELL_DN_RX_PORT					PORTB
#define PIN_CELL_DN_RX_DDR					DDRB
#define PIN_CELL_DN_RX_PIN					PINB
#define PIN_CELL_DN_RX_INT					PCINT1

#define PIN_CELL_UP_TX						PB0
#define PIN_CELL_UP_TX_PORT					PORTB
#define	PIN_CELL_UP_TX_DDR					DDRB
#define	PIN_CELL_UP_TX_PIN					PINB

#define PIN_CELL_UP_RX						PB4
#define	PIN_CELL_UP_RX_PORT					PORTB
#define PIN_CELL_UP_RX_DDR					DDRB
#define PIN_CELL_UP_RX_PIN					PINB
#define PIN_CELL_UP_RX_INT					PCINT4

#define PIN_CELL_DN_TX						PB5
#define PIN_CELL_DN_TX_PORT					PORTB
#define PIN_CELL_DN_TX_DDR					DDRB
#define PIN_CELL_DN_TX_PIN					PINB

// CELL_UP_TX macros
#define CELL_UP_TX_ASSERT()					PIN_CELL_UP_TX_PORT |= ((uint8_t) (1 << PIN_CELL_UP_TX))
#define CELL_UP_TX_DEASSERT()				PIN_CELL_UP_TX_PORT &= ((uint8_t) ~(1 << PIN_CELL_UP_TX))

// CELL_DN_TX macros
#define CELL_DN_TX_ASSERT()					PIN_CELL_DN_TX_PORT &= ((uint8_t) ~(1 << PIN_CELL_DN_TX));
#define CELL_DN_TX_DEASSERT()				PIN_CELL_DN_TX_PORT |= ((uint8_t) (1 << PIN_CELL_DN_TX));

// Receive macros
#define	IS_PIN_CELL_DN_RX_ASSERTED()		(0 == IS_PIN_CELL_DN_RX_DEASSERTED())
#define IS_PIN_CELL_DN_RX_DEASSERTED()		((1 << PIN_CELL_DN_RX) & PIN_CELL_DN_RX_PIN)

#define IS_PIN_CELL_UP_RX_ASSERTED()		((1 << PIN_CELL_UP_RX) & PIN_CELL_UP_RX_PIN)
#define IS_PIN_CELL_UP_RX_DEASSERTED()		(0 == IS_PIN_CELL_UP_RX_ASSERTED())

// External interrupt enables
#define INT_CELL_DN_RX_ENABLE()				PCMSK |= (1 << PIN_CELL_DN_RX_INT)	// PCINT1
#define INT_CELL_DN_RX_DISABLE()			PCMSK &= (uint8_t) ~(1 << PIN_CELL_DN_RX_INT)

#define INT_CELL_UP_RX_ENABLE()				PCMSK |= (1 << PIN_CELL_UP_RX_INT)	// PCINT4
#define INT_CELL_UP_RX_DISABLE()			PCMSK &= (uint8_t) ~(1 << PIN_CELL_UP_RX_INT)

#define TIMER_CHA_INT(x)					OCR0A = (uint8_t) (TIMER_COUNTER() + (x)); TIMER_CHA_INT_CLEAR(); TIMSK |= (1 << OCIE0A)
#define TIMER_CHA_INT_CLEAR()				TIFR = (1 << OCF0A);
#define TIMER_CHB_INT(x)					OCR0B = (uint8_t) (TIMER_COUNTER() + (x)); TIMER_CHB_INT_CLEAR(); TIMSK |= (1 << OCIE0B)
#define TIMER_CHB_INT_CLEAR()				TIFR = (1 << OCF0B);
#define TIMER_CHA_INT_DISABLE()				TIMSK &= (uint8_t) ~(1 << OCIE0A)
#define TIMER_CHB_INT_DISABLE()				TIMSK &= (uint8_t) ~(1 << OCIE0B)

// Profiling bits (nothing on this CPU since there are no free pins for it)

#define PROFILER_INIT()
#define PROF_1_ASSERT()
#define PROF_1_DEASSERT()
#define PROF_2_ASSERT()
#define PROF_2_DEASSERT()

// I2C Port
#define I2C_PORT							PORTB
#define I2C_PORT_READ						PINB
#define I2C_PORT_DDR						DDRB

// I2C Pins on that port
#define I2C_SDA_PIN							PORTB2
#define I2C_SCL_PIN							PORTB3

// WDT Defines (for 1hz periodic timer callback)
#define WDT_INIT							(1 << WDE) | (1 << WDCE) | (1 << WDIE) | WDT_TIMEOUT;
#define	DISABLE_WDT()						WDTCR |= (1 << WDCE) | (1 << WDE); WDTCR = 0;
#define ENABLE_1HZ_WDT()					WDTCR |= (1 << WDIE); WDTCR = WDT_INIT;

#elif defined(__AVR_ATtiny261A__)

// *************************************************************************************************
// ATTINY261A defines - Used on the Beavis board
// *************************************************************************************************

// Internal 8Mhz clock 
#define CPU_CLOCK_INIT()					CLKPR = (1 << CLKPCE); CLKPR = 0; PRR = 0; PCMSK0 = 0; PCMSK1 = 0;
#define TIMER_INIT()						TCCR0A = 0; TCCR0B = (1 << CS01); TCNT0L = 0; TCNT0H = 0;  
#define TIMER_COUNTER()						TCNT0L
#define TIMER_OVF_VECTOR					TIMER0_OVF_vect
#define PCINT_VECTOR						PCINT_vect
#define TIMER_COMPA_VECTOR					TIMER0_COMPA_vect
#define TIMER_COMPB_VECTOR					TIMER0_COMPB_vect

// ADC Input related
#define ADC_ADMUX_SET()						ADMUX = 0		// ADC0, VCC reference

// Initializes the interrupt subsystem to receive pin change interrupts
// but does not enable interrupts on any specific pin
#define	INT_ENABLE()						GIMSK |= (1 << PCIE0) | (1 << PCIE1); MCUCR = (MCUCR & ~3) | (1 << ISC00);

#define PIN_CELL_DN_RX						PORTA6		// PA6/PCINT6
#define PIN_CELL_DN_RX_PORT					PORTA
#define PIN_CELL_DN_RX_DDR					DDRA
#define PIN_CELL_DN_RX_PIN					PINA

#define PIN_CELL_UP_TX						PORTA7		// PA7/ADC6/AIN1
#define PIN_CELL_UP_TX_PORT					PORTA
#define	PIN_CELL_UP_TX_DDR					DDRA
#define	PIN_CELL_UP_TX_PIN					PINA

#define PIN_CELL_UP_RX						PORTB4		// XTAL2/CLKO/ADC2/OC1B/PCINT4
#define	PIN_CELL_UP_RX_PORT					PORTB
#define PIN_CELL_UP_RX_DDR					DDRB
#define PIN_CELL_UP_RX_PIN					PINB

#define PIN_CELL_DN_TX						PORTB5		// RESET/dW/ADC0/PCINT5
#define PIN_CELL_DN_TX_PORT					PORTB
#define PIN_CELL_DN_TX_DDR					DDRB
#define PIN_CELL_DN_TX_PIN					PINB

// CELL_UP_TX macros
#define CELL_UP_TX_ASSERT()					PIN_CELL_UP_TX_PORT |= ((uint8_t) (1 << PIN_CELL_UP_TX))
#define CELL_UP_TX_DEASSERT()				PIN_CELL_UP_TX_PORT &= ((uint8_t) ~(1 << PIN_CELL_UP_TX))

// CELL_DN_TX macros
#define CELL_DN_TX_ASSERT()					PIN_CELL_DN_TX_PORT &= ((uint8_t) ~(1 << PIN_CELL_DN_TX));
#define CELL_DN_TX_DEASSERT()				PIN_CELL_DN_TX_PORT |= ((uint8_t) (1 << PIN_CELL_DN_TX));

// Receive macros
#define	IS_PIN_CELL_DN_RX_ASSERTED()		(0 == IS_PIN_CELL_DN_RX_DEASSERTED())
#define IS_PIN_CELL_DN_RX_DEASSERTED()		((1 << PIN_CELL_DN_RX) & PIN_CELL_DN_RX_PIN)

#define IS_PIN_CELL_UP_RX_ASSERTED()		((1 << PIN_CELL_UP_RX) & PIN_CELL_UP_RX_PIN)
#define IS_PIN_CELL_UP_RX_DEASSERTED()		(0 == IS_PIN_CELL_UP_RX_ASSERTED())

// External interrupt enables
#define INT_CELL_DN_RX_ENABLE()				PCMSK0 |= (1 << PIN_CELL_DN_RX)	// PCINT6
#define INT_CELL_DN_RX_DISABLE()			PCMSK0 &= (uint8_t) ~(1 << PIN_CELL_DN_RX)

#define INT_CELL_UP_RX_ENABLE()				PCMSK1 |= (1 << PIN_CELL_UP_RX) // PCINT12
#define INT_CELL_UP_RX_DISABLE()			PCMSK1 &= (uint8_t) ~(1 << PIN_CELL_UP_RX)

#define TIMER_CHA_INT(x)					OCR0A = (uint8_t) (TIMER_COUNTER() + (x)); TIMER_CHA_INT_CLEAR(); TIMSK |= (1 << OCIE0A)
#define TIMER_CHA_INT_CLEAR()				TIFR = (1 << OCF0A);
#define TIMER_CHB_INT(x)					OCR0B = (uint8_t) (TIMER_COUNTER() + (x)); TIMER_CHB_INT_CLEAR(); TIMSK |= (1 << OCIE0B)
#define TIMER_CHB_INT_CLEAR()				TIFR = (1 << OCF0B);
#define TIMER_CHA_INT_DISABLE()				TIMSK &= (uint8_t) ~(1 << OCIE0A)
#define TIMER_CHB_INT_DISABLE()				TIMSK &= (uint8_t) ~(1 << OCIE0B)

// Profiling bits

//#define PROFILER_INIT()					DDRA |= (1 << PORTA1) | (1 << PORTA2); PORTA |=(1 << PORTA1) | (1 << PORTA2);
//#define PROF_1_ASSERT()					PORTA |= (1 << PORTA1)
//#define PROF_1_DEASSERT()					PORTA &= (uint8_t) ~(1 << PORTA1)
//#define PROF_2_ASSERT()					PORTA |= (1 << PORTA2)
//#define PROF_2_DEASSERT()					PORTA &= (uint8_t) ~(1 << PORTA2)

#define PROFILER_INIT()
#define PROF_1_ASSERT()
#define PROF_1_DEASSERT()
#define PROF_2_ASSERT()
#define PROF_2_DEASSERT()

// I2C Port
#define I2C_PORT							PORTB
#define I2C_PORT_READ						PINB
#define I2C_PORT_DDR						DDRB

// I2C Pins on that port
#define I2C_SDA_PIN							PORTB6
#define I2C_SCL_PIN							PORTB3

// WDT Defines (for 1hz periodic timer callback)
#define WDT_INIT							(1 << WDE) | (1 << WDCE) | (1 << WDIE) | WDT_TIMEOUT;
#define	DISABLE_WDT()						WDTCR |= (1 << WDCE) | (1 << WDE); WDTCR = 0;
#define ENABLE_1HZ_WDT()					WDTCR |= (1 << WDIE); WDTCR = WDT_INIT;

#else
#error No target processor defined or target processor type unknown
#endif

// Macros for controlling/reading the I2C data lines
#define SCL_LOW()				(I2C_PORT &= (uint8_t) ~(1 << I2C_SCL_PIN))				// Logic 0
#define SCL_HIGH()				(I2C_PORT |= (uint8_t) (1 << I2C_SCL_PIN))				// Logic 1
#define	SCL_READ()				((I2C_PORT_READ & (1 << I2C_SCL_PIN)) ? true : false)
#define SCL_SET_OUTPUT()		(I2C_PORT_DDR |= (1 << I2C_SCL_PIN))
#define	SCL_SET_INPUT()			(I2C_PORT_DDR &= (uint8_t) ~(1 << I2C_SCL_PIN)); I2C_PORT &= (uint8_t) ~(1 << I2C_SCL_PIN)
#define SDA_LOW()				(I2C_PORT &= (uint8_t) ~(1 << I2C_SDA_PIN))				// Logic 0
#define SDA_HIGH()				(I2C_PORT |= (uint8_t) (1 << I2C_SDA_PIN))				// Logic 1
#define	SDA_READ()				((I2C_PORT_READ & (1 << I2C_SDA_PIN)) ? true : false)
#define SDA_SET_OUTPUT()		(I2C_PORT_DDR |= (1 << I2C_SDA_PIN));
#define SDA_SET_INPUT()			(I2C_PORT_DDR &= ((uint8_t) ~(1 << I2C_SDA_PIN))); SDA_HIGH()
#define SCL_DISABLE()			SCL_SET_INPUT(); SCL_LOW()


#endif/* CellCPU
 *
 * Cell controller firmware - Virtual UART module
 *
 * (C) Copyright 2023-2024 Modular Battery Technologies, Inc.
 * US Patents 11,380,942; 11,469,470; 11,575,270; others. All
 * rights reserved
 **/

#ifndef _VUART_H_
#define _VUART_H_

extern bool vUARTStartcell_dn_tx(uint8_t u8StartDelayTicks);
extern void vUARTPinInit(void);
extern void vUARTInitTransmit(void);
extern void vUARTInitReceive(void);
extern bool vUARTIscell_dn_rxActive(void);

#endif
/* CellCPU
 *
 * Cell controller firmware - ADC module
 *
 * (C) Copyright 2023-2024 Modular Battery Technologies, Inc.
 * US Patents 11,380,942; 11,469,470; 11,575,270; others. All
 * rights reserved
 */

#include <stdint.h>
#include <xc.h>
#include <stdbool.h>
#include <avr/io.h>
#include <avr/interrupt.h>
#include "adc.h"
#include "main.h"
#include "platform.h"

// Configures PB3 as an analog input and converts/samples it
uint16_t ADCRead(void)
{
	uint16_t u16Reading;
	
    // Set the prescaler to clock/2 & enable ADC
    ADCSRA |= (1 << ADPS0) | (1 << ADEN);

	// Minor delay so we get a reasonable value
	Delay(20);
    
    // Read the ADC in order to get a 10 bit reading of where it is.
    // Start the conversion
    ADCSRA |= (1 << ADSC);

    // Wait for it to finish - blocking
    while (ADCSRA & (1 << ADSC));
	
	// Get the actual reading
	u16Reading = ADC;
	
	// Power down the ADC
	ADCSRA &= ~(1 << ADEN);
    
    return(u16Reading);
}
/* CellCPU
 *
 * Cell controller firmware - fuses
 *
 * (C) Copyright 2023-2024 Modular Battery Technologies, Inc.
 * US Patents 11,380,942; 11,469,470; 11,575,270; others. All
 * rights reserved
 */

#include <avr/io.h>

// Fuse calculations were made by using this web site. There are others out there, too,
// providing the same functionality:
//
// https://www.engbedded.com/fusecalc/
//
// In all definitions below, anything that's mentioned is considered to be SET (0). 
// Anything that is not mentioned should tbe considered NOT set (1). The low/high/extended
// fuse values come directly from the site above with the functionality set as documented in
// each CPU section.

#if defined(__AVR_ATtiny13A__)

// *************************************************************************************************
// ATTINY13 fuses
// *************************************************************************************************

// 9.6Mhz, startup time 14 CK + 0 ms (CKSEL=10 SUT=00)
// Brown out level at VCC=1.8V
// Reset disabled (RSTDISBL)
//
// NOTE: Once you program this, YOU WILL NOT BE ABLE TO PROGRAM IT AGAIN unless you use a high
// voltage (12V) capable AVR programmer.

FUSES =
{
	.low=0xf2,
	.high=0xfc
};

#elif defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__)

// *************************************************************************************************
// ATTINY25/45 fuses
// *************************************************************************************************

// 8Mhz, startup time 6CK/14CK + 0ms (CKSEL=0010 SUT=00)
// Brown out level at VCC=1.8V
// Reset disabled (RSTDISBL)
//
// NOTE: Once you program this, YOU WILL NOT BE ABLE TO PROGRAM IT AGAIN unless you use a high 
// voltage (12V) capable AVR programmer.

FUSES =
{
	.low=0xe2,
	.high=0x7f,
	.extended=0xff
};

#elif defined(__AVR_ATtiny261A__)

// *************************************************************************************************
// ATTINY261A fuses
// *************************************************************************************************

// 8Mhz, startup time 6CK/14CK + 0ms (CKSEL=0010 SUT=00)
// Brown out level at VCC=1.8V
// SPI Downloading enabled
// DebugWire enabled
// ** DO NOT DISABLE RESET, SPI, NOR DEBUGWIRE - IT IS NOT NECESSARY ON BEAVIS **

FUSES =
{
// Disables SPI/debugWire
	.low=0xc2,
	.high=0xfe,
	.extended=0xff
	
// Doesn't disable SPI/debugWire
//	.low=0xe2,
//	.high=0x9f,
//	.extended=0xff
};

#else
#error No target processor defined or target processor type unknown
#endif

/* CellCPU
 *
 * Cell controller firmware - bit bang I2C module
 *
 * (C) Copyright 2023-2024 Modular Battery Technologies, Inc.
 * US Patents 11,380,942; 11,469,470; 11,575,270; others. All
 * rights reserved
 */

#include <stdint.h>
#include <xc.h>
#include <stdbool.h>
#include <avr/io.h>
#include <avr/interrupt.h>
#include "i2c.h"
#include "main.h"
#include "Platform.h"

// Delays for one I2C bit's worth of time
static void I2CBitDelay(void)
{
	Delay(5);
}

// Causes the code to become synchronized with 
static void I2CQuantizeTiming(void)
{
	Delay(1);
}

// Send an I2C start sequence and quantize foreground code to the overflow
// timer
void I2CStart(void)
{
	I2CQuantizeTiming();

	SDA_SET_OUTPUT();
	SDA_HIGH();
	SCL_HIGH();
	I2CBitDelay();
	SDA_LOW();
	I2CBitDelay();
	SCL_LOW();
	I2CBitDelay();
}

// Send an I2C stop sequence
void I2CStop(void)
{
	I2CQuantizeTiming();

	SDA_LOW();
	I2CBitDelay();
	SCL_HIGH();
	I2CBitDelay();
	SDA_SET_INPUT();
	I2CBitDelay();
}

// Sends a single I2C byte. Returns false if the byte is not acked, or true if it is.
bool I2CTxByte(uint8_t u8Byte)
{
	uint8_t u8Length = 8;			// 8 Bits to send
	bool bAck = false;

	I2CQuantizeTiming();
	SDA_SET_OUTPUT();

	while (u8Length)
	{
		if (u8Byte & 0x80)
		{
			SDA_HIGH();
		}
		else
		{
			SDA_LOW();
		}
		
		// Drive SCL high
		SCL_HIGH();
		
		I2CBitDelay();
		
		// Ensure SCL is low
		SCL_LOW();
	
		// SDA Is now set. Delay.
		I2CBitDelay();
		
		// Next bit
		u8Byte <<= 1;	
		u8Length--;
	}
	
	SDA_SET_INPUT();
	SCL_HIGH();
	I2CBitDelay();
	
	// See if the byte was acknowledged
	if (SDA_READ())
	{
		bAck = false;
	}
	else
	{
		bAck = true;
	}
	
	SCL_LOW();
	I2CBitDelay();
	return(bAck);
}

// Receives a single I2C byte and will optionally generate an ack at the end
uint8_t I2CRxByte(bool bAck)
{
	uint8_t u8Data = 0;
	uint8_t u8Count = 8;
	
	I2CQuantizeTiming();

	SDA_SET_INPUT();
	
	// Consume all 8 data bits
	while (u8Count)
	{
		u8Data <<= 1;

		SCL_HIGH();
		I2CBitDelay();
			
		if (SDA_READ())
		{
			u8Data |= 1;
		}
		
		SCL_LOW();
		I2CBitDelay();
		u8Count--;
	}

	// See if we acknowledge this
	SDA_SET_OUTPUT();
	if (bAck)
	{
		SDA_LOW();
	}
	else
	{
		SDA_HIGH();
	}
	
	I2CBitDelay();
	SCL_HIGH();
	I2CBitDelay();
	SCL_LOW();
	I2CBitDelay();
	SDA_LOW();

	return(u8Data);	
}

// Prepares the SCL/SDA pins for I2C operation and returns when the CPU is
// quantized to the timer (for consistent bit alignment)
void I2CSetup(void)
{
	// Deassert SCL and SDA
	SCL_HIGH();
	SDA_HIGH();

	// Set SCL and SDA lines as push/pull output drives
	SCL_SET_OUTPUT();
	
	// Turn on SDA, set as an input
	SDA_SET_INPUT();
	
	Delay(20);
}

// Sets up the I2C pins, sends slave address/read/write byte, and waits for acknowledgment.
// Returns false if no device is responding.
bool I2CStartTransaction(uint8_t u8SlaveAddress,
						 bool bRead)
{
	// Set up the pins for I2C operation
	I2CSetup();
	
	// I2C Start condition
	I2CStart();

	// If it's a read operation, clear the lower bit
	if (bRead)
	{
		u8SlaveAddress |= 1;
	}
	else
	{
		// Otherwise set it
		u8SlaveAddress &= (uint8_t) (~1);
	}
	
	// Now send out the slave address + the read/write bit
	return(I2CTxByte(u8SlaveAddress));
}


/* CellCPU
 *
 * Cell controller firmware - main module
 *
 * (C) Copyright 2023-2024 Modular Battery Technologies, Inc.
 * US Patents 11,380,942; 11,469,470; 11,575,270; others. All
 * rights reserved
 */

#include "Platform.h"
#include "I2c.h"
#include "mcp9843.h"
#include "adc.h"
#include "main.h"
#include "vUART.h"
#include "../Shared/Shared.h"
#include <avr/sleep.h>
#include <avr/wdt.h>

// Most recent ADC (battery voltage) reading
static uint16_t sg_u16BatteryVoltage;							// Latest battery voltage reading

// Most recent temperature reading
static volatile uint16_t sg_u16BatteryTemperature;				// Latest battery temperature reading

// Target voltage. If sg_u16BatteryVoltage is higher than sg_u16BatterVoltageTarget, 
// turn on the discharge resistor
static volatile uint16_t sg_u16BatteryVoltageTarget;			// Target battery voltage (most recently received)

// Set true if the battery is currently being discharged
static volatile bool sg_bDischargeActive;

// Set true if this is the last cell CPU in the chain. If set true,
// this cell CPU will initiate transmission.
static volatile bool sg_bCellCPULast;

// This is the 16 bit quantity we get from the module controller - raw
static uint16_t sg_u16BatteryVoltageMsg;


// What state are we in?
typedef enum
{
	EACTION_NONE,
	EACTION_SEND_SENSOR_READING,
	EACTION_SEND_PATTERN,
	EACTION_INIT,
	EACTION_INITIATE_TRANSMIT
} ECellAction;

// Cell action - used by ISR to signal foreground wakeup
static ECellAction sg_eCellAction;

// Delay for at least u16Ticks timer B overflow ticks. If u16Ticks is 0, it will quantize to the
// next timer tick change.
void Delay(uint16_t u16Ticks)
{
	uint8_t u8Sample;
	
	u16Ticks++;
	
	u8Sample = TIMER_COUNTER();
	while (u16Ticks)
	{
		// Wait until we quantize
		while (u8Sample == TIMER_COUNTER());
		
		u8Sample = TIMER_COUNTER();
		--u16Ticks;
	}
}

// *************************************************************************
// cell_up_rx->cell_dn_tx handlers. This is data received from upstream cell
// CPUs and is retransmitted to other cell CPUs or to a module controller.
// *************************************************************************

// For our existing message, we will transmit 4 bytes:
//
// 0 - LSB Voltage
// 1 - MSB Voltage	(bit 7: 1=Discharge active, 0=Discharge inactive)
// 2 - LSB Temperature
// 3 - MSB Temperature (bit 7: 1=Valid I2C reading, 0=I2C communication error)

static uint8_t sg_u8TransmitOffset;

// Returns true if cell data is available. See message above for the meaning of >=4
bool Celldn_txDataAvailable(void)
{
	// We signal no more data available at the 4th byte (offset 3)
	// but still need to transmit the final byte.
	if (sg_u8TransmitOffset >= 4)
	{
		return(false);
	}
	
	return(true);
}

// Returns the next byte of cell data we want to transmit to the next cell, etc... module controller
uint8_t Celldn_txDataGet(void)
{
	uint8_t u8Data = 0xff;
	
	if (0 == sg_u8TransmitOffset)
	{
		// 0 - LSB Voltage
		u8Data = (uint8_t) sg_u16BatteryVoltage;
	}
	else
	if (1 == sg_u8TransmitOffset)
	{
		// 1 - MSB Voltage
		u8Data = (uint8_t) (sg_u16BatteryVoltage >> 8);
	}
	else
	if (2 == sg_u8TransmitOffset)
	{
		// 2 - LSB Temperature
		u8Data = (uint8_t) sg_u16BatteryTemperature;
	}
	else
	if (3 == sg_u8TransmitOffset)
	{
		// 3 - MSB Temperature
		u8Data = (uint8_t) (sg_u16BatteryTemperature >> 8);
	}
	
	sg_u8TransmitOffset++;
	return(u8Data);
}

// Resets the cell data state machine if necessary. This is called upon the falling
// edge of the start of a receive stream.
void Celldn_txDataReset(void)
{
	// Offset back to 0
	sg_u8TransmitOffset = 0;
}

// Battery target receive globals
static uint8_t sg_u8dn_rxBitCount = 0;

// Called right before data is transmitted/appended
void Celldn_txTransmitStart(void)
{
	// Sending the 0th byte
	sg_u8TransmitOffset = 0;
}

// *************************************************************************
// cell_dn_rx->cell_up_tx handlers. Received from module controller or cell
// CPU and transmitted to other cells.
// *************************************************************************

// Incoming message from the module controller:
//
// 0 - MSB Of voltage target
// 1 - LSB Of voltage target
//
// The cell_dn_rx->cell_up_tx path must do MSB first because it relies on
// getting the top two bits of the 16 bit quantity to indicate the command
// type.

// Called when start of message from module controller or upstream is started
void Celldn_rxDataStart(void)
{
	sg_u8dn_rxBitCount = 0;
	sg_u16BatteryVoltageMsg = 0;
}

// All messages from the module controller are 16 bit message. The top bit
// indicates if it's a setting of a voltage target or if it's a reading
// request. Bit 14 indicates the type of reading. Look in main.h for
// MSG_CELL_SEND_REPORT, MSG_CELL_SEND_PATTERN, and MSG_CELL_SEND_SENSORS
// for further specific illustration.

// Called for each received bit from the dn_rx direction (from the module controller)
void Celldn_rxDataBit(uint8_t u8DataBit)
{
	sg_u16BatteryVoltageMsg <<= 1;
	sg_u16BatteryVoltageMsg |= u8DataBit;
	sg_u8dn_rxBitCount++;

	// Special case after reception of the second data bit - if this is
	// a request for a reading, then signal the foreground code to do
	// a sensor reading. This hastens the response time of the initial request.

	if (2 == sg_u8dn_rxBitCount)
	{
		// After the second bit, let's see if we send a report. If so, then flag it
		// and record the type. The shift is necessary because we haven't received all 
		// 16 bits yet - just look at the two that we've received.
		if (sg_u16BatteryVoltageMsg & (MSG_CELL_SEND_REPORT >> 14))
		{
			// Indicates we want the cell CPU to send a report. Figure out which type.
			if (sg_u16BatteryVoltageMsg & (MSG_CELL_SEND_PATTERN >> 14))
			{
				sg_eCellAction = EACTION_SEND_PATTERN;
			}
			else
			{
				// Send an actual sensor reading. On the CPU at the end of the
				// chain, this will cause a reading to occur, then it will
				// originate transmission up the chain by sending its reading
				// to the next neighboring CPU. If it's not the CPU on the end,
				// it will simply perform the reading and wait for the downstream
				// message to append itself to.
				sg_eCellAction = EACTION_SEND_SENSOR_READING;
			}
		}
		else
		{
			// This is a new discharge target - ignore it
		}
	}
	else
	if (16 == sg_u8dn_rxBitCount)
	{
		if (sg_u16BatteryVoltageMsg & MSG_CELL_SEND_REPORT)
		{
			// We don't do anything because it already happened at bit 2 above.
		}
		else
		{
			// New voltage target - no need to mask off the upper bits since they'll be 0 here
			sg_u16BatteryVoltageTarget = sg_u16BatteryVoltageMsg;
		}
		
		sg_u16BatteryVoltageMsg = 0;
	}
}

/*
static void PinSetup(void)
{
	cli();
	
	// Set up up_tx and dn_tx as outputs
	PIN_CELL_UP_TX_DDR |= (1 << PIN_CELL_UP_TX);
	PIN_CELL_DN_TX_DDR |= (1 << PIN_CELL_DN_TX);
	
	// And SCL/SDA
	I2C_PORT_DDR |= (1 << I2C_SDA_PIN) | (1 << I2C_SCL_PIN);
	// And pullups
	I2C_PORT |= (1 << I2C_SDA_PIN) | (1 << I2C_SCL_PIN);

	// Set up cell_dn_rx and cell_up_rx as inputs and turn on pullups
	PIN_CELL_DN_RX_DDR &= ~(1 << PIN_CELL_DN_RX);
	PIN_CELL_DN_RX_PORT |= (1 << PIN_CELL_DN_RX);
	
	PIN_CELL_UP_RX_DDR &= ~(1 << PIN_CELL_UP_RX);
	PIN_CELL_UP_RX_PORT |= (1 << PIN_CELL_UP_RX);
}

// Endlessly toggles all outputs
static void ToggleAllOutputs(void)
{
	PinSetup();
	
	while (1)
	{
		CELL_UP_TX_ASSERT();
		CELL_DN_TX_ASSERT();
		SCL_LOW();
		SDA_LOW();
		CELL_UP_TX_DEASSERT();
		CELL_DN_TX_DEASSERT();
		SCL_HIGH();
		SDA_HIGH();
	}
}

// Mirror cell_dn_rx->cell_up_tx and cell_up_rx->cell_dn_tx
static void InputMirror(void)
{
	PinSetup();
	
	while (1)
	{
		if (IS_PIN_CELL_DN_RX_ASSERTED())
		{
			CELL_UP_TX_ASSERT();
		}
		else
		{
			CELL_UP_TX_DEASSERT();
		}
		
		if (IS_PIN_CELL_UP_RX_ASSERTED())
		{
			CELL_DN_TX_ASSERT();
		}
		else
		{
			CELL_DN_TX_DEASSERT();
		}
	}
}
*/

int main(void)
{
	// Stop all interrupts
	cli();
	
	// Shut off the watchdog timer and reset reason
	MCUSR = 0;
	DISABLE_WDT();
	
	// Init CPU clock
	CPU_CLOCK_INIT();
	
	// Ensure pullups aren't globally disabled
	MCUCR &= (uint8_t) ~(1 << PUD);
	
	// Initialize virtual UART pins
	vUARTPinInit();
	
    // Set the ADC input to MUX_SELECT
    ADC_ADMUX_SET();
	
	// Drive cell_dn_tx low. This is required so we can detect if we're end-of-chain
	// or not.
	CELL_DN_TX_ASSERT();
	
	// Now init timer B
	TIMER_INIT();
	
	// Set battery target voltage so the event/discharge is forced off
	sg_u16BatteryVoltageTarget = 0xffff;
	
	// This will cause discharge to get shut off initially
	sg_bDischargeActive = true;

	// Turn on interrupt functionality but no specific interrupts
	INT_ENABLE();
	
	// First thing is an init/sensor read
	sg_eCellAction = EACTION_INIT;
	sg_bCellCPULast = true;  // assume we're last in the chain

	// Enable CPU interrupts
	sei();
	
	// Hang on forever!
	while (1)
	{
		uint16_t u16Voltage;
		uint16_t u16Temperature;

		if ((EACTION_SEND_SENSOR_READING == sg_eCellAction) ||
			(EACTION_SEND_PATTERN == sg_eCellAction) || 
			(EACTION_INIT == sg_eCellAction))
		{
			bool bDischargeActive = false;
			
			// Read the voltage first since the MUX is switched to the ADC
			// by default
			u16Voltage = ADCRead();
			sg_u16BatteryVoltage = u16Voltage;
			
			if ((EACTION_INIT == sg_eCellAction) && (true == IS_PIN_CELL_UP_RX_ASSERTED()))  // do a quick detect prior to sensor read, but check again after
			{
				// Pin is asserted, we're NOT the last CPU
				sg_bCellCPULast = false;
			}

			
			// Now temperature
			u16Temperature = MCP9843ReadTemperature();

			// Analog channel is now an input
			SCL_DISABLE();
			
			// Set SCL back to analog input
			ADC_ADMUX_SET();
			
			if ((EACTION_INIT == sg_eCellAction) && (true == IS_PIN_CELL_UP_RX_ASSERTED()))  // do a quick detect prior to possible event set, it may happen on some cells but not others
			{
				// Pin is asserted, we're NOT the last CPU
				sg_bCellCPULast = false;
			}
			
			
			// While we have I2C operational, let's evaluate the discharge
			// state and change it if it's updated
			if (u16Voltage > sg_u16BatteryVoltageTarget)
			{
				bDischargeActive = true;
			}
			
			// If the discharge state has changed, tell the MCP9843 about it
			if (bDischargeActive != sg_bDischargeActive)
			{
				sg_bDischargeActive = bDischargeActive;
				
				// Discharge is active LOW on the EVENT pin
				MCP9843SetEventPin(sg_bDischargeActive ? false : true);
				
				// Analog channel is now an input
				SCL_DISABLE();
			
				// Set SCL back to analog input
				ADC_ADMUX_SET();
			}
			
			// If we're discharging, update the battery voltage message
			if (sg_bDischargeActive)
			{
				// Set the upper bit to indicate we're actively discharging
				u16Voltage |= MSG_CELL_DISCHARGE_ACTIVE;
			}
			
			// If this is set, it will originate (or propagate) a pattern
			if (EACTION_SEND_PATTERN == sg_eCellAction)
			{
				sg_u16BatteryTemperature = PATTERN_TEMPERATURE;
				sg_u16BatteryVoltage = PATTERN_VOLTAGE;
			}
			else
			{
				// We're sending the actual reading
				sg_u16BatteryTemperature = u16Temperature;
				sg_u16BatteryVoltage = u16Voltage;
			}
		
			// If we're just initializing, go back to sleep. We only needed
			// the first pass to set the discharge/charge state
			// do a sample window for last cpu detection to account for any differences in arriving at this point between adjacent cpus due to I2C
			if (EACTION_INIT == sg_eCellAction)
			{
				uint8_t sample_count = 10;  //number of times to sample UP_RX for last cpu detection
				sg_eCellAction = EACTION_NONE;
				
				// sample every 1ms
				while (sample_count--)
				{
				// If at any point we see the pin asserted, we're NOT the last
					if (true == IS_PIN_CELL_UP_RX_ASSERTED())
					{
						// Pin is asserted, we're NOT the last CPU
						sg_bCellCPULast = false;
					}
					Delay(1000);  //this also gives the cell below more time to detect us
				}

				
				// If we're not the last cell CPU, turn on receive interrupts
				if (false == sg_bCellCPULast)
				{
					// Initialize the UART for receive operation (from cell CPUs to module CPUs)
					vUARTInitReceive();
				}
				else
				{
					// Last cell CPU in the chain - not needed and will just generated spurious
					// interrupts.
				}
		
				
				// Initialize transmit communication for module->cell->cell... communication				
				vUARTInitTransmit(); // this also deasserts DN_TX, so this is the end of last detect sample window for cell below
			}
			else
			{
				// We're doing a send of the data!
				sg_eCellAction = EACTION_INITIATE_TRANSMIT;
			}
		}
	
		if (EACTION_INITIATE_TRANSMIT == sg_eCellAction)
		{
			sg_eCellAction = EACTION_NONE;
			
			
			// If we're the last CPU, then we initiate transmit, otherwise we
			// don't do anything - we wait for the last CPU to start the message
			// transmission.
			if (true == sg_bCellCPULast)
			{
				// While we're receiving something, don't transmit anything. In practice, this
				// should never loop, but during development, it might.
				while (vUARTIscell_dn_rxActive());
				
				// Start transmission. Note this routine stops and starts interrupts, too.
				vUARTStartcell_dn_tx(VUART_BIT_TICKS/2);
			}
		}
		
		// SLEEP - The CPU will wake up on the next interrupt
		set_sleep_mode(SLEEP_MODE_IDLE);
		sleep_mode();
	}
}

// NOTE: If you're getting unexpected AVR resets, uncomment these unused handlers to see
// if another interrupt is being taken that doesn't have a handler. AVR Defaults to jumping
// to 0 when not vector is programmed.

ISR(INT0_vect, ISR_BLOCK)
{
	while (1);
}

ISR(TIMER1_OVF_vect, ISR_BLOCK)
{
	while (1);
}

ISR(TIMER0_OVF_vect, ISR_BLOCK)
{
	while (1);
}

ISR(USI_START_vect, ISR_BLOCK)
{
	while (1);
}

ISR(USI_OVF_vect, ISR_BLOCK)
{
	while (1);
}

ISR(EE_RDY_vect, ISR_BLOCK)
{
	while (1);
}

ISR(ANA_COMP_vect, ISR_BLOCK)
{
	while (1);
}

ISR(INT1_vect, ISR_BLOCK)
{
	while (1);
}

ISR(TIMER0_CAPT_vect, ISR_BLOCK)
{
	while (1);
}

ISR(TIMER1_COMPD_vect, ISR_BLOCK)
{
	while (1);
}

ISR(FAULT_PROTECTION_vect, ISR_BLOCK)
{
	while (1);
}
/* CellCPU
 *
 * Cell controller firmware - MCP9843 driver
 *
 * (C) Copyright 2023-2024 Modular Battery Technologies, Inc.
 * US Patents 11,380,942; 11,469,470; 11,575,270; others. All
 * rights reserved
 */

#include <stdint.h>
#include <xc.h>
#include <stdbool.h>
#include <avr/io.h>
#include <avr/interrupt.h>
#include "I2c.h"
#include "mcp9843.h"
#include "../Shared/Shared.h"

// Slave address
#define MCP9843_SLAVE_ADDRESS_SENSOR	0x30
#define MCP9843_SLAVE_ADDRESS_EEPROM	0xa0
#define MCP9843_SLAVE_ADDRESS_WP		0x60

// Register definitions
#define MCP9843REG_CAPBILITIES			0x00
#define MCP9843REG_CONFIG				0x01
#define MCP9843REG_EVENT_LOWER			0x02
#define MCP9843REG_EVENT_HIGHER			0x03
#define MCP9843REG_CRIT_TEMP_TRIP		0x04
#define MCP9843REG_TEMP					0x05
#define MCP9843REG_MFG_ID				0x06
#define MCP9843REG_DEV_ID				0x07
#define MCP9843REG_RESOLUTION			0x08

// _CONFIG bits

// Byte 1 (bits 8-15) - MSB
#define MCP9843REG_CONFIG_SHUTDOWN		(1 << 0)
#define	MCP9843REG_CONFIG_HYST_0		(0 << 1)
#define	MCP9843REG_CONFIG_HYST_1_5		(0x01 << 1)
#define	MCP9843REG_CONFIG_HYST_3_0		(0x02 << 1)
#define	MCP9843REG_CONFIG_HYST_6_0		(0x03 << 1)

// Byte 2 (bits 0-7) - LSB
#define MCP9843REG_CONFIG_OUTPUT_STATUS	(1 << 4)
#define MCP9843REG_CONFIG_EV_ENABLE		(1 << 3)
#define MCP9843REG_CONFIG_EV_POLARITY	(1 << 1)

// This is the default configuration bytes for the system
#define MCP9843_CONFIG_DEFAULT_MSB		(MCP9843REG_CONFIG_HYST_0)
#define MCP9843_CONFIG_DEFAULT_LSB		(MCP9843REG_CONFIG_EV_POLARITY | MCP9843REG_CONFIG_EV_ENABLE | MCP9843REG_CONFIG_OUTPUT_STATUS)

// Sets the register pointer to the incoming value, ready for subsequent transactions.
// Routine returns true if the device acknowledged the transactions, otherwise false
// is returned.
static bool MCP9843SetSensorRegister(uint8_t u8Register,
									 bool bRead)
{
	// Attempt to start a transaction
	if (false == I2CStartTransaction(MCP9843_SLAVE_ADDRESS_SENSOR,
									 bRead))
	{
		return(false);
	}
	
	// Now write the register. Since we're the master, we're monitoring ACK from the slave.
	if (false == I2CTxByte(u8Register))
	{
		// Not good.
		return(false);
	}
	
	return(true);
}

// This sets the EVENT pin either high or low depending on the input signal. The 
// logic requires that the thresholds are NOT triggered, as it uses the 
bool MCP9843SetEventPin(bool bHigh)
{
#if defined(__AVR_ATtiny261A__)
	return(true);
#else
	bool bResult = false;
	volatile uint8_t u8ConfigByteLSB = MCP9843_CONFIG_DEFAULT_LSB;
	
	// Set up the output pins for I2C operation
	I2CSetup();
	
	// Write the configuration register
	if (false == MCP9843SetSensorRegister(MCP9843REG_CONFIG,
										  false))
	{
		goto i2cFail;
	}
	
	// Config MSB
	if (false == I2CTxByte(MCP9843_CONFIG_DEFAULT_MSB))
	{
		goto i2cFail;
	}
	
	if (bHigh)
	{
		u8ConfigByteLSB |= MCP9843REG_CONFIG_EV_POLARITY;
	}
	else
	{
		u8ConfigByteLSB &= (uint8_t) (~MCP9843REG_CONFIG_EV_POLARITY);
	}
	
	// Config LSB
	if (false == I2CTxByte(u8ConfigByteLSB))
	{
		goto i2cFail;
	}
	
	// Indicate we're OK
	bResult = true;
	
	// And a stop condition
i2cFail:
	I2CStop();
	
	return(bResult);
#endif
}

// Reads the temperature from the MCP9843 in increments of 0.0625C degrees
// Bits 0-3  - 16ths of a degree C
// Bits 4-11 - Whole degrees C
// Bit 12    - Temperature sign bit - 0=Positive, 1=Negative
// Bits 13-14- Always 0
// Bit 15    - 1=Reading of temperature is valid, 0=Not valid
int16_t MCP9843ReadTemperature(void)
{
	int16_t s16Temperature;
	
#if defined(__AVR_ATtiny261A__)
	// Let's try 23.5 degrees
	s16Temperature = (23 << 4) | (0x08);
#else
	// Set up the output pins for I2C operation
	I2CSetup();
	
	// Write the temperature register
	if (false == MCP9843SetSensorRegister(MCP9843REG_TEMP,
										  false))
	{
		// Not valid
		return(0);											  
	}

	I2CStop();
	
	// Attempt to start a transaction
	if (false == I2CStartTransaction(MCP9843_SLAVE_ADDRESS_SENSOR,
									 true))
	{
		// Not valid
		return(0);
	}
	
	// Now read MSB/LSB
	s16Temperature = I2CRxByte(true) << 8;
	s16Temperature |= I2CRxByte(false);
	
	// Now the stop condition
	I2CStop();

	// Mask off the tcrit/tupper/tlower bits - they aren't useful
#endif
	s16Temperature &= 0xfff;
	s16Temperature |= MSG_CELL_TEMP_I2C_OK;
	
	return(s16Temperature);
}
/* CellCPU
 *
 * Cell controller firmware - Virtual UART module
 *
 * (C) Copyright 2023-2024 Modular Battery Technologies, Inc.
 * US Patents 11,380,942; 11,469,470; 11,575,270; others. All
 * rights reserved
 *
 * This module contains the "virtual UART" functionality, implemented with a
 * combination of bit banging, interrupts, and timers. Naming conventions are
 * from the perspective of the pack controller:
 *
 * cell_up_rx (PB4) -> cell_dn_tx (PB5) (upstream) - Receives/relays cell status, to be sent to the pack controller
 * cell_dn_rx (PB1) -> cell_up_tx (PB0) (downstream) - Receives/relays messages from the pack controller 
 *
 * For each byte received, the format is as follows:
 *
 * 1 Start bit
 * 8 Data bits
 * 1 Stop bit (asserted=more coming, deasserted=nothing coming)
 * 1 Guard bit (always deasserted so there is transition time between bits)
 * 
 * The stop bit has a unique use, in that if it's a 1, it means more data is coming.
 * If it's a 0, there's no more data, leaving open the opportunity for the 
 * current controller to append more data.
 *
 * Timer0 is used for both upstream and downstream activity. Upstream is
 * handled by compare A, and downstream compare B. Timer0 is set to free run
 * and is NOT reset by a match to either channel.
 *
 * Reception of a byte is documented as follows:
 * 
 * 1) RX Line has a falling edge, causes a GPIO interrupt
 * 2) GPIO RX Pin is masked for interrupt operation
 * 3) Timer is set to TCNT0 + VUART_BIT_TICKS + (VUART_BIT_TICKS / 2) to set up
 * 4) When a timer/counter interrupt expires, sample RX pin
 * 5) Set equivalent TX pin to the same value (to pass it through)
 * 6) Timer is set to TCNT0 + VUART_BIT_TICKS, repeat until all 8 bits are received
 * 7) On the 9th bit, sample the RX pin. If it's 1, more data is coming, go back to step
 *    1. If it's 0, continue on to step 9.
 * 9) Deassert cell_dn_tx. Wait 1 bit time, advance to 10.
 * 10) Transmit/append local battery data.
 */

#include "Platform.h"
#include "vUART.h"
#include "main.h"

// States for the receive state machine
typedef enum
{
	ESTATE_IDLE,				// Bus is completely idle and nothing is running
	ESTATE_RX_DATA,				// Bus is receiving data from cell_up_rx/cell_dn_rx
	ESTATE_TX_DATA,				// Bus is transmitting data to cell_dn_tx/cell_up_tx
	ESTATE_NEXT_BYTE,			// Bus is active (transmitting or receiving) but in between bytes and more data coming
} EChannelState;

// States of each channel

// cell_up_rx related
static uint8_t sg_u8Cell_up_rxBitCount;
static bool sg_bcell_up_rxPriorState;
static volatile EChannelState sg_ecell_up_rxState = ESTATE_IDLE;
static bool sg_bCell_up_rxMoreData;
static bool sg_bcell_up_rx_Enabled;

// cell_dn_rx related
static uint8_t sg_u8Cell_dn_rxBitCount;
static bool sg_bcell_dn_rxPriorState;
static volatile EChannelState sg_ecell_dn_rxState = ESTATE_IDLE;
static bool sg_bCell_dn_rxMoreData;

// cell_dn_tx related
static bool sg_bdn_txNextBit;
static uint8_t sg_u8dn_txBitCount;
static uint8_t sg_u8dn_txDataByte;
static bool sg_bdn_txMoreAvailable;

// Pin change interrupt - detecting start bit
ISR(PCINT_VECTOR, ISR_BLOCK)
{
	bool bCellUpRXAsserted = IS_PIN_CELL_UP_RX_ASSERTED();
	bool bCellDnRxAsserted = IS_PIN_CELL_DN_RX_ASSERTED();

	// If we have timers we need to start, start them at the top of the procedure	
	// so the sample times are tighter/more consistent
	if (bCellUpRXAsserted && sg_bcell_up_rx_Enabled &&
		((ESTATE_IDLE == sg_ecell_up_rxState) ||
		 (ESTATE_NEXT_BYTE == sg_ecell_up_rxState)))
	{
		// This causes a sampling in the middle of the waveform
		// and accounts for code overhead.
		TIMER_CHA_INT(VUART_BIT_TICKS);

		// Stop cell_up_rx interrupts
		INT_CELL_UP_RX_DISABLE();
		
		// We are now receiving data
		sg_ecell_up_rxState = ESTATE_RX_DATA;
		sg_bcell_up_rxPriorState = true;
		sg_u8Cell_up_rxBitCount = 0;
	}
	
	// Handle cell_dn_rx incomings
	if ((bCellDnRxAsserted) &&
		((ESTATE_IDLE == sg_ecell_dn_rxState) ||
		 (ESTATE_NEXT_BYTE == sg_ecell_dn_rxState)))
	{
		// This causes sampling closer to the middle of the waveform
		// and accounts for code overhead.
		TIMER_CHB_INT(VUART_BIT_TICKS + (VUART_BIT_TICKS / 10));

		// Stop cell_dn_rx interrupts
		INT_CELL_DN_RX_DISABLE();
		
		// Only call the data start routine when it's the actual start of the initial
		// byte, not subsequent bytes.
		if (ESTATE_IDLE == sg_ecell_dn_rxState)
		{
			// Falling edge on cell_dn_rx
			Celldn_rxDataStart();
		}
		
		// Set the RX data state
		sg_ecell_dn_rxState = ESTATE_RX_DATA;
		sg_bcell_dn_rxPriorState = true;
		sg_u8Cell_dn_rxBitCount = 0;
	}
}

// Timer 0 compare A interrupt (bit clock) for cell_up_rx
ISR(TIMER_COMPA_VECTOR, ISR_BLOCK)
{
	TIMER_CHA_INT(VUART_BIT_TICKS-6);
	if (ESTATE_RX_DATA == sg_ecell_up_rxState)
	{
		// Set the bit value for what the prior state was
		if (sg_bcell_up_rxPriorState)
		{
			CELL_DN_TX_ASSERT();
		}
		else
		{
			CELL_DN_TX_DEASSERT();
		}
		
		sg_bcell_up_rxPriorState = IS_PIN_CELL_UP_RX_ASSERTED();
	
		sg_u8Cell_up_rxBitCount++;
		
		// Handles incoming start bit and data bits
		if (sg_u8Cell_up_rxBitCount < 9)
		{
			// Data bits
			return;
		}
		else
		if (9 == sg_u8Cell_up_rxBitCount)
		{
			// This is the more data vs. data stop bit
			sg_bCell_up_rxMoreData = sg_bcell_up_rxPriorState;
			
			// Always ensure that we're signaling more data since the termination
			// bit is done in the transmit phase
			sg_bcell_up_rxPriorState = true;
			return;
		}
		else
		if (10 == sg_u8Cell_up_rxBitCount)
		{
			// Deassert the dn_tx signal (guard bit)
			sg_bcell_up_rxPriorState = false;
			return;
		}
		else
		if (11 == sg_u8Cell_up_rxBitCount)
		{
			// Only way to get here is if we have more data. We are now at the start of a start
			// cycle now and we can reenable interrupts on cell_up_rx so we wait for the
			// start of the next byte.
			TIMER_CHA_INT_DISABLE();
			
			// Enable cell_up_rx interrupts
			INT_CELL_UP_RX_ENABLE();
				
			if (sg_bCell_up_rxMoreData)
			{
				// Flag that more data is coming
				sg_ecell_up_rxState = ESTATE_NEXT_BYTE;
			}
			else
			{
				// Bus is now idle		
				sg_ecell_up_rxState = ESTATE_IDLE;
				
				// Start transmission of our data
				(void) vUARTStartcell_dn_tx(VUART_BIT_TICKS*3);
			}
		}
		
		return;
	} 
	
	// This handles the transmission of data when this CPU originates it
	if (ESTATE_TX_DATA == sg_ecell_up_rxState)
	{
		// Set the state of the output pin
		if (sg_bdn_txNextBit)
		{
			CELL_DN_TX_ASSERT();
		}
		else
		{
			CELL_DN_TX_DEASSERT();
		}
		
		// Preincrement the bit count 
		sg_u8dn_txBitCount++;

		// Transmit start condition and prepare data byte
		// If this is the first bit, fetch the byte
		if( sg_u8dn_txBitCount < 9 )
		{
			// Transmit data! (msb first)
			if (sg_u8dn_txDataByte & 0x80)
			{
				sg_bdn_txNextBit = true;
			}
			else
			{
				sg_bdn_txNextBit = false;
			}
			
			sg_u8dn_txDataByte <<= 1;
			return;
		}
		// Transmit stop bit (stop or continue!)
		else 
		if (9 == sg_u8dn_txBitCount)
		{
			sg_bdn_txNextBit = sg_bdn_txMoreAvailable;
			return;
		}
		else 
		if (10 == sg_u8dn_txBitCount)
		{
			// Guard bit
			sg_bdn_txNextBit = false;
			return;
		}
		else
		if (11 == sg_u8dn_txBitCount)
		{
			// Already deasserted here
			sg_u8dn_txBitCount = 0;

			TIMER_CHA_INT_DISABLE();
				
			// If more available, reset the bit count and exit
			if (false == sg_bdn_txMoreAvailable)
			{
				sg_ecell_up_rxState = ESTATE_IDLE;

				// Terminate! stop the timer interrupts and reenable port pin interrupts
				CELL_DN_TX_DEASSERT();
			
				// Allow reception of the cell_up_rx path again
				INT_CELL_UP_RX_ENABLE();
				
				// Bail out - don't continue to process anything since it's idle
				CELL_UP_TX_DEASSERT();
				return;
			}
			else
			{
				// Set the timer 2 bits later - this can be sloppy since it's in between bytes
				TIMER_CHA_INT(VUART_BIT_TICKS*4);

				// Get the next data byte and whether or not
				sg_u8dn_txDataByte = Celldn_txDataGet();
				sg_bdn_txMoreAvailable = Celldn_txDataAvailable();
				sg_bdn_txNextBit = true;
			}
		}

		return;
	}
	
	// Stop the timer - not necessary
	TIMER_CHA_INT_DISABLE();
}

// Timer 0 compare B interrupt (bit clock) for cell_dn_rx
ISR(TIMER_COMPB_VECTOR, ISR_BLOCK)
{
	bool bData;
	
	TIMER_CHB_INT(VUART_BIT_TICKS-6);
		
	// Set the bit value for what the prior state was
	if (sg_bcell_dn_rxPriorState)
	{
		CELL_UP_TX_ASSERT();
	}
	else
	{
		CELL_UP_TX_DEASSERT();
	}

	bData = sg_bcell_dn_rxPriorState;
	sg_bcell_dn_rxPriorState = IS_PIN_CELL_DN_RX_ASSERTED();
	
	sg_u8Cell_dn_rxBitCount++;
	
	// Handles cell_dn_rx
	if (1 == sg_u8Cell_dn_rxBitCount)
	{
		// Start bit
	}
	else
	if (sg_u8Cell_dn_rxBitCount < 10)
	{
		Celldn_rxDataBit(bData);
		return;
	}
	else
	if (10 == sg_u8Cell_dn_rxBitCount)
	{
		// This is the more data vs. data stop bit
		sg_bCell_dn_rxMoreData = sg_bcell_dn_rxPriorState;
		return;
	}
	else
	if (11 == sg_u8Cell_dn_rxBitCount)
	{
		// No longer asserted
		sg_bcell_dn_rxPriorState = false;
		return;
	}
	else
	if (12 == sg_u8Cell_dn_rxBitCount)
	{
		TIMER_CHB_INT_DISABLE();
		
		// Enable cell_dn_rx for next byte
		INT_CELL_DN_RX_ENABLE();
		
		if (false == sg_bCell_dn_rxMoreData)
		{
			// Bus is now idle
			sg_ecell_dn_rxState = ESTATE_IDLE;
		}
		else
		{
			// Flag that more data is coming
			sg_ecell_dn_rxState = ESTATE_NEXT_BYTE;
		}

		return;
	}
}

// This starts a transmission on cell_dn_tx. true Is returned if it 
// was successfully started, but false if the cell_dn_tx vUART is active.
bool vUARTStartcell_dn_tx(uint8_t u8StartDelayTicks)
{
	bool bReturnCode = false;

	// Is our cell_up_rx->cell_dn_tx path busy? If so, we can't start
	if (ESTATE_IDLE == sg_ecell_up_rxState)
	{
		// Shut off cell_up_rx interrupts coming from up stream so we don't hit a
		// spurious interrupt while we're transmitting
		INT_CELL_UP_RX_DISABLE();

		bReturnCode = true;
		
		// Set the state machine to transmit data.
		sg_ecell_up_rxState = ESTATE_TX_DATA;

		// Ensure the first bit is a start bit		
		sg_bdn_txNextBit = true;

		// Let the consumer code know that a transmission is starting
		Celldn_txDataReset();
		
		// Seed any data to transmit
		sg_u8dn_txDataByte = Celldn_txDataGet();
		sg_bdn_txMoreAvailable = Celldn_txDataAvailable();

		// Clear our dn_tx bit count
		sg_u8dn_txBitCount = 0;
		
		// Start up timer A to fire a half a bit later (if it's sloppy, that's OK)
		TIMER_CHA_INT(u8StartDelayTicks);		
	}
	
	return(bReturnCode);
}

void vUARTPinInit(void)
{
	// Set up cell_dn_rx
	PIN_CELL_DN_RX_DDR &= ((uint8_t) ~(1 << PIN_CELL_DN_RX));	// Set as input
#if defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__)
	PIN_CELL_DN_RX_PORT &= ((uint8_t) ~(1 << PIN_CELL_DN_RX));	// Turn off pullup
#elif defined(__AVR_ATtiny261A__)
	PIN_CELL_DN_RX_PORT |= ((uint8_t) (1 << PIN_CELL_DN_RX));	// Turn on pullup
#else
#error No target processor defined or target processor type unknown
#endif
		
	// Set up cell_up_tx
	PIN_CELL_UP_TX_DDR |= (1 << PIN_CELL_UP_TX);	// Set as output
#if defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__)
	PIN_CELL_UP_TX_PORT &= ((uint8_t) ~(1 << PIN_CELL_UP_TX));	// Turn off pullup
#elif defined(__AVR_ATtiny261A__)
	PIN_CELL_UP_TX_PORT |= ((uint8_t) (1 << PIN_CELL_UP_TX));	// Turn on pullup
#else
#error No target processor defined or target processor type unknown
#endif
	CELL_UP_TX_DEASSERT();							// Deassert cell_up_tx
	
	// Set up cell_up_rx
	PIN_CELL_UP_RX_DDR &= ((uint8_t) ~(1 << PIN_CELL_UP_RX));	// Set as input
#if defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__)
	PIN_CELL_UP_RX_PORT &= ((uint8_t) ~(1 << PIN_CELL_UP_RX));	// Turn off pullup
#elif defined(__AVR_ATtiny261A__)
	PIN_CELL_UP_RX_PORT |= ((uint8_t) (1 << PIN_CELL_UP_RX));	// Turn on pullup
#else
#error No target processor defined or target processor type unknown
#endif
	
	// Set up cell_dn_tx
	PIN_CELL_DN_TX_DDR |= (1 << PIN_CELL_DN_TX);	// Set as output
#if defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__)
	PIN_CELL_DN_TX_PORT &= ((uint8_t) ~(1 << PIN_CELL_DN_TX));	// Turn off pullup
#elif defined(__AVR_ATtiny261A__)
	PIN_CELL_DN_TX_PORT |= ((uint8_t) (1 << PIN_CELL_DN_TX));	// Turn on pullup
#else
#error No target processor defined or target processor type unknown
#endif

	CELL_DN_TX_DEASSERT();							// Deassert cell_dn_tx

	// Fire up the profiler (if available)
	PROFILER_INIT();
}

bool vUARTIscell_dn_rxActive(void)
{
	if (ESTATE_IDLE == sg_ecell_dn_rxState)
	{
		return(false);
	}
	else
	{
		return(true);
	}
}

// Enables transmit communication from module CPU to cell CPU
void vUARTInitTransmit(void)
{
	// Fire up the profiler (if available)
	PROFILER_INIT();

	// Cell_dn_rx to allow receives. We do not need cell_up_tx interrupts
	INT_CELL_DN_RX_ENABLE();
}

// Enables receive communication from cell CPUs to module CPU
void vUARTInitReceive(void)
{
	sg_bcell_up_rx_Enabled = true;
	
	// Set up receives in the cell_up_tx direction
	INT_CELL_UP_RX_ENABLE();
	
	// Ready to rock!	
}